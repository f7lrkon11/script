pcall(function()
	if setfpscap then
		setfpscap(240)
	end
end)

local LoadingTick = os.clock()
local getgenv = getgenv or function()
	return _G
end
local genv = getgenv()

local writefile = writefile or function() end
local readfile = readfile or function() return "" end
local listfiles = listfiles or function() return {} end
local makefolder = makefolder or function() end
local delfile = delfile or function() end
local isfile = isfile or function() return false end
local isfolder = isfolder or function() return false end

if not game.HttpGet then
	game.HttpGet = function() return "" end
end

if genv and genv.Library and genv.Library.Unload then
	genv.Library:Unload()
end
local Library do
	local UserInputService = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	local Workspace = game:GetService("Workspace")
	local HttpService = game:GetService("HttpService")
	local TweenService = game:GetService("TweenService")
	local cloneref = cloneref or function(obj)
		return obj
	end
	local CoreGui = cloneref(game:GetService("CoreGui"))
	gethui = gethui or function()
		return CoreGui
	end
	local LocalPlayer = Players.LocalPlayer
	local Camera = Workspace.CurrentCamera
	local Mouse = LocalPlayer:GetMouse()
	local FromRGB = Color3.fromRGB
	local FromHSV = Color3.fromHSV
	local FromHex = Color3.fromHex
	local RGBSequence = ColorSequence.new
	local RGBSequenceKeypoint = ColorSequenceKeypoint.new
	local NumSequence = NumberSequence.new
	local NumSequenceKeypoint = NumberSequenceKeypoint.new
	local UDim2New = UDim2.new
	local UDimNew = UDim.new
	local Vector2New = Vector2.new
	local InstanceNew = Instance.new
	local MathClamp = math.clamp
	local MathFloor = math.floor
	local TableInsert = table.insert
	local TableFind = table.find or function(t, value)
		for i, v in ipairs(t) do
			if v == value then
				return i
			end
		end
		return nil
	end
	local TableRemove = table.remove
	local TableConcat = table.concat
	local TableUnpack = unpack or table.unpack
	local StringFormat = string.format
	local StringFind = string.find
	local StringGSub = string.gsub
	Library = {
		Flags = { },
		Theme = {
			["Background"] = FromRGB(10, 10, 10),
			["Inline"] = FromRGB(15, 15, 15),
			["Page Background"] = FromRGB(20, 20, 20),
			["Border"] = FromRGB(5, 5, 5),
			["Outline"] = FromRGB(25, 5, 5),
			["Accent"] = FromRGB(255, 0, 0),
			["Element"] = FromRGB(18, 18, 18),
			["Hovered Element"] = FromRGB(30, 5, 5),
			["Text"] = FromRGB(255, 255, 255),
			["Text Border"] = FromRGB(0, 0, 0)
		},
		MenuKeybind = Enum.KeyCode.Z, 
		Tween = {
			Time = 0.3,
			Style = Enum.EasingStyle.Exponential,
			Direction = Enum.EasingDirection.Out
		},
		Folders = {
			Directory = "scriptname",
			Configs = "scriptname/Configs",
			Assets = "scriptname/Assets"
		},
		Images = {
			["Saturation"] = {"Saturation.png", "https://github.com/sametexe001/images/blob/main/saturation.png?raw=true" },
			["Value"] = { "Value.png", "https://github.com/sametexe001/images/blob/main/value.png?raw=true" },
			["Hue"] = { "Hue.png", "https://github.com/sametexe001/images/blob/main/hue.png?raw=true" },
			["Scrollbar"] =  { "Scrollbar.png", "https://github.com/sametexe001/images/blob/main/scrollbar.png?raw=true" },
			["Checkers"] = { "Checkers.png", "https://github.com/sametexe001/images/blob/main/checkers.png?raw=true" },
			["Resize"] = { "Resize.png", "https://github.com/sametexe001/images/blob/main/resize.png?raw=true" },
		},
		Pages = { },
		Sections = { },
		Connections = { },
		Threads = { },
		ThemeMap = { },
		ThemeItems = { },
		SetFlags = { },
		UnnamedConnections = 0,
		UnnamedFlags = 0,
		Holder = nil,
		NotifHolder = nil,
		Font = nil,
		KeyList = nil,
		CurrentColorpicker = nil
	}
	Library.__index = Library
	Library.Sections.__index = Library.Sections
	Library.Pages.__index = Library.Pages
	local Keys = {
		["Unknown"]           = "Unknown",
		["Backspace"]         = "Back",
		["Tab"]               = "Tab",
		["Clear"]             = "Clear",
		["Return"]            = "Return",
		["Pause"]             = "Pause",
		["Escape"]            = "Escape",
		["Space"]             = "Space",
		["QuotedDouble"]      = '"',
		["Hash"]              = "#",
		["Dollar"]            = "$",
		["Percent"]           = "%",
		["Ampersand"]         = "&",
		["Quote"]             = "'",
		["LeftParenthesis"]   = "(",
		["RightParenthesis"]  = " )",
		["Asterisk"]          = "*",
		["Plus"]              = "+",
		["Comma"]             = ",",
		["Minus"]             = "-",
		["Period"]            = ".",
		["Slash"]             = "`",
		["Three"]             = "3",
		["Seven"]             = "7",
		["Eight"]             = "8",
		["Colon"]             = ":",
		["Semicolon"]         = ";",
		["LessThan"]          = "<",
		["GreaterThan"]       = ">",
		["Question"]          = "?",
		["Equals"]            = "=",
		["At"]                = "@",
		["LeftBracket"]       = "LeftBracket",
		["RightBracket"]      = "RightBracked",
		["BackSlash"]         = "BackSlash",
		["Caret"]             = "^",
		["Underscore"]        = "_",
		["Backquote"]         = "`",
		["LeftCurly"]         = "{",
		["Pipe"]              = "|",
		["RightCurly"]        = "}",
		["Tilde"]             = "~",
		["Delete"]            = "Delete",
		["End"]               = "End",
		["KeypadZero"]        = "Keypad0",
		["KeypadOne"]         = "Keypad1",
		["KeypadTwo"]         = "Keypad2",
		["KeypadThree"]       = "Keypad3",
		["KeypadFour"]        = "Keypad4",
		["KeypadFive"]        = "Keypad5",
		["KeypadSix"]         = "Keypad6",
		["KeypadSeven"]       = "Keypad7",
		["KeypadEight"]       = "Keypad8",
		["KeypadNine"]        = "Keypad9",
		["KeypadPeriod"]      = "KeypadP",
		["KeypadDivide"]      = "KeypadD",
		["KeypadMultiply"]    = "KeypadM",
		["KeypadMinus"]       = "KeypadM",
		["KeypadPlus"]        = "KeypadP",
		["KeypadEnter"]       = "KeypadE",
		["KeypadEquals"]      = "KeypadE",
		["Insert"]            = "Insert",
		["Home"]              = "Home",
		["PageUp"]            = "PageUp",
		["PageDown"]          = "PageDown",
		["RightShift"]        = "RightShift",
		["LeftShift"]         = "LeftShift",
		["RightControl"]      = "RightControl",
		["LeftControl"]       = "LeftControl",
		["LeftAlt"]           = "LeftAlt",
		["RightAlt"]          = "RightAlt"
	}
	for _, FileName in Library.Folders do
		if not isfolder(FileName) then
			makefolder(FileName)
		end
	end
	for _, ImageData in Library.Images do
		local ImageName = ImageData[1]
		local ImageLink = ImageData[2]
		if not isfile(Library.Folders.Assets .. "/" .. ImageName) then
			writefile(Library.Folders.Assets .. "/" .. ImageName, game:HttpGet(ImageLink))
		end
	end
	local Tween = { } do
		Tween.__index = Tween
		Tween.Create = function(self, Item, Info, Goal, IsRawItem)
			Item = IsRawItem and Item or Item.Instance
			Info = Info or TweenInfo.new(Library.Tween.Time, Library.Tween.Style, Library.Tween.Direction)
			local NewTween = {
				Tween = TweenService:Create(Item, Info, Goal),
				Info = Info,
				Goal = Goal,
				Item = Item
			}
			NewTween.Tween:Play()
			setmetatable(NewTween, Tween)
			return NewTween
		end
		Tween.Get = function(self)
			if not self.Tween then 
				return
			end
			return self.Tween, self.Info, self.Goal
		end
		Tween.Pause = function(self)
			if not self.Tween then 
				return
			end
			self.Tween:Pause()
		end
		Tween.Play = function(self)
			if not self.Tween then 
				return
			end
			self.Tween:Play()
		end
		Tween.Clean = function(self)
			if not self.Tween then 
				return
			end
			Tween:Pause()
			self = nil
		end
	end
	local Instances = { } do
		Instances.__index = Instances
		Instances.Create = function(self, Class, Properties)
			local NewItem = {
				Instance = InstanceNew(Class),
				Properties = Properties,
				Class = Class
			}
			setmetatable(NewItem, Instances)
			for Property, Value in NewItem.Properties do
				NewItem.Instance[Property] = Value
			end
			return NewItem
		end
		Instances.Border = function(self)
			if not self.Instance then 
				return
			end
			local Item = self.Instance
			local UIStroke = Instances:Create("UIStroke", {
				Parent = Item,
				Color = Library.Theme.Border,
				Thickness = 1,
				LineJoinMode = Enum.LineJoinMode.Miter
			})
			UIStroke:AddToTheme({Color = "Border"})
			return UIStroke
		end
		Instances.AddToTheme = function(self, Properties)
			if not self.Instance then 
				return
			end
			Library:AddToTheme(self, Properties)
		end
		Instances.ChangeItemTheme = function(self, Properties)
			if not self.Instance then 
				return
			end
			Library:ChangeItemTheme(self, Properties)
		end
		Instances.Connect = function(self, Event, Callback, Name)
			if not self.Instance then 
				return
			end
			if not self.Instance[Event] then 
				return
			end
			return Library:Connect(self.Instance[Event], Callback, Name)
		end
		Instances.Tween = function(self, Info, Goal)
			if not self.Instance then 
				return
			end
			return Tween:Create(self, Info, Goal)
		end
		Instances.Disconnect = function(self, Name)
			if not self.Instance then 
				return
			end
			return Library:Disconnect(Name)
		end
		Instances.Clean = function(self)
			if not self.Instance then 
				return
			end
			self.Instance:Destroy()
			self = nil
		end
		Instances.MakeDraggable = function(self)
			if not self.Instance then 
				return
			end
			local Gui = self.Instance
			local Dragging = false 
			local DragStart
			local StartPosition
			local DragConnection = nil
			local RunService = game:GetService("RunService")
			local function UpdatePosition()
				if Dragging and DragStart then
					local DragDeltaX = Mouse.X - DragStart.X
					local DragDeltaY = Mouse.Y - DragStart.Y
					Gui.Position = UDim2New(StartPosition.X.Scale, StartPosition.X.Offset + DragDeltaX, StartPosition.Y.Scale, StartPosition.Y.Offset + DragDeltaY)
				end
			end
			self:Connect("InputBegan", function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
					Dragging = true
					DragStart = {X = Mouse.X, Y = Mouse.Y}
					StartPosition = Gui.Position
					if not DragConnection then
						DragConnection = RunService.RenderStepped:Connect(UpdatePosition)
					end
				end
			end)
			self:Connect("InputEnded", function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
					Dragging = false
					if DragConnection then
						DragConnection:Disconnect()
						DragConnection = nil
					end
				end
			end)
			return Dragging
		end
		Instances.MakeResizeable = function(self, Minimum, Maximum)
			if not self.Instance then 
				return
			end
			local Gui = self.Instance
			local Resizing = false 
			local Start = UDim2New()
			local Delta = UDim2New()
			local ResizeMax = Gui.Parent.AbsoluteSize - Gui.AbsoluteSize
			local ResizeButton = Instances:Create("TextButton", {
				Parent = Gui,
				AnchorPoint = Vector2New(1, 1),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(0, 8, 0, 8),
				Position = UDim2New(1, 0, 1, 0),
				Name = "\0",
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				AutoButtonColor = false,
				Visible = true,
				Text = ""
			})
			ResizeButton:Connect("InputBegan", function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
					Resizing = true
					Start = Gui.Size - UDim2New(0, Input.Position.X, 0, Input.Position.Y)
				end
			end)
			ResizeButton:Connect("InputEnded", function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
					Resizing = false
				end
			end)
			local LastResizeUpdate = 0
			local ResizeTween = nil
			Library:Connect(UserInputService.InputChanged, function(Input)
				if Input.UserInputType == Enum.UserInputType.MouseMovement and Resizing then
					local CurrentTime = tick()
					if CurrentTime - LastResizeUpdate >= 0.01 then
						ResizeMax = Maximum or Gui.Parent.AbsoluteSize - Gui.AbsoluteSize
						Delta = Start + UDim2New(0, Input.Position.X, 0, Input.Position.Y)
						Delta = UDim2New(0, math.clamp(Delta.X.Offset, Minimum.X, ResizeMax.X), 0, math.clamp(Delta.Y.Offset, Minimum.Y, ResizeMax.Y))
						if ResizeTween then
							ResizeTween.Tween:Cancel()
						end
						Gui.Size = Delta
						LastResizeUpdate = CurrentTime
					end
				end
			end)
			return Resizing
		end
		Instances.OnHover = function(self, Function)
			if not self.Instance then 
				return
			end
			return Library:Connect(self.Instance.MouseEnter, Function)
		end
		Instances.OnHoverLeave = function(self, Function)
			if not self.Instance then 
				return
			end
			return Library:Connect(self.Instance.MouseLeave, Function)
		end
	end
	local CustomFont = { } do
		function CustomFont:New(Name, Weight, Style, Data)
			if isfile(Library.Folders.Assets .. "/" .. Name .. ".json") then
				return Font.new(getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".json"))
			end
			if not isfile(Library.Folders.Assets .. "/" .. Name .. ".ttf") then 
				writefile(Library.Folders.Assets .. "/" .. Name .. ".ttf", game:HttpGet(Data.Url))
			end
			local FontData = {
				name = Name,
				faces = { {
					name = "Regular",
					weight = Weight,
					style = Style,
					assetId = getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".ttf")
				} }
			}
			writefile(Library.Folders.Assets .. "/" .. Name .. ".json", HttpService:JSONEncode(FontData))
			return Font.new(getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".json"))
		end
		function CustomFont:Get(Name)
			if isfile(Library.Folders.Assets .. "/" .. Name .. ".json") then
				return Font.new(getcustomasset(Library.Folders.Assets .. "/" .. Name .. ".json"))
			end
		end
		CustomFont:New("Windows-XP-Tahoma", 200, "Regular", {
			Url = "https://github.com/sametexe001/luas/raw/refs/heads/main/fonts/windows-xp-tahoma.ttf"
		})
		Library.Font = CustomFont:Get("Windows-XP-Tahoma")
	end
	Library.Holder = Instances:Create("ScreenGui", {
		Parent = gethui(),
		Name = "\0",
		ResetOnSpawn = false
	})
	Library.NotifHolder = Instances:Create("Frame", {
		Parent = Library.Holder.Instance,
		BorderColor3 = FromRGB(0, 0, 0),
		AnchorPoint = Vector2New(0.5, 0),
		BackgroundTransparency = 1,
		Position = UDim2New(0.5, 0, 0, 0),
		Name = "\0",
		Size = UDim2New(0.34, 0, 1, -14),
		BorderSizePixel = 0,
		BackgroundColor3 = FromRGB(255, 255, 255)
	}) 
	Instances:Create("UIListLayout", {
		Parent = Library.NotifHolder.Instance,
		VerticalAlignment = Enum.VerticalAlignment.Top,
		SortOrder = Enum.SortOrder.LayoutOrder,
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
		Padding = UDimNew(0, 10)
	}) 
	Library.GetImage = function(self, Image)
		local ImageData = self.Images[Image]
		if not ImageData then 
			return
		end
		return getcustomasset(self.Folders.Assets .. "/" .. ImageData[1])
	end
	Library.Round = function(self, Number, Float)
		local Multiplier = 1 / (Float or 1)
		return MathFloor(Number * Multiplier) / Multiplier
	end
	Library.GetTransparencyPropertyFromItem = function(self, Item)
		if Item:IsA("Frame") then
			return { "BackgroundTransparency" }
		elseif Item:IsA("TextLabel") or Item:IsA("TextButton") then
			return { "TextTransparency", "BackgroundTransparency" }
		elseif Item:IsA("ImageLabel") or Item:IsA("ImageButton") then
			return { "BackgroundTransparency", "ImageTransparency" }
		elseif Item:IsA("ScrollingFrame") then
			return { "BackgroundTransparency", "ScrollBarImageTransparency" }
		elseif Item:IsA("TextBox") then
			return { "TextTransparency", "BackgroundTransparency" }
		elseif Item:IsA("UIStroke") then 
			return { "Transparency" }
		end
	end
	Library.FadeItem = function(self, Item, Property, Visibility, Speed)
		local OldTransparency = Item[Property]
		Item[Property] = Visibility and 1 or OldTransparency
		local NewTween = Tween:Create(Item, TweenInfo.new(Speed or Library.Tween.Time, Library.Tween.Style, Library.Tween.Direction), {
			[Property] = Visibility and OldTransparency or 1
		}, true)
		Library:Connect(NewTween.Tween.Completed, function()
			if not Visibility then 
				task.wait()
				Item[Property] = OldTransparency
			end
		end)
		return NewTween
	end
	Library.Unload = function(self)
		for Index, Value in self.Connections do 
			Value.Connection:Disconnect()
		end
		for Index, Value in self.Threads do 
			coroutine.close(Value)
		end
		if self.Holder then 
			self.Holder:Clean()
		end
		Library = nil 
		local genv = getgenv()
		if genv then
			genv.Library = nil
		end
	end
	Library.Thread = function(self, Function)
		local NewThread = coroutine.create(Function)
		coroutine.wrap(function()
			coroutine.resume(NewThread)
		end)()
		TableInsert(self.Threads, NewThread)
		return NewThread
	end
	Library.SafeCall = function(self, Function, ...)
		local Arguements = { ... }
		local Success, Result = pcall(Function, TableUnpack(Arguements))
		if not Success then
			Library:Notification("Error caught in function, report this to the devs:\n"..Result, 5, FromRGB(255, 0, 0))
			warn(Result)
			return false
		end
		return Success
	end
	Library.Connect = function(self, Event, Callback, Name)
		Name = Name or StringFormat("Connection_%s_%s", self.UnnamedConnections + 1, HttpService:GenerateGUID(false))
		local NewConnection = {
			Event = Event,
			Callback = Callback,
			Name = Name,
			Connection = nil
		}
		Library:Thread(function()
			NewConnection.Connection = Event:Connect(Callback)
		end)
		TableInsert(self.Connections, NewConnection)
		return NewConnection
	end
	Library.Disconnect = function(self, Name)
		for _, Connection in self.Connections do 
			if Connection.Name == Name then
				Connection.Connection:Disconnect()
				break
			end
		end
	end
	Library.NextFlag = function(self)
		local FlagNumber = self.UnnamedFlags + 1
		return StringFormat("Flag Number %s %s", FlagNumber, HttpService:GenerateGUID(false))
	end
	Library.AddToTheme = function(self, Item, Properties)
		Item = Item.Instance or Item 
		local ThemeData = {
			Item = Item,
			Properties = Properties,
		}
		for Property, Value in ThemeData.Properties do
			if type(Value) == "string" then
				Item[Property] = self.Theme[Value]
			end
		end
		TableInsert(self.ThemeItems, ThemeData)
		self.ThemeMap[Item] = ThemeData
	end
	Library.GetConfig = function(self)
		local Config = { } 
		local Success, Result = Library:SafeCall(function()
			for Index, Value in Library.Flags do 
				if type(Value) == "table" and Value.Key then
					Config[Index] = {Key = tostring(Value.Key), Mode = Value.Mode}
				elseif type(Value) == "table" and Value.Color then
					Config[Index] = {Color = "#" .. Value.HexValue, Alpha = Value.Alpha}
				else
					Config[Index] = Value
				end
			end
		end)
		return HttpService:JSONEncode(Config)
	end
	Library.LoadConfig = function(self, Config)
		local Decoded = HttpService:JSONDecode(Config)
		local Success, Result = Library:SafeCall(function()
			for Index, Value in Decoded do 
				local SetFunction = Library.SetFlags[Index]
				if SetFunction then
					if type(Value) == "table" and Value.Key then 
						SetFunction(Value)
					elseif type(Value) == "table" and Value.Color then
						SetFunction(Value.Color, Value.Alpha)
					else
						SetFunction(Value)
					end
				end
			end
		end)
		if Success then 
			Library:Notification("Successfully loaded config", 5, Color3.fromRGB(0, 255, 0))
		end
	end
	Library.DeleteConfig = function(self, Config)
		if isfile(Library.Folders.Configs .. "/" .. Config) then 
			delfile(Library.Folders.Configs .. "/" .. Config)
			Library:Notification("Deleted config " .. Config .. ".json", 5, Color3.fromRGB(0, 255, 0))
		end
	end
	Library.SaveConfig = function(self, Config)
		if isfile(Library.Folders.Directory .. "/" .. Library.Folders.Configs .. "/" .. Config .. ".json") then
			writefile(Library.Folders.Directory .. "/" .. Library.Folders.Configs .. "/" .. Config .. ".json", Library:GetConfig())
			Library:Notification("Saved config " .. Config .. ".json", 5, Color3.fromRGB(0, 255, 0))
		end
	end
	Library.RefreshConfigsList = function(self, Element)
		local CurrentList = { }
		local List = { }
		local ConfigFolderName = StringGSub(Library.Folders.Configs, Library.Folders.Directory .. "/", "")
		for Index, Value in listfiles(Library.Folders.Configs) do
			local FileName = StringGSub(Value, Library.Folders.Directory .. "\\" .. ConfigFolderName .. "\\", "")
			List[Index] = FileName
		end
		local IsNew = #List ~= CurrentList
		if not IsNew then
			for Index = 1, #List do
				if List[Index] ~= CurrentList[Index] then
					IsNew = true
					break
				end
			end
		else
			CurrentList = List
			Element:Refresh(CurrentList)
		end
	end
	Library.ChangeItemTheme = function(self, Item, Properties)
		Item = Item.Instance or Item
		if not self.ThemeMap[Item] then 
			return
		end
		self.ThemeMap[Item].Properties = Properties
		self.ThemeMap[Item] = self.ThemeMap[Item]
	end
	Library.ChangeTheme = function(self, Theme, Color)
		self.Theme[Theme] = Color
		for _, Item in self.ThemeItems do
			for Property, Value in Item.Properties do
				if type(Value) == "string" and Value == Theme then
					Item.Item[Property] = Color
				end
			end
		end
	end
	Library.IsMouseOverFrame = function(self, Frame)
		Frame = Frame.Instance
		local MousePosition = Vector2New(Mouse.X, Mouse.Y)
		return MousePosition.X >= Frame.AbsolutePosition.X and MousePosition.X <= Frame.AbsolutePosition.X + Frame.AbsoluteSize.X 
		and MousePosition.Y >= Frame.AbsolutePosition.Y and MousePosition.Y <= Frame.AbsolutePosition.Y + Frame.AbsoluteSize.Y
	end
	Library.Watermark = function(self, Name)
		local Watermark = { } 
		local Items = { } do 
			Items["Watermark"] = Instances:Create("Frame", {
				Parent = Library.Holder.Instance,
				Size = UDim2New(0, 0, 0, 20),
				Name = "\0",
				Position = UDim2New(0, 15, 0, 15),
				BorderColor3 = FromRGB(10, 10, 10),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.X,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["Watermark"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Items["Watermark"]:MakeDraggable()
			Instances:Create("UIStroke", {
				Parent = Items["Watermark"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIPadding", {
				Parent = Items["Watermark"].Instance,
				PaddingTop = UDimNew(0, 2),
				PaddingRight = UDimNew(0, 5),
				PaddingLeft = UDimNew(0, 5)
			}) 
			Items["Title"] = Instances:Create("TextLabel", {
				Parent = Items["Watermark"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Name,
				Name = "\0",
				Size = UDim2New(1, 0, 0, 15),
				BackgroundTransparency = 1,
				Position = UDim2New(0, 0, 0, 1),
				BorderSizePixel = 0,
				AutomaticSize = Enum.AutomaticSize.X,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Title"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Title"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["AccentLine"] = Instances:Create("Frame", {
				Parent = Items["Watermark"].Instance,
				Name = "\0",
				Position = UDim2New(0, -5, 0, -2),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 10, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(235, 157, 255)
			})  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UIGradient", {
				Parent = Items["AccentLine"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
			})             
		end
		function Watermark:SetVisibility(Bool)
			Items["Watermark"].Instance.Visible = Bool
		end
		return Watermark
	end
	Library.Notification = function(self, Text, Duration, Color, Icon)
		local Items = { } do
			Items["Notification"] = Instances:Create("Frame", {
				Parent = Library.NotifHolder.Instance,
				Name = "\0",
				Size = UDim2New(0, 0, 0, 22),
				BorderColor3 = FromRGB(10, 10, 10),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.X,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["Notification"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["Notification"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"}) 
			Instances:Create("UIPadding", {
				Parent = Items["Notification"].Instance,
				PaddingTop = UDimNew(0, 1),
				PaddingRight = UDimNew(0, 8),
				PaddingLeft = UDimNew(0, 5)
			}) 
			Items["Title"] = Instances:Create("TextLabel", {
				Parent = Items["Notification"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Text,
				Name = "\0",
				Size = UDim2New(1, 0, 0, 15),
				BackgroundTransparency = 1,
				Position = UDim2New(0, 13, 0, 2),
				BorderSizePixel = 0,
				AutomaticSize = Enum.AutomaticSize.X,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Title"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Title"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["AccentLine"] = Instances:Create("Frame", {
				Parent = Items["Notification"].Instance,
				Name = "\0",
				Position = UDim2New(0, -5, 0, -1),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 13, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = Color
			})  
			Instances:Create("UIGradient", {
				Parent = Items["AccentLine"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
			})
			Items["Icon"] = Instances:Create("ImageLabel", {
				Parent = Items["Notification"].Instance,
				ImageColor3 = FromRGB(255, 255, 255),
				ScaleType = Enum.ScaleType.Fit,
				BorderColor3 = FromRGB(0, 0, 0),
				Name = "\0",
				Image = "rbxassetid://94324346713012",
				BackgroundTransparency = 1,
				Position = UDim2New(0, -2, 0, 3),
				Size = UDim2New(0, 13, 0, 13),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			if not Icon then 
				Items["Icon"]:Clean()
				Items["Title"].Instance.Position = UDim2New(0, 1, 0, 2)
			else
				Items["Icon"].Instance.Image = Icon[1]
				Items["Icon"].Instance.ImageColor3 = Icon[2] or FromRGB(255, 255, 255)
			end
		end
		Items["Notification"].Instance.BackgroundTransparency = 1
		Items["Notification"].Instance.Size = UDim2New(0, 0, 0, 0)
		for Index, Value in Items["Notification"].Instance:GetDescendants() do
			if Value:IsA("UIStroke") then 
				Value.Transparency = 1
			elseif Value:IsA("TextLabel") then 
				Value.TextTransparency = 1
			elseif Value:IsA("ImageLabel") then 
				Value.ImageTransparency = 1
			elseif Value:IsA("Frame") then 
				Value.BackgroundTransparency = 1
			end
		end
		Library:Thread(function()
			Items["Notification"]:Tween(nil, {BackgroundTransparency = 0, Size = UDim2New(0, 0, 0, 22)})
			task.wait(0.06)
			for Index, Value in Items["Notification"].Instance:GetDescendants() do
				if Value:IsA("UIStroke") then
					Tween:Create(Value, nil, {Transparency = 0}, true)
				elseif Value:IsA("TextLabel") then
					Tween:Create(Value, nil, {TextTransparency = 0}, true)
				elseif Value:IsA("ImageLabel") then
					Tween:Create(Value, nil, {ImageTransparency = 0}, true)
				elseif Value:IsA("Frame") then
					Tween:Create(Value, nil, {BackgroundTransparency = 0}, true)
				end
			end
			task.delay(Duration + 0.1, function()
				for Index, Value in Items["Notification"].Instance:GetDescendants() do
					if Value:IsA("UIStroke") then
						Tween:Create(Value, nil, {Transparency = 1}, true)
					elseif Value:IsA("TextLabel") then
						Tween:Create(Value, nil, {TextTransparency = 1}, true)
					elseif Value:IsA("ImageLabel") then
						Tween:Create(Value, nil, {ImageTransparency = 1}, true)
					elseif Value:IsA("Frame") then
						Tween:Create(Value, nil, {BackgroundTransparency = 1}, true)
					end
				end
				task.wait(0.06)
				Items["Notification"]:Tween(nil, {BackgroundTransparency = 1, Size = UDim2New(0, 0, 0, 0)})
				task.wait(0.5)
				Items["Notification"]:Clean()
			end)
		end)
	end
	Library.KeybindList = function(self)
		local KeybindList = { }
		self.KeyList = KeybindList
		local Items = { } do
			Items["KeybindList"] = Instances:Create("Frame", {
				Parent = Library.Holder.Instance,
				BorderColor3 = FromRGB(10, 10, 10),
				AnchorPoint = Vector2New(0, 0.5),
				Name = "\0",
				Position = UDim2New(0, 15, 0.5, 0),
				Size = UDim2New(0, 0, 0, 18),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.XY,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["KeybindList"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Items["KeybindList"]:MakeDraggable()
			Instances:Create("UIStroke", {
				Parent = Items["KeybindList"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["AccentLine"] = Instances:Create("Frame", {
				Parent = Items["KeybindList"].Instance,
				Name = "\0",
				Position = UDim2New(0, -5, 0, -5),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 10, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(235, 157, 255)
			})  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UIGradient", {
				Parent = Items["AccentLine"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
			}) 
			Instances:Create("UIPadding", {
				Parent = Items["KeybindList"].Instance,
				PaddingTop = UDimNew(0, 5),
				PaddingBottom = UDimNew(0, 5),
				PaddingRight = UDimNew(0, 5),
				PaddingLeft = UDimNew(0, 5)
			}) 
			Items["Title"] = Instances:Create("TextLabel", {
				Parent = Items["KeybindList"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "Keybinds",
				Name = "\0",
				Size = UDim2New(0, 100, 0, 15),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Position = UDim2New(0, 0, 0, -1),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Title"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Title"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Content"] = Instances:Create("Frame", {
				Parent = Items["KeybindList"].Instance,
				Name = "\0",
				BackgroundTransparency = 1,
				Position = UDim2New(0, 5, 0, 19),
				BorderColor3 = FromRGB(0, 0, 0),
				BorderSizePixel = 0,
				AutomaticSize = Enum.AutomaticSize.XY,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Instances:Create("UIListLayout", {
				Parent = Items["Content"].Instance,
				Padding = UDimNew(0, 4),
				SortOrder = Enum.SortOrder.LayoutOrder
			}) 
		end
		function KeybindList:Add(Mode, Name, Key)
			local NewKey = Instances:Create("TextLabel", {
				Parent = Items["Content"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "(" .. Mode .. ") " .. Name .. " - " .. Key,
				Name = "\0",
				Size = UDim2New(0, 0, 0, 15),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				BorderSizePixel = 0,
				AutomaticSize = Enum.AutomaticSize.X,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  NewKey:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = NewKey.Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			function NewKey:Set(Mode, Name, Key)
				NewKey.Instance.Text = "(" .. Mode .. ") " .. Name .. " - " .. Key
			end
			function NewKey:SetStatus(Status)
				if Status == "Active" then 
					NewKey:Tween(nil, {TextColor3 = Library.Theme.Accent})
					NewKey:ChangeItemTheme({TextColor3 = "Accent"})
				else 
					NewKey:Tween(nil, {TextColor3 = Library.Theme.Text})
					NewKey:ChangeItemTheme({TextColor3 = "Text"})
				end
			end
			return NewKey
		end
		function KeybindList:SetVisibility(Bool)
			Items["KeybindList"].Instance.Visible = Bool
		end
		return KeybindList
	end
	Library.CreateColorpicker = function(self, Data)
		local Colorpicker = {
			Hue = 0,
			Saturation = 0,
			Value = 0,
			Alpha = 0,
			HexValue = "",
			IsOpen = false,
			Color = FromRGB(0, 0, 0),
			Class = "Colorpicker"
		}
		Library.Flags[Data.Flag] = { }
		local Items = { } do
			Items["ColorpickerButton"] = Instances:Create("TextButton", {
				Parent = Data.Parent.Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "",
				AutoButtonColor = false,
				AnchorPoint = Vector2New(1, 0.5),
				Name = "\0",
				Position = UDim2New(1, 0, 0.5, 0),
				Size = UDim2New(0, 20, 0, 10),
				BorderSizePixel = 0,
				TextSize = 14,
				BackgroundColor3 = FromRGB(255, 0, 0)
			}) 
			Colorpicker.CalculateCount = function(self, Index, YScale, YOffset)
				local MaxButtonsAdded = 5
				local Column = Index % MaxButtonsAdded
				local ButtonSize = Items["ColorpickerButton"].Instance.AbsoluteSize
				local Spacing = 4
				local XPosition = (ButtonSize.X + Spacing) * Column - Spacing - 21
				Items["ColorpickerButton"].Instance.Position = UDim2New(1, -XPosition, YScale or 0.5, YOffset or 0)
			end
			Colorpicker:CalculateCount(Data.Count)
			Instances:Create("UIStroke", {
				Parent = Items["ColorpickerButton"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIGradient", {
				Parent = Items["ColorpickerButton"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})             
			Items["ColorpickerWindow"] = Instances:Create("TextButton", {
				Parent = Library.Holder.Instance,
				AutoButtonColor = false,
				Text = "",
				Name = "\0",
				Position = UDim2New(0, Data.Parent.Instance.AbsolutePosition.X, 0, Data.Parent.Instance.AbsolutePosition.Y + 15),
				BorderColor3 = FromRGB(10, 10, 10),
				Visible = false,
				Size = UDim2New(0, 238, 0, 224),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["ColorpickerWindow"]:AddToTheme({BackgroundColor3 = "Background"})
			Items["ColorpickerWindow"]:MakeDraggable()
			Items["ColorpickerWindow"]:MakeResizeable(Vector2New(200, 180), Vector2New(9999, 9999))
			Instances:Create("UIStroke", {
				Parent = Items["ColorpickerWindow"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Title"] = Instances:Create("TextLabel", {
				Parent = Items["ColorpickerWindow"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Data.Name,
				Name = "\0",
				Size = UDim2New(1, 0, 0, 15),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Position = UDim2New(0, -2, 0, -3),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Title"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Title"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["AccentLine"] = Instances:Create("Frame", {
				Parent = Items["ColorpickerWindow"].Instance,
				Name = "\0",
				Position = UDim2New(0, -6, 0, -6),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 12, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(235, 157, 255)
			})  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UIGradient", {
				Parent = Items["AccentLine"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
			}) 
			Instances:Create("UIPadding", {
				Parent = Items["ColorpickerWindow"].Instance,
				PaddingTop = UDimNew(0, 6),
				PaddingBottom = UDimNew(0, 6),
				PaddingRight = UDimNew(0, 6),
				PaddingLeft = UDimNew(0, 6)
			}) 
			Items["Palette"] = Instances:Create("TextButton", {
				Parent = Items["ColorpickerWindow"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "",
				AutoButtonColor = false,
				Name = "\0",
				Position = UDim2New(0, 0, 0, 15),
				Size = UDim2New(1, -26, 1, -40),
				BorderSizePixel = 0,
				TextSize = 14,
				BackgroundColor3 = FromRGB(255, 0, 0)
			}) 
			Items["Saturation"] = Instances:Create("ImageLabel", {
				Parent = Items["Palette"].Instance,
				BorderColor3 = FromRGB(0, 0, 0),
				Image = Library:GetImage("Saturation"),
				BackgroundTransparency = 1,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Items["Value"] = Instances:Create("ImageLabel", {
				Parent = Items["Palette"].Instance,
				BorderColor3 = FromRGB(0, 0, 0),
				Image = Library:GetImage("Value"),
				BackgroundTransparency = 1,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Instances:Create("UIStroke", {
				Parent = Items["Palette"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["PaletteDragger"] = Instances:Create("Frame", {
				Parent = Items["Palette"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(0, 2, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Instances:Create("UIStroke", {
				Parent = Items["PaletteDragger"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Hue"] = Instances:Create("ImageButton", {
				Parent = Items["ColorpickerWindow"].Instance,
				BorderColor3 = FromRGB(0, 0, 0),
				AutoButtonColor = false,
				AnchorPoint = Vector2New(1, 0),
				Image = Library:GetImage("Hue"),
				Name = "\0",
				Position = UDim2New(1, 0, 0, 15),
				Size = UDim2New(0, 18, 1, -15),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Items["HueDragger"] = Instances:Create("Frame", {
				Parent = Items["Hue"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 1),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Instances:Create("UIStroke", {
				Parent = Items["HueDragger"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIStroke", {
				Parent = Items["Hue"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Alpha"] = Instances:Create("TextButton", {
				Parent = Items["ColorpickerWindow"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "",
				AutoButtonColor = false,
				AnchorPoint = Vector2New(0, 1),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 0),
				Size = UDim2New(1, -26, 0, 18),
				BorderSizePixel = 0,
				TextSize = 14,
				BackgroundColor3 = FromRGB(255, 0, 0)
			}) 
			Instances:Create("UIStroke", {
				Parent = Items["Alpha"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Checkers"] = Instances:Create("ImageLabel", {
				Parent = Items["Alpha"].Instance,
				ScaleType = Enum.ScaleType.Tile,
				BorderColor3 = FromRGB(0, 0, 0),
				Image = Library:GetImage("Checkers"),
				TileSize = UDim2New(0, 6, 0, 6),
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Instances:Create("UIGradient", {
				Parent = Items["Checkers"].Instance,
				Transparency = NumSequence{NumSequenceKeypoint(0, 1), NumSequenceKeypoint(1, 0)}
			}) 
			Instances:Create("UIGradient", {
				Parent = Items["Alpha"].Instance,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(0, 0, 0))}
			}) 
			Items["AlphaDragger"] = Instances:Create("Frame", {
				Parent = Items["Alpha"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(0, 1, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Instances:Create("UIStroke", {
				Parent = Items["AlphaDragger"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
		end
		local SlidingPalette = false
		local SlidingHue = false
		local SlidingAlpha = false
		local Debounce = false
		function Colorpicker:SetOpen(Bool)
			if Debounce then 
				return 
			end
			Colorpicker.IsOpen = Bool
			Debounce = true 
			if Bool then 
				Items["ColorpickerWindow"].Instance.Visible = true
				Items["ColorpickerWindow"].Instance.Position = UDim2New(0, Data.Parent.Instance.AbsolutePosition.X, 0, Data.Parent.Instance.AbsolutePosition.Y + 15)
				if Library.CurrentColorpicker then
					Library.CurrentColorpicker:SetOpen(false)
					Library.CurrentColorpicker = nil 
				end
				if not Library.CurrentColorpicker then 
					Library.CurrentColorpicker = Colorpicker
				end
			else
				Library.CurrentColorpicker = nil
			end
			local Descendants = Items["ColorpickerWindow"].Instance:GetDescendants()
			TableInsert(Descendants, Items["ColorpickerWindow"].Instance)
			local NewTween
			for Index, Value in Descendants do 
				local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)
				if ValueIndex then
					if not StringFind(Value.ClassName, "UI") then 
						Value.ZIndex = Bool and 10001 or 1
					end
					if type(ValueIndex) == "table" then
						for _, Property in ValueIndex do 
							NewTween = Library:FadeItem(Value, Property, Bool, Data.FadeSpeed)
						end
					else
						NewTween = Library:FadeItem(Value, ValueIndex, Bool, Data.FadeSpeed)
					end
				end
			end
			Library:Connect(NewTween.Tween.Completed, function()
				Debounce = false
				Items["ColorpickerWindow"].Instance.Visible = Bool
			end)
		end
		function Colorpicker:Get()
			return Colorpicker.Value
		end
		function Colorpicker:SetVisibility(Bool)
		   Data.Parent.Instance.Visible = Bool 
		end
		function Colorpicker:Set(Color, Alpha)
			if type(Color) == "table" then 
				Color = FromRGB(Color[1], Color[2], Color[3])
				Alpha = Color[4]
			elseif type(Color) == "string" then 
				Color = FromHex(Color)
			end
			self.Hue, self.Saturation, self.Value = Color:ToHSV()
			self.Alpha = Alpha or 0
			self.Color = FromHSV(self.Hue, self.Saturation, self.Value)
			self.HexValue = self.Color:ToHex()
			Library.Flags[Data.Flag] = {
				Color = self.Color,
				HexValue =  self.HexValue,
				Alpha = self.Alpha
			}
			local ColorPositionX = MathClamp(1 - self.Saturation, 0, 0.989)
			local ColorPositionY = MathClamp(1 - self.Value, 0, 0.989)
			Items["PaletteDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(ColorPositionX, 0, ColorPositionY, 0)})
			local HuePositionY = MathClamp(self.Hue, 0, 0.994)
			Items["HueDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(0, 0, HuePositionY, 0)})
			local AlphaPositionX = MathClamp(self.Alpha, 0, 0.994)
			Items["AlphaDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(AlphaPositionX, 0, 0, 0)})
			self:Update()
		end
		function Colorpicker:Update(IsFromAlpha)
			self.Color = FromHSV(self.Hue, self.Saturation, self.Value)
			self.HexValue = self.Color:ToHex()
			Library.Flags[Data.Flag] = {
				Color = self.Color,
				HexValue =  self.HexValue,
				Alpha = self.Alpha
			}
			Items["ColorpickerButton"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundColor3 = self.Color})
			Items["Palette"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundColor3 = FromHSV(self.Hue, 1, 1)})
			if not IsFromAlpha then 
				Items["Alpha"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundColor3 = self.Color})
			end
			if Data.Callback then 
				Library:SafeCall(Data.Callback, self.Color, self.Alpha)
			end
		end
		function Colorpicker:SlidePalette(Input)
			if not Input or not SlidingPalette then 
				return
			end
			local ValueX = MathClamp(1 - (Input.Position.X - Items["Palette"].Instance.AbsolutePosition.X) / Items["Palette"].Instance.AbsoluteSize.X, 0, 1)
			local ValueY = MathClamp(1 - (Input.Position.Y - Items["Palette"].Instance.AbsolutePosition.Y) / Items["Palette"].Instance.AbsoluteSize.Y, 0, 1)
			self.Saturation = ValueX
			self.Value = ValueY
			local SlideX = MathClamp((Input.Position.X - Items["Palette"].Instance.AbsolutePosition.X) / Items["Palette"].Instance.AbsoluteSize.X, 0, 0.989)
			local SlideY = MathClamp((Input.Position.Y - Items["Palette"].Instance.AbsolutePosition.Y) / Items["Palette"].Instance.AbsoluteSize.Y, 0, 0.989)
			Items["PaletteDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(SlideX, 0, SlideY, 0)})
			self:Update()            
		end
		function Colorpicker:SlideHue(Input)
			if not Input or not SlidingHue then 
				return
			end
			local ValueY = MathClamp((Input.Position.Y - Items["Hue"].Instance.AbsolutePosition.Y) / Items["Hue"].Instance.AbsoluteSize.Y, 0, 1)
			self.Hue = ValueY
			local PositionY = MathClamp((Input.Position.Y - Items["Hue"].Instance.AbsolutePosition.Y) / Items["Hue"].Instance.AbsoluteSize.Y, 0, 0.994)
			Items["HueDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(0, 0, PositionY, 0)})
			self:Update()
		end
		function Colorpicker:SlideAlpha(Input)
			if not Input or not SlidingAlpha then 
				return
			end
			local ValueX = MathClamp((Input.Position.X - Items["Alpha"].Instance.AbsolutePosition.X) / Items["Alpha"].Instance.AbsoluteSize.X, 0, 1)
			self.Alpha = ValueX
			local PositionX = MathClamp((Input.Position.X - Items["Alpha"].Instance.AbsolutePosition.X) / Items["Alpha"].Instance.AbsoluteSize.X, 0, 0.994)
			Items["AlphaDragger"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2New(PositionX, 0, 0, 0)})
			self:Update(true)
		end
		Items["ColorpickerButton"]:Connect("MouseButton1Down", function()
			Colorpicker:SetOpen(not Colorpicker.IsOpen)
		end)
		Items["Palette"]:Connect("InputBegan", function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				SlidingPalette = true
				Colorpicker:SlidePalette(Input)
			end
		end)
		Items["Palette"]:Connect("InputEnded", function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				SlidingPalette = false
			end
		end)
		Items["Hue"]:Connect("InputBegan", function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				SlidingHue = true
				Colorpicker:SlideHue(Input)
			end
		end)
		Items["Hue"]:Connect("InputEnded", function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				SlidingHue = false
			end
		end)
		Items["Alpha"]:Connect("InputBegan", function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				SlidingAlpha = true
				Colorpicker:SlideAlpha(Input)
			end
		end)
		Items["Alpha"]:Connect("InputEnded", function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				SlidingAlpha = false
			end
		end)
		Library:Connect(UserInputService.InputChanged, function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseMovement then
				if SlidingPalette then
					Colorpicker:SlidePalette(Input)
				end
				if SlidingHue then
					Colorpicker:SlideHue(Input)
				end
				if SlidingAlpha then
					Colorpicker:SlideAlpha(Input)
				end
			end
		end)
		Library:Connect(UserInputService.InputBegan, function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				if Library:IsMouseOverFrame(Items["ColorpickerWindow"]) then
					return
				end
				Colorpicker:SetOpen(false)
			end
		end)
		if Data.Default then 
			Colorpicker:Set(Data.Default, Data.Alpha)
		end
		Library.SetFlags[Data.Flag] = function(Color, Alpha)
			Colorpicker:Set(Color, Alpha)
		end
		return Colorpicker
	end
	Library.CreateKeybind = function(self, Data)
		local Keybind = {
			Key = nil,
			Value = "",
			Mode = "",
			Toggled = false,
			IsOpen = false,
			Picking = false,
			Class = "Keybind",
			OnModeChange = nil
		}
		Library.Flags[Data.Flag] = { }
		local KeyListItem
		local Items = { } do 
			Items["KeyButton"] = Instances:Create("TextButton", {
				Parent = Data.Parent.Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(27, 27, 32),
				Text = "",
				AutoButtonColor = false,
				AnchorPoint = Vector2New(1, 0),
				Size = UDim2New(0, 0, 1, 1),
				Name = "\0",
				Position = UDim2New(1, 0, 0, 0),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.X,
				TextSize = 14,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["KeyButton"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Outline"})
			if Library.KeyList then 
				KeyListItem = Library.KeyList:Add(Keybind.Mode, Data.Name, Keybind.Value)
			end
			Instances:Create("UIStroke", {
				Parent = Items["KeyButton"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(10, 10, 10)
			}):AddToTheme({Color = "Border"})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["KeyButton"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "MB2",
				Name = "\0",
				BackgroundTransparency = 1,
				Position = UDim2New(0, 1, 0, 0),
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Instances:Create("UIPadding", {
				Parent = Items["KeyButton"].Instance,
				PaddingRight = UDimNew(0, 3),
				PaddingLeft = UDimNew(0, 3),
				PaddingBottom = UDimNew(0, 2)
			})             
			Items["Window"] = Instances:Create("Frame", {
				Parent = Data.Parent.Instance,
				BorderColor3 = FromRGB(10, 10, 10),
				AnchorPoint = Vector2New(1, 0),
				Name = "\0",
				Position = UDim2New(1, 0, 1, 5),
				Size = UDim2New(0, 50, 0, 48),
				BorderSizePixel = 2,
				Visible = false,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["Window"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["Window"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Toggle"] = Instances:Create("TextButton", {
				Parent = Items["Window"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(235, 157, 255),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "Toggle",
				AutoButtonColor = false,
				Name = "\0",
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				Position = UDim2New(0, 1, 0, 0),
				Size = UDim2New(1, 0, 0, 15),
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Toggle"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Toggle"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Hold"] = Instances:Create("TextButton", {
				Parent = Items["Window"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "Hold",
				AutoButtonColor = false,
				Name = "\0",
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				Position = UDim2New(0, 1, 0, 15),
				Size = UDim2New(1, 0, 0, 15),
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Hold"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Hold"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Always"] = Instances:Create("TextButton", {
				Parent = Items["Window"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "Always",
				AutoButtonColor = false,
				Name = "\0",
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				Position = UDim2New(0, 1, 0, 30),
				Size = UDim2New(1, 0, 0, 15),
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Always"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Always"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
		end
		local Modes = {
			["Toggle"] = Items["Toggle"],
			["Hold"] = Items["Hold"],
			["Always"] = Items["Always"]
		}
		local Update = function()
			if KeyListItem then
				KeyListItem:Set(Keybind.Mode, Data.Name, Keybind.Value)
				KeyListItem:SetStatus(Keybind.Toggled and "Active" or "Inactive")
			end
		end
		function Keybind:Get()
		   return Keybind.Toggled, Keybind.Key, Keybind.Mode 
		end
		function Keybind:SetVisibility(Bool)
			Data.Parent.Instance.Visible = Bool
		end
		local Debounce = false
		function Keybind:SetOpen(Bool)
			Keybind.IsOpen = Bool
			if Bool then 
				Debounce = true
				Items["Window"].Instance.Visible = true
				Items["Window"].Instance.ZIndex = 16
				Items["Window"]:Tween(nil, {BackgroundTransparency = 0})
				task.wait(0.1)
				for Index, Value in Items["Window"].Instance:GetDescendants() do 
					if Value:IsA("UIStroke") then
						Tween:Create(Value, nil, {Transparency = 0}, true)
					elseif Value:IsA("TextButton") then
						Tween:Create(Value, nil, {TextTransparency = 0}, true)
						Value.ZIndex = 16
					end
				end
			else 
				for Index, Value in Items["Window"].Instance:GetDescendants() do 
					if Value:IsA("UIStroke") then
						Tween:Create(Value, nil, {Transparency = 1}, true)
					elseif Value:IsA("TextButton") then
						Tween:Create(Value, nil, {TextTransparency = 1}, true)
						Value.ZIndex = 1
					end
				end
				task.wait(0.1)
				Items["Window"]:Tween(nil, {BackgroundTransparency = 1})
				Items["Window"].Instance.ZIndex = 1
				task.wait(0.1)
				Items["Window"].Instance.Visible = false
			end
			Debounce = false
		end
		function Keybind:Set(Key)
			if StringFind(tostring(Key), "Enum") then 
				Keybind.Key = tostring(Key)
				Key = Key.Name == "Backspace" and "None" or Key.Name
				local KeyString = Keys[Keybind.Key] or StringGSub(Key, "Enum.", "") or "None"
				local TextToDisplay = StringGSub(StringGSub(KeyString, "KeyCode.", ""), "UserInputType.", "") or "None"
				Keybind.Value = TextToDisplay
				Items["Text"].Instance.Text = TextToDisplay
				if Data.Callback then 
					Library:SafeCall(Data.Callback, Keybind.Toggled)
				end
		   elseif TableFind({"Toggle", "Hold", "Always"}, Key) then 
				Keybind.Mode = Key
				Keybind:SetMode(Key)
				if Data.Callback then 
					Library:SafeCall(Data.Callback, Keybind.Toggled)
				end
			elseif type(Key) == "table" then 
				local RealKey = Key.Key == "Backspace" and "None" or Key.Key
				Keybind.Key = tostring(Key.Key)
				if Key.Mode then
					Keybind.Mode = Key.Mode
					Keybind:SetMode(Key.Mode)
				else
					Keybind.Mode = "Toggle"
					Keybind:SetMode("Toggle")
				end
				local KeyString = Keys[Keybind.Key] or StringGSub(tostring(RealKey), "Enum.", "") or RealKey
				local TextToDisplay = KeyString and StringGSub(StringGSub(KeyString, "KeyCode.", ""), "UserInputType.", "") or "None"
				TextToDisplay = StringGSub(StringGSub(KeyString, "KeyCode.", ""), "UserInputType.", "")
				Keybind.Value = TextToDisplay
				Items["Text"].Instance.Text = TextToDisplay
				if Keybind.Callback then 
					Library:SafeCall(Keybind.Callback, Keybind.Toggled)
				end
			end
			Keybind.Picking = false
			Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Text})
			Items["Text"]:ChangeItemTheme({TextColor3 = "Text"})
			Items["Text"].Instance.Size = UDim2New(0, Items["Text"].Instance.TextBounds.X, 1, 1)
			Update()
		end
		function Keybind:SetMode(Mode)
			for Index, Value in Modes do 
				if Index == Mode then 
					Value:Tween(nil, {TextColor3 = Library.Theme.Accent})
					Value:ChangeItemTheme({TextColor3 = "Accent"})
				else
					Value:Tween(nil, {TextColor3 = Library.Theme.Text})
					Value:ChangeItemTheme({TextColor3 = "Text"})
				end
			end
			if Keybind.Mode == "Always" then 
				Keybind.Toggled = true
			else
				Keybind.Toggled = false
			end
			Library.Flags[Data.Flag] = {
				Mode = Keybind.Mode,
				Key = Keybind.Key,
				Toggled = Keybind.Toggled
			}
			if Data.Callback then 
				Library:SafeCall(Data.Callback, Keybind.Toggled)
			end
			Update()
		end
		function Keybind:Press(Bool)
			if Keybind.Mode == "Toggle" then
				Keybind.Toggled = not Keybind.Toggled
			elseif Keybind.Mode == "Hold" then
				Keybind.Toggled = Bool
			elseif Keybind.Mode == "Always" then
				Keybind.Toggled = true
			end
			Library.Flags[Data.Flag] = {
				Mode = Keybind.Mode,
				Key = Keybind.Key,
				Toggled = Keybind.Toggled
			}
			if Data.Callback then 
				Library:SafeCall(Data.Callback, Keybind.Toggled)
			end
			Update()
		end
		Items["KeyButton"]:Connect("MouseButton1Click", function()
			if Keybind.Picking then 
				return
			end
			Keybind.Picking = true
			Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Accent})
			Items["Text"]:ChangeItemTheme({TextColor3 = "Accent"})
			local InputBegan 
			InputBegan = UserInputService.InputBegan:Connect(function(Input)
				if Input.UserInputType == Enum.UserInputType.Keyboard then 
					Keybind:Set(Input.KeyCode)
				else
					Keybind:Set(Input.UserInputType)
				end
				InputBegan:Disconnect()
				InputBegan = nil
			end)
		end)
		Items["KeyButton"]:Connect("MouseButton2Down", function()
			Keybind:SetOpen(not Keybind.IsOpen)
		end)
		Library:Connect(UserInputService.InputBegan, function(Input)
			if tostring(Input.KeyCode) == Keybind.Key or tostring(Input.UserInputType) == Keybind.Key then
				if Keybind.Mode == "Toggle" then 
					Keybind:Press()
				elseif Keybind.Mode == "Hold" then 
					Keybind:Press(true)
				end
			end
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				if Library:IsMouseOverFrame(Items["Window"]) then
					return
				end
				if Debounce then 
					return
				end
				Keybind:SetOpen(false)
			end
		end)
		Library:Connect(UserInputService.InputEnded, function(Input)
			if tostring(Input.KeyCode) == Keybind.Key or tostring(Input.UserInputType) == Keybind.Key then
				if Keybind.Mode == "Hold" then 
					Keybind:Press(false)
				end
			end
		end)
		Items["Toggle"]:Connect("MouseButton1Down", function()
			Keybind.Mode = "Toggle"
			Keybind:SetMode("Toggle")
			if Keybind.OnModeChange then
				Keybind.OnModeChange("Toggle")
			end
		end)
		Items["Always"]:Connect("MouseButton1Down", function()
			Keybind.Mode = "Always"
			Keybind:SetMode("Always")
			if Keybind.OnModeChange then
				Keybind.OnModeChange("Always")
			end
		end)
		Items["Hold"]:Connect("MouseButton1Down", function()
			Keybind.Mode = "Hold"
			Keybind:SetMode("Hold")
			if Keybind.OnModeChange then
				Keybind.OnModeChange("Hold")
			end
		end)
		if Data.Default then 
			Keybind:Set({
				Key = Data.Default,
				Mode = Data.Mode or "Toggle"
			})
		end
		Library.SetFlags[Data.Flag] = function(Value)
			Keybind:Set(Value)
		end
		return Keybind
	end
	Library.Window = function(self, Data)
		Data = Data or { }
		local Window = {
			Name = Data.Name or Data.name or "Window",
			Size = Data.Size or Data.size or UDim2New(0, 500, 0, 600),
			FadeSpeed = Data.FadeSpeed or Data.fadespeed or 0.25,
			Pages = { },
			SubPages = { },
			Elements = { },
			IsOpen = true
		}
		local Items = { } do 
			Items["MainFrame"] = Instances:Create("Frame", {
				Parent = Library.Holder.Instance,
				AnchorPoint = Vector2New(0, 0),
				Name = "\0",
				Position = UDim2New(0, 0, 0, 0),
				BorderColor3 = FromRGB(10, 10, 10),
				Size = Window.Size,
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["MainFrame"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Items["MainFrame"].Instance.Position = UDim2New(0, Camera.ViewportSize.X / 4, 0, Camera.ViewportSize.Y / 4)
			Items["MainFrame"]:MakeDraggable()
			Items["MainFrame"]:MakeResizeable(Vector2New(Window.Size.X.Offset, Window.Size.Y.Offset), Vector2New(9999, 9999))
			
			Items["AccentBorder"] = Instances:Create("UIStroke", {
				Parent = Items["MainFrame"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(235, 157, 255)
			})  Items["AccentBorder"]:AddToTheme({Color = "Accent"})
			Items["Title"] = Instances:Create("TextLabel", {
				Parent = Items["MainFrame"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Window.Name,
				Name = "\0",
				Size = UDim2New(1, 0, 0, 15),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Position = UDim2New(0, 6, 0, 1),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Title"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Title"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Inline"] = Instances:Create("Frame", {
				Parent = Items["MainFrame"].Instance,
				Name = "\0",
				Position = UDim2New(0, 7, 0, 20),
				BorderColor3 = FromRGB(27, 27, 32),
				Size = UDim2New(1, -14, 1, -27),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(20, 20, 25)
			})  Items["Inline"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Outline"})
			Instances:Create("UIStroke", {
				Parent = Items["Inline"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				Color = Library.Theme.Border,
				Name = "\0"
			}):AddToTheme({Color = "Border"})
			Items["Pages"] = Instances:Create("Frame", {
				Parent = Items["Inline"].Instance,
				Name = "\0",
				BackgroundTransparency = 1,
				Position = UDim2New(0, 7, 0, 7),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, -14, 0, 19),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Instances:Create("UIListLayout", {
				Parent = Items["Pages"].Instance,
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalFlex = Enum.UIFlexAlignment.Fill,
				Padding = UDimNew(0, 6),
				SortOrder = Enum.SortOrder.LayoutOrder
			})
			Items["Content"] = Instances:Create("Frame", {
				Parent = Items["Inline"].Instance,
				Name = "\0",
				Position = UDim2New(0, 7, 0, 26),
				BorderColor3 = FromRGB(10, 10, 10),
				Size = UDim2New(1, -14, 1, -33),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["Content"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["Content"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				Color = Library.Theme.Outline,
				Name = "\0"
			}):AddToTheme({Color = "Outline"})
		end
		local Debounce = false
		function Window:SetOpen(Bool)
			if Debounce then 
				return 
			end
			Window.IsOpen = Bool
			Debounce = true 
			if Bool then 
				Items["MainFrame"].Instance.Visible = true
			end
			local FadeSpeed = math.min(Window.FadeSpeed or 0.15, 0.15)
			local MainFrame = Items["MainFrame"].Instance
			local NewTween
			local TransparencyProp = Library:GetTransparencyPropertyFromItem(MainFrame)
			if TransparencyProp then
				if type(TransparencyProp) == "table" then
					NewTween = Library:FadeItem(MainFrame, TransparencyProp[1], Bool, FadeSpeed)
				else
					NewTween = Library:FadeItem(MainFrame, TransparencyProp, Bool, FadeSpeed)
				end
			end
			if NewTween and NewTween.Tween then
				Library:Connect(NewTween.Tween.Completed, function()
					Debounce = false
					Items["MainFrame"].Instance.Visible = Bool
				end)
			else
				Debounce = false
				Items["MainFrame"].Instance.Visible = Bool
			end
		end
		Library:Connect(UserInputService.InputBegan, function(Input)
			if tostring(Input.KeyCode) == Library.MenuKeybind or tostring(Input.UserInputType) == Library.MenuKeybind then
				Window:SetOpen(not Window.IsOpen)
			end
		end)
		Window.Elements = Items
		return setmetatable(Window, Library)
	end
	Library.Page = function(self, Data)
		Data = Data or { }
		local Page = {
			Window = self,
			Name = Data.Name or Data.name or "Page",
			Columns = Data.Columns or Data.columns or 2,
			HasSubtabs = Data.Subtabs or Data.subtabs or false,
			Active = false,
			ColumnsData = { },
			Elements = { }
		}
		local Items = { } do 
			Items["Inactive"] = Instances:Create("TextButton", {
				Parent = Page.Window.Elements["Pages"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(10, 10, 10),
				Text = "",
				AutoButtonColor = false,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 2,
				TextSize = 14,
				BackgroundColor3 = FromRGB(30, 30, 35)
			})  Items["Inactive"]:AddToTheme({BackgroundColor3 = "Page Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["Inactive"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				Color = Library.Theme.Outline,
				Name = "\0"
			}):AddToTheme({Color = "Outline"})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Inactive"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				TextTransparency = 0.47999998927116394,
				Text = Page.Name,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Position = UDim2New(0, 0, 0, -1),
				BorderSizePixel = 0,
				BorderColor3 = FromRGB(0, 0, 0),
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Hide"] = Instances:Create("Frame", {
				Parent = Items["Inactive"].Instance,
				Visible = false,
				BorderColor3 = FromRGB(0, 0, 0),
				AnchorPoint = Vector2New(0, 1),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 0),
				Size = UDim2New(1, 0, 0, 3),
				ZIndex = 2,
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["Hide"]:AddToTheme({BackgroundColor3 = "Background"})
			Items["MiscPixel1"] = Instances:Create("Frame", {
				Parent = Items["Hide"].Instance,
				Size = UDim2New(0, 1, 0, 1),
				Name = "\0",
				Position = UDim2New(0, -1, 0, 1),
				BorderColor3 = FromRGB(0, 0, 0),
				ZIndex = 2,
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(27, 27, 32)
			})  Items["MiscPixel1"]:AddToTheme({BackgroundColor3 = "Outline"})
			Items["MiscPixel2"] = Instances:Create("Frame", {
				Parent = Items["Hide"].Instance,
				BorderColor3 = FromRGB(0, 0, 0),
				AnchorPoint = Vector2New(1, 0),
				Name = "\0",
				Position = UDim2New(1, 1, 0, 1),
				Size = UDim2New(0, 1, 0, 1),
				ZIndex = 2,
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(27, 27, 32)
			})  Items["MiscPixel2"]:AddToTheme({BackgroundColor3 = "Outline"})
			Items["UIGradient"] = Instances:Create("UIGradient", {
				Parent = Items["Inactive"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(108, 108, 108))}
			})            
			Items["Page"] = Instances:Create("Frame", {
				Parent = Page.Window.Elements["Content"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255),
				Visible = false
			})
			if not Page.HasSubtabs then 
				Instances:Create("UIListLayout", {
					Parent = Items["Page"].Instance,
					FillDirection = Enum.FillDirection.Horizontal,
					HorizontalFlex = Enum.UIFlexAlignment.Fill,
					SortOrder = Enum.SortOrder.LayoutOrder,
					VerticalFlex = Enum.UIFlexAlignment.Fill
				})
				for Index = 1, Page.Columns do
					local NewColumn = Instances:Create("ScrollingFrame", {
						Parent = Items["Page"].Instance,
						ScrollBarImageColor3 = FromRGB(235, 157, 255),
						Active = true,
						AutomaticCanvasSize = Enum.AutomaticSize.Y,
						ScrollBarThickness = 1,
						Name = "\0",
						BackgroundTransparency = 1,
						Size = UDim2New(0, 100, 0, 100),
						BackgroundColor3 = FromRGB(255, 255, 255),
						BorderColor3 = FromRGB(0, 0, 0),
						BorderSizePixel = 0,
						BottomImage = Library:GetImage("Scrollbar"),
						MidImage = Library:GetImage("Scrollbar"),
						TopImage = Library:GetImage("Scrollbar"),
						CanvasSize = UDim2New(0, 0, 0, 0)
					})  NewColumn:AddToTheme({ScrollBarImageColor3 = "Accent"})
					Instances:Create("UIPadding", {
						Parent = NewColumn.Instance,
						PaddingTop = UDimNew(0, 6),
						PaddingBottom = UDimNew(0, 6),
						PaddingRight = UDimNew(0, 6),
						PaddingLeft = UDimNew(0, 6)
					})
					Instances:Create("UIListLayout", {
						Parent = NewColumn.Instance,
						Padding = UDimNew(0, 8),
						SortOrder = Enum.SortOrder.LayoutOrder
					}) 
					Page.ColumnsData[Index] = NewColumn
				end
			else
				Items["Columns"] = Instances:Create("Frame", {
					Parent = Items["Page"].Instance,
					Name = "\0",
					Position = UDim2New(0, 7, 0, 45),
					BorderColor3 = FromRGB(10, 10, 10),
					Size = UDim2New(1, -14, 1, -52),
					BorderSizePixel = 2,
					BackgroundColor3 = FromRGB(15, 15, 20)
				})  Items["Columns"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
				Items["SubTabs"] = Instances:Create("Frame", {
					Parent = Items["Page"].Instance,
					Name = "\0",
					BackgroundTransparency = 1,
					Position = UDim2New(0, 7, 0, 7),
					BorderColor3 = FromRGB(0, 0, 0),
					Size = UDim2New(1, -14, 0, 35),
					BorderSizePixel = 0,
					BackgroundColor3 = FromRGB(255, 255, 255)
				}) 
				Instances:Create("UIListLayout", {
					Parent = Items["SubTabs"].Instance,
					FillDirection = Enum.FillDirection.Horizontal,
					HorizontalFlex = Enum.UIFlexAlignment.Fill,
					Padding = UDimNew(0, 6),
					SortOrder = Enum.SortOrder.LayoutOrder
				}) 
			end
		end
		function Page:Turn(Bool)
			Page.Active = Bool
			if Bool then 
				Items["Page"].Instance.Visible = true
				Items["Text"].Instance.TextColor3 = Library.Theme.Accent
				Items["Text"].Instance.TextTransparency = 0
				Items["Hide"].Instance.Visible = true
				Items["Text"]:ChangeItemTheme({TextColor3 = "Accent"})
			else
				Items["Text"].Instance.TextColor3 = Library.Theme.Text
				Items["Text"].Instance.TextTransparency = 0.5
				Items["Hide"].Instance.Visible = false
				Items["Text"]:ChangeItemTheme({TextColor3 = "Text"})
				Items["Page"].Instance.Visible = false
			end
		end
		Items["Inactive"]:Connect("MouseButton1Down", function()
			for Index, Value in Page.Window.Pages do
				Value:Turn(Value == Page)
			end
		end)
		if #Page.Window.Pages == 0 then 
			Page:Turn(true)
		end
		Page.Elements = Items
		TableInsert(Page.Window.Pages, Page)
		return setmetatable(Page, Library.Pages)
	end
	Library.Pages.SubPage = function(self, Data)
		Data = Data or { }
		local SubPage = {
			Window = self.Window,
			Page = self,
			Icon = Data.Icon or Data.icon or "9080568477801",
			Columns = Data.Columns or Data.columns or 2,
			Active = false,
			ColumnsData = { },
			Elements = { }
		}
		local Items = { } do
			Items["Inactive"] = Instances:Create("TextButton", {
				Parent = SubPage.Page.Elements["SubTabs"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(10, 10, 10),
				Text = "",
				AutoButtonColor = false,
				Name = "\0",
				Size = UDim2New(1, 0, 1, -2),
				BorderSizePixel = 2,
				TextSize = 14,
				BackgroundColor3 = FromRGB(30, 30, 35)
			})  Items["Inactive"]:AddToTheme({BackgroundColor3 = "Page Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["Inactive"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Hide"] = Instances:Create("Frame", {
				Parent = Items["Inactive"].Instance,
				Visible = false,
				BorderColor3 = FromRGB(0, 0, 0),
				AnchorPoint = Vector2New(0, 1),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 2),
				Size = UDim2New(1, 0, 0, 2),
				ZIndex = 5,
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(20, 20, 25)
			})  Items["Hide"]:AddToTheme({BackgroundColor3 = "Background"})
			Items["MiscPixel1"] = Instances:Create("Frame", {
				Parent = Items["Hide"].Instance,
				Size = UDim2New(0, 1, 0, 1),
				Name = "\0",
				Position = UDim2New(0, -1, 0, 1),
				BorderColor3 = FromRGB(0, 0, 0),
				ZIndex = 5,
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(27, 27, 32)
			}) 
			Items["MiscPixel2"] = Instances:Create("Frame", {
				Parent = Items["Hide"].Instance,
				BorderColor3 = FromRGB(0, 0, 0),
				AnchorPoint = Vector2New(1, 0),
				Name = "\0",
				Position = UDim2New(1, 1, 0, 1),
				Size = UDim2New(0, 1, 0, 1),
				ZIndex = 5,
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(27, 27, 32)
			}) 
			Items["Icon"] = Instances:Create("ImageLabel", {
				Parent = Items["Inactive"].Instance,
				ScaleType = Enum.ScaleType.Fit,
				ImageTransparency = 0.35,
				BorderColor3 = FromRGB(0, 0, 0),
				Name = "\0",
				AnchorPoint = Vector2New(0.5, 0.5),
				Image = "rbxassetid://"..SubPage.Icon,
				BackgroundTransparency = 1,
				Position = UDim2New(0.5, 0, 0.5, 0),
				Size = UDim2New(0, 30, 0, 30),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Icon"]:AddToTheme({ImageColor3 = "Text"})
			Instances:Create("UIGradient", {
				Parent = Items["Inactive"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(138, 138, 138))}
			}) 
			Items["Subtab"] = Instances:Create("Frame", {
				Parent = SubPage.Page.Elements["Columns"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) 
			Instances:Create("UIPadding", {
				Parent = Items["Subtab"].Instance,
				PaddingTop = UDimNew(0, 6),
				PaddingRight = UDimNew(0, 6),
				PaddingLeft = UDimNew(0, 6)
			}) 
			Instances:Create("UIListLayout", {
				Parent = Items["Subtab"].Instance,
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalFlex = Enum.UIFlexAlignment.Fill,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalFlex = Enum.UIFlexAlignment.Fill
			}) 
			Instances:Create("UIStroke", {
				Parent = Items["Subtab"].Instance,
				Color = FromRGB(27, 27, 32),
				Name = "\0",
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			}):AddToTheme({Color = "Outline"})
			for Index = 1, SubPage.Columns do
				local NewColumn = Instances:Create("ScrollingFrame", {
					Parent = Items["Subtab"].Instance,
					ScrollBarImageColor3 = FromRGB(235, 157, 255),
					Active = true,
					AutomaticCanvasSize = Enum.AutomaticSize.Y,
					ScrollBarThickness = 1,
					Name = "\0",
					BackgroundTransparency = 1,
					Size = UDim2New(0, 100, 0, 100),
					BackgroundColor3 = FromRGB(255, 255, 255),
					BorderColor3 = FromRGB(0, 0, 0),
					BorderSizePixel = 0,
					CanvasSize = UDim2New(0, 0, 0, 0)
				})  NewColumn:AddToTheme({ScrollBarImageColor3 = "Accent"})
				Instances:Create("UIPadding", {
					Parent = NewColumn.Instance,
					PaddingTop = UDimNew(0, 6),
					PaddingBottom = UDimNew(0, 6),
					PaddingRight = UDimNew(0, 6),
					PaddingLeft = UDimNew(0, 6)
				}) 
				Instances:Create("UIListLayout", {
					Parent = NewColumn.Instance,
					Padding = UDimNew(0, 8),
					SortOrder = Enum.SortOrder.LayoutOrder
				}) 
				SubPage.ColumnsData[Index] = NewColumn
			end
		end
		local Debounce = false
		function SubPage:Turn(Bool)
			if Debounce then 
				return 
			end
			SubPage.Active = Bool
			Debounce = true 
			if Bool then 
				Items["Subtab"].Instance.Visible = true
				Items["Icon"]:Tween(nil, {ImageColor3 = Library.Theme.Accent, ImageTransparency = 0})
				Items["Hide"].Instance.Visible = true
				Items["Icon"]:ChangeItemTheme({ImageColor3 = "Accent"})
				Items["Inactive"].Instance.Size = UDim2New(1, 0, 1, 1)
			else
				Items["Icon"]:Tween(nil, {ImageColor3 = Library.Theme.Text, ImageTransparency = 0.35})
				Items["Hide"].Instance.Visible = false
				Items["Icon"]:ChangeItemTheme({ImageColor3 = "Text"})
				Items["Inactive"].Instance.Size = UDim2New(1, 0, 1, -2)
			end
			local Descendants = Items["Subtab"].Instance:GetDescendants()
			TableInsert(Descendants, Items["Subtab"].Instance)
			local NewTween
			for Index, Value in Descendants do 
				local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)
				if ValueIndex then
					if type(ValueIndex) == "table" then
						for _, Property in ValueIndex do 
							NewTween = Library:FadeItem(Value, Property, Bool, SubPage.Window.FadeSpeed or 0.5)
						end
					else
						NewTween = Library:FadeItem(Value, ValueIndex, Bool, SubPage.Window.FadeSpeed or 0.5)
					end
				end
			end
			Library:Connect(NewTween.Tween.Completed, function()
				Debounce = false
				Items["Subtab"].Instance.Visible = Bool
			end)
		end
		Items["Inactive"]:Connect("MouseButton1Down", function()
			for Index, Value in SubPage.Window.SubPages do
				Value:Turn(Value == SubPage)
			end
		end)
		if #SubPage.Window.SubPages == 0 then 
			SubPage:Turn(true)
		end
		SubPage.Elements = Items
		TableInsert(SubPage.Window.SubPages, SubPage)
		return setmetatable(SubPage, Library.Pages)
	end
	Library.Pages.Section = function(self, Data)
		Data = Data or { }
		local Section = {
			Window = self.Window,
			Page = self,
			Name = Data.Name or Data.name or "Section",
			Side = Data.Side or Data.side or 1,
			Elements = { }
		}
		local Items = { } do 
			Items["Section"] = Instances:Create("Frame", {
				Parent = Section.Page.ColumnsData[Section.Side].Instance,
				Name = "\0",
				Size = UDim2New(1, 0, 0, 25),
				BorderColor3 = FromRGB(27, 27, 32),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundColor3 = FromRGB(20, 20, 25)
			})  Items["Section"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Outline"})
			Instances:Create("UIStroke", {
				Parent = Items["Section"].Instance,
				Color = FromRGB(10, 10, 10),
				Name = "\0",
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			}):AddToTheme({Color = "Border"})
			Instances:Create("UIPadding", {
				Parent = Items["Section"].Instance,
				PaddingBottom = UDimNew(0, 6)
			})
			Items["AccentLine"] = Instances:Create("Frame", {
				Parent = Items["Section"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(235, 157, 255)
			})  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UIGradient", {
				Parent = Items["AccentLine"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
			})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Section"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Section.Name,
				Name = "\0",
				Size = UDim2New(1, -12, 0, 15),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Position = UDim2New(0, 4, 0, 2),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Content"] = Instances:Create("Frame", {
				Parent = Items["Section"].Instance,
				Name = "\0",
				BackgroundTransparency = 1,
				Position = UDim2New(0, 7, 0, 21),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, -14, 1, -20),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Instances:Create("UIListLayout", {
				Parent = Items["Content"].Instance,
				Padding = UDimNew(0, 6),
				SortOrder = Enum.SortOrder.LayoutOrder
			})
		end
		Section.Elements = Items
		return setmetatable(Section, Library.Sections)
	end
	Library.Pages.MultiSection = function(self, Data)
		local MultiSection = {
			Window = self.Window,
			Page = self,
			Sections = Data.Sections or Data.sections or { "Section 1", "Section 2", "Section 3" },
			Side = Data.Side or Data.side or 1,
			SectionContents = { },
			Elements = { }
		}
		local Items = { } do
			Items["MultiSection"] = Instances:Create("Frame", {
				Parent = MultiSection.Page.ColumnsData[MultiSection.Side].Instance,
				Name = "\0",
				Size = UDim2New(1, 0, 0, 25),
				BorderColor3 = FromRGB(27, 27, 32),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundColor3 = FromRGB(20, 20, 25)
			})  Items["MultiSection"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Outline"})
			Instances:Create("UIStroke", {
				Parent = Items["MultiSection"].Instance,
				Color = FromRGB(10, 10, 10),
				Name = "\0",
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			}):AddToTheme({Color = "Border"})
			Instances:Create("UIPadding", {
				Parent = Items["MultiSection"].Instance,
				PaddingBottom = UDimNew(0, 6)
			})
			Items["AccentLine"] = Instances:Create("Frame", {
				Parent = Items["MultiSection"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(235, 157, 255)
			})  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UIGradient", {
				Parent = Items["AccentLine"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
			})
			Items["Sections"] = Instances:Create("Frame", {
				Parent = Items["MultiSection"].Instance,
				Name = "\0",
				BackgroundTransparency = 1,
				Position = UDim2New(0, 7, 0, 9),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, -14, 0, 19),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Instances:Create("UIListLayout", {
				Parent = Items["Sections"].Instance,
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalFlex = Enum.UIFlexAlignment.Fill,
				Padding = UDimNew(0, 5),
				SortOrder = Enum.SortOrder.LayoutOrder
			})
			Items["Content"] = Instances:Create("Frame", {
				Parent = Items["MultiSection"].Instance,
				Name = "\0",
				BackgroundTransparency = 1,
				Position = UDim2New(0, 7, 0, 35),
				BorderColor3 = FromRGB(10, 10, 10),
				Size = UDim2New(1, -14, 1, -33),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})
		end
		for Index, Value in MultiSection.Sections do
			local NewSection = {
				Window = MultiSection.Window,
				Page = MultiSection.Page,
				MultiSection = MultiSection,
				Name = Value,
				Elements = { },
				Active = false,
			}
			local SubItems = { } do
				SubItems["Inactive"] = Instances:Create("TextButton", {
					Parent = Items["Sections"].Instance,
					FontFace = Library.Font,
					TextColor3 = FromRGB(0, 0, 0),
					BorderColor3 = FromRGB(10, 10, 10),
					Text = "",
					AutoButtonColor = false,
					Name = "\0",
					Size = UDim2New(1, 0, 1, 0),
					BorderSizePixel = 2,
					TextSize = 14,
					BackgroundColor3 = FromRGB(30, 30, 35)
				})  SubItems["Inactive"]:AddToTheme({BackgroundColor3 = "Page Background", BorderColor3 = "Border"})
				SubItems["Text"] = Instances:Create("TextLabel", {
					Parent = SubItems["Inactive"].Instance,
					FontFace = Library.Font,
					TextColor3 = FromRGB(215, 215, 215),
					TextTransparency = 0.48,
					Text = NewSection.Name,
					Name = "\0",
					Size = UDim2New(1, 0, 1, 0),
					BackgroundTransparency = 1,
					Position = UDim2New(0, 0, 0, -1),
					BorderSizePixel = 0,
					BorderColor3 = FromRGB(0, 0, 0),
					TextSize = 12,
					BackgroundColor3 = FromRGB(255, 255, 255)
				})  SubItems["Text"]:AddToTheme({TextColor3 = "Text"})
				Instances:Create("UIStroke", {
					Parent = SubItems["Text"].Instance,
					LineJoinMode = Enum.LineJoinMode.Miter,
					Name = "\0"
				}):AddToTheme({Color = "Text Border"})
				SubItems["Hide"] = Instances:Create("Frame", {
					Parent = SubItems["Inactive"].Instance,
					Visible = false,
					BorderColor3 = FromRGB(0, 0, 0),
					AnchorPoint = Vector2New(0, 1),
					Name = "\0",
					Position = UDim2New(0, 0, 1, 0),
					Size = UDim2New(1, 0, 0, 3),
					ZIndex = 2,
					BorderSizePixel = 0,
					BackgroundColor3 = FromRGB(15, 15, 20)
				})  SubItems["Hide"]:AddToTheme({BackgroundColor3 = "Background"})
				SubItems["MiscPixel1"] = Instances:Create("Frame", {
					Parent = SubItems["Hide"].Instance,
					Size = UDim2New(0, 1, 0, 1),
					Name = "\0",
					Position = UDim2New(0, -1, 0, 1),
					BorderColor3 = FromRGB(0, 0, 0),
					ZIndex = 2,
					BorderSizePixel = 0,
					BackgroundColor3 = FromRGB(27, 27, 32)
				}) 
				SubItems["MiscPixel2"] = Instances:Create("Frame", {
					Parent = SubItems["Hide"].Instance,
					BorderColor3 = FromRGB(0, 0, 0),
					AnchorPoint = Vector2New(1, 0),
					Name = "\0",
					Position = UDim2New(1, 1, 0, 1),
					Size = UDim2New(0, 1, 0, 1),
					ZIndex = 2,
					BorderSizePixel = 0,
					BackgroundColor3 = FromRGB(27, 27, 32)
				}) 
				Instances:Create("UIStroke", {
					Parent = SubItems["Inactive"].Instance,
					ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
					LineJoinMode = Enum.LineJoinMode.Miter,
					Name = "\0",
					Color = FromRGB(27, 27, 32)
				}):AddToTheme({Color = "Outline"})
				Instances:Create("UIGradient", {
					Parent = SubItems["Inactive"].Instance,
					Rotation = 90,
					Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(108, 108, 108))}
				})
				SubItems["Content"] = Instances:Create("Frame", {
					Parent = Items["Content"].Instance,
					BackgroundTransparency = 1,
					Name = "\0",
					BorderColor3 = FromRGB(0, 0, 0),
					Size = UDim2New(1, 0, 1, 0),
					BorderSizePixel = 0,
					Visible = false,
					BackgroundColor3 = FromRGB(255, 255, 255)
				})
				Instances:Create("UIListLayout", {
					Parent = SubItems["Content"].Instance,
					Padding = UDimNew(0, 6),
					SortOrder = Enum.SortOrder.LayoutOrder
				})
			end
			local Debounce = false
			function NewSection:Turn(Bool)
				if Debounce then 
					return 
				end
				NewSection.Active = Bool
				Debounce = true 
				if Bool then 
					SubItems["Content"].Instance.Visible = true
					SubItems["Text"]:Tween(nil, {TextColor3 = Library.Theme.Accent, TextTransparency = 0})
					SubItems["Text"]:ChangeItemTheme({TextColor3 = "Accent"})
				else
					SubItems["Text"]:Tween(nil, {TextColor3 = Library.Theme.Text, TextTransparency = 0.5})
					SubItems["Text"]:ChangeItemTheme({TextColor3 = "Text"})
				end
				local Descendants = SubItems["Content"].Instance:GetDescendants()
				TableInsert(Descendants, SubItems["Content"].Instance)
				local NewTween
				for Index, Value in Descendants do 
					local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)
					if ValueIndex then
						if type(ValueIndex) == "table" then
							for _, Property in ValueIndex do 
								NewTween = Library:FadeItem(Value, Property, Bool, MultiSection.Window.FadeSpeed or 0.5)
							end
						else
							NewTween = Library:FadeItem(Value, ValueIndex, Bool, MultiSection.Window.FadeSpeed or 0.5)
						end
					end
				end
				Library:Connect(NewTween.Tween.Completed, function()
					Debounce = false
					SubItems["Content"].Instance.Visible = Bool
				end)
			end
			SubItems["Inactive"]:Connect("MouseButton1Down", function()
				for Index, Value in MultiSection.SectionContents do
					Value:Turn(Value == NewSection)
				end
			end)
			if #MultiSection.SectionContents == 0 then 
				NewSection:Turn(true)
			end
			NewSection.Elements = SubItems
			MultiSection.SectionContents[#MultiSection.SectionContents+1] = setmetatable(NewSection, Library.Sections)
		end
		MultiSection.SectionContents[1]:Turn(true)
		MultiSection.Window.Sections[#MultiSection.Window.Sections+1] = MultiSection
		return TableUnpack(MultiSection.SectionContents)
	end
	Library.Pages.ScrollableSection = function(self, Data)
		Data = Data or { }
		local Section = {
			Window = self.Window,
			Page = self,
			Name = Data.Name or Data.name or "Section",
			Side = Data.Side or Data.side or 1,
			Size = Data.Size or Data.size or 175,
			Elements = { }
		}
		local Items = { } do
			Items["Section"] = Instances:Create("Frame", {
				Parent = Section.Page.ColumnsData[Section.Side].Instance,
				Name = "\0",
				Size = UDim2New(1, 0, 0, Section.Size),
				BorderColor3 = FromRGB(27, 27, 32),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundColor3 = FromRGB(20, 20, 25)
			})  Items["Section"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Outline"})
			Items["Fade"] = Instances:Create("Frame", {
				Parent = Items["Section"].Instance,
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 20),
				AnchorPoint = Vector2New(0, 1),
				Position = UDim2New(0, 0, 1, 2),
				BorderSizePixel = 0,
				ZIndex = 15,
				BackgroundColor3 = FromRGB(27, 27, 32)
			})  Items["Fade"]:AddToTheme({BackgroundColor3 = "Inline"})
			Instances:Create("UIGradient", {
				Parent = Items["Fade"].Instance,
				Rotation = -90,
				Transparency = NumSequence{NumSequenceKeypoint(0, 0), NumSequenceKeypoint(0.718, 0.768750011920929), NumSequenceKeypoint(1, 1)}
			})
			Instances:Create("UIStroke", {
				Parent = Items["Section"].Instance,
				Color = FromRGB(10, 10, 10),
				Name = "\0",
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			}):AddToTheme({Color = "Border"})
			Instances:Create("UIPadding", {
				Parent = Items["Section"].Instance,
				PaddingBottom = UDimNew(0, 6)
			})
			Items["AccentLine"] = Instances:Create("Frame", {
				Parent = Items["Section"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 2),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(235, 157, 255)
			})  Items["AccentLine"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UIGradient", {
				Parent = Items["AccentLine"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(65, 65, 65))}
			})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Section"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Section.Name,
				Name = "\0",
				Size = UDim2New(1, -12, 0, 15),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Position = UDim2New(0, 4, 0, 2),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Content"] = Instances:Create("ScrollingFrame", {
				Parent = Items["Section"].Instance,
				Name = "\0",
				ScrollBarThickness = 3,
				AutomaticCanvasSize = Enum.AutomaticSize.Y,
				CanvasSize = UDim2New(0, 0, 0, 0),
				ScrollBarImageColor3 = FromRGB(235, 157, 255),
				MidImage = Library:GetImage("Scrollbar"),
				TopImage = Library:GetImage("Scrollbar"),
				BottomImage = Library:GetImage("Scrollbar"),
				Active = true,
				BackgroundTransparency = 1,
				Position = UDim2New(0, 0, 0, 21),
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, -5, 1, -20),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Content"]:AddToTheme({ScrollBarImageColor3 = "Accent"})
			Instances:Create("UIPadding", {
				Parent = Items["Content"].Instance,
				PaddingTop = UDimNew(0, 0),
				PaddingBottom = UDimNew(0, 8),
				PaddingRight = UDimNew(0, 11),
				PaddingLeft = UDimNew(0, 8)
			})
			Instances:Create("UIListLayout", {
				Parent = Items["Content"].Instance,
				Padding = UDimNew(0, 6),
				SortOrder = Enum.SortOrder.LayoutOrder
			})
		end
		Section.Elements = Items
		return setmetatable(Section, Library.Sections)
	end
	Library.Sections.__index = Library.Sections
	Library.Sections.Divider = function(self)
		local Divider = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
		}
		local Items = { } do
			Items["Divider"] = Instances:Create("Frame", {
				Parent = Divider.Section.Elements["Content"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 10),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["RealDivider"] = Instances:Create("Frame", {
				Parent = Items["Divider"].Instance,
				AnchorPoint = Vector2New(0, 0.5),
				Name = "\0",
				Position = UDim2New(0, 0, 0.5, 0),
				BorderColor3 = FromRGB(10, 10, 10),
				Size = UDim2New(1, 0, 0, 3),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(15, 15, 20)
			})  Items["RealDivider"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["RealDivider"].Instance,
				Color = FromRGB(27, 27, 32),
				Name = "\0",
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			}):AddToTheme({Color = "Outline"})
		end
		function Divider:SetVisibility(Bool)
			Items["Divider"].Instance.Visible = Bool
		end
		return Divider
	end
	Library.Sections.Slider = function(self, Data)
		Data = Data or { }
		local Min = Data.Min or Data.min or 0
		local Max = Data.Max or Data.max or 100
		if Min > Max then
			Min, Max = Max, Min
		end
		local Slider = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
			Name = Data.Name or Data.name or "Slider",
			Flag = Data.Flag or Data.flag or Library:NextFlag(),
			Min = Min,
			Default = Data.Default or Data.default or 0,
			Max = Max,
			Suffix = Data.Suffix or Data.suffix or "",
			Decimals = Data.Decimals or Data.decimals or 1,
			Callback = Data.Callback or Data.callback or function() end,
			Compact = Data.Compact or Data.compact or false,
			Value = 0,
			Sliding = false,
			Class = "Slider",
		}
		if Slider.Decimals < 0 then
			Slider.Decimals = 1
		end
		local Items = { } do
			Items["Slider"] = Instances:Create("Frame", {
				Parent = Slider.Section.Elements["Content"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 27),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Slider"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Slider.Name,
				Name = "\0",
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Size = UDim2New(1, 0, 0, 13),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["RealSlider"] = Instances:Create("TextButton", {
				Parent = Items["Slider"].Instance,
				AnchorPoint = Vector2New(0, 1),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 0),
				BorderColor3 = FromRGB(10, 10, 10),
				Text = "",
				AutoButtonColor = false,
				Size = UDim2New(1, 0, 0, 10),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(33, 33, 36)
			})  Items["RealSlider"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["RealSlider"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIGradient", {
				Parent = Items["RealSlider"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})
			Items["Indicator"] = Instances:Create("Frame", {
				Parent = Items["RealSlider"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(0.5, 0, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(235, 157, 255)
			})  Items["Indicator"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UIGradient", {
				Parent = Items["Indicator"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})
			Items["Value"] = Instances:Create("TextLabel", {
				Parent = Items["RealSlider"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "50/100s",
				Name = "\0",
				BackgroundTransparency = 1,
				Position = UDim2New(0, 0, 0, -1),
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Value"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Value"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			if Slider.Compact then
				Items["Value"]:Clean()
				Items["Value"] = nil
				Items["Slider"].Instance.Size = UDim2New(1,0,0,10)
				Items["Text"].Instance.Parent = Items["RealSlider"].Instance
				Items["Text"].Instance.Position = UDim2New(0,0,0,-2)
				Items["Text"].Instance.TextXAlignment = Enum.TextXAlignment.Center
			end
			Items["RealSlider"]:OnHover(function()
				Items["RealSlider"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
				Items["RealSlider"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
			end)
			Items["RealSlider"]:OnHoverLeave(function()
				Items["RealSlider"]:Tween(nil, {BackgroundColor3 = Library.Theme["Background"]})
				Items["RealSlider"]:ChangeItemTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			end)
		end
		function Slider:Set(Value)
			local num_value = tonumber(Value)
			if not num_value or num_value ~= num_value then
				Value = Slider.Value or Slider.Default or Slider.Min
				num_value = tonumber(Value)
				if not num_value or num_value ~= num_value then
					Value = Slider.Min
				end
			end
			if Slider.Decimals == 0 then
				Slider.Value = MathClamp(math.floor(Value + 0.5), Slider.Min, Slider.Max)
			else
				Slider.Value = MathClamp(Library:Round(Value, Slider.Decimals), Slider.Min, Slider.Max)
			end
			Library.Flags[Slider.Flag] = Slider.Value
			if Slider.Compact then
				Items["Text"].Instance.Text = Slider.Name .. ": " .. Slider.Value .. Slider.Suffix
			else
				Items["Value"].Instance.Text = Slider.Value .. Slider.Suffix
			end
			local range = Slider.Max - Slider.Min
			local indicator_size = 0
			if range > 0 then
				indicator_size = math.clamp((Slider.Value - Slider.Min) / range, 0, 1)
			else
				indicator_size = 0.5
			end
			Items["Indicator"]:Tween(TweenInfo.new(0.17, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2New(indicator_size, 0, 1, 0)})
			if Slider.Callback then
				Library:SafeCall(Slider.Callback, Slider.Value)
			end
		end
		function Slider:Get()
			return Slider.Value
		end
		function Slider:SetVisibility(Bool)
			Items["Slider"].Instance.Visible = Bool
		end
		Items["RealSlider"]:Connect("MouseButton1Down", function()
			Slider.Sliding = true
			local MousePos = UserInputService:GetMouseLocation()
			local sliderSize = Items["RealSlider"].Instance.AbsoluteSize.X
			if sliderSize > 0 then
				local SizeX = math.clamp((MousePos.X - Items["RealSlider"].Instance.AbsolutePosition.X) / sliderSize, 0, 1)
				local range = Slider.Max - Slider.Min
				local Value = (range * SizeX) + Slider.Min
				Slider:Set(Value)
			end
		end)
		Items["RealSlider"]:Connect("InputEnded", function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				Slider.Sliding = false
			end
		end)
		Library:Connect(UserInputService.InputChanged, function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseMovement and Slider.Sliding then
				local MousePos = UserInputService:GetMouseLocation()
				local sliderSize = Items["RealSlider"].Instance.AbsoluteSize.X
				if sliderSize > 0 then
					local SizeX = math.clamp((MousePos.X - Items["RealSlider"].Instance.AbsolutePosition.X) / sliderSize, 0, 1)
					local range = Slider.Max - Slider.Min
					local Value = (range * SizeX) + Slider.Min
					Slider:Set(Value)
				end
			end
		end)
		if Slider.Default then
			Slider:Set(Slider.Default)
		end
		Library.SetFlags[Slider.Flag] = function(Value)
			Slider:Set(Value)
		end
		return Slider
	end
	Library.Sections.Toggle = function(self, Data)
		Data = Data or { }
		local Toggle = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
			Name = Data.Name or Data.name or "Toggle",
			Flag = Data.Flag or Data.flag or Library:NextFlag(),
			Default = Data.Default or Data.default or false,
			Callback = Data.Callback or Data.callback or function() end,
			Value = false,
			Class = "Toggle",
			Count = 0
		}
		local Items = { } do
			Items["Toggle"] = Instances:Create("TextButton", {
				Parent = Toggle.Section.Elements["Content"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "",
				AutoButtonColor = false,
				BackgroundTransparency = 1,
				Name = "\0",
				Size = UDim2New(1, 0, 0, 11),
				BorderSizePixel = 0,
				TextSize = 14,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["Indicator"] = Instances:Create("Frame", {
				Parent = Items["Toggle"].Instance,
				Name = "\0",
				BorderColor3 = FromRGB(10, 10, 10),
				Size = UDim2New(0, 10, 0, 10),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(33, 33, 36)
			})  Items["Indicator"]:AddToTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["Indicator"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIGradient", {
				Parent = Items["Indicator"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Toggle"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				TextTransparency = 0.48,
				Text = Toggle.Name,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				Position = UDim2New(0, 18, 0, -1),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				BorderSizePixel = 0,
				BorderColor3 = FromRGB(0, 0, 0),
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Toggle"]:OnHover(function()
				if Toggle.Value then return end
				Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
				Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
			end)
			Items["Toggle"]:OnHoverLeave(function()
				if Toggle.Value then return end
				Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme["Element"]})
				Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
			end)
		end
		function Toggle:Get()
			return Toggle.Value
		end
		function Toggle:Set(Bool)
			Toggle.Value = Bool or not Toggle.Value
			Library.Flags[Toggle.Flag] = Toggle.Value
			if Toggle.Value then
				Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Accent"})
				Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme.Accent})
				Items["Text"]:Tween(nil, {TextTransparency = 0})
			else
				Items["Indicator"]:ChangeItemTheme({BackgroundColor3 = "Element"})
				Items["Indicator"]:Tween(nil, {BackgroundColor3 = Library.Theme.Element})
				Items["Text"]:Tween(nil, {TextTransparency = 0.48})
			end
			if Toggle.Callback then
				Library:SafeCall(Toggle.Callback, Toggle.Value)
			end
		end
		function Toggle:SetVisiblity(Bool)
			Items["Toggle"].Instance.Visible = Bool
		end
		function Toggle:Colorpicker(Data)
			Data = Data or { }
			local Colorpicker = {
				Window = self.Window,
				Tab = self.Tab,
				Section = self.Section,
				Parent = Items["Toggle"],
				Name = Data.Name or Data.name or "Colorpicker",
				Flag = Data.Flag or Data.flag or Library:NextFlag(),
				Default = Data.Default or Data.default or Color3.fromRGB(255, 255, 255),
				Callback = Data.Callback or Data.callback or function() end,
				Alpha = Data.Alpha or Data.alpha or false,
				Count = self.Count,
				FadeSpeed = self.Window.FadeSpeed
			}
			self.Count = self.Count + 1
			Colorpicker.Count = self.Count
			local Extension = Library:CreateColorpicker(Colorpicker)
			Library.Flags[Colorpicker.Flag] = Extension
			return Colorpicker
		end
		function Toggle:Keybind(Data)
			Data = Data or { }
			local Keybind = {
				Window = self.Window,
				Tab = self.Tab,
				Section = self.Section,
				Parent = Items["Toggle"],
				Name = Data.Name or Data.name or "Keybind",
				Flag = Data.Flag or Data.flag or Library:NextFlag(),
				Default = Data.Default or Data.default or "MB2",
				Mode = Data.Mode or Data.mode or "Toggle",
				Callback = Data.Callback or Data.callback or function() end,
			}
			local Extension = Library:CreateKeybind(Keybind)
			Library.Flags[Keybind.Flag] = Extension
			return Keybind, Extension
		end
		Items["Toggle"]:Connect("MouseButton1Down", function()
			Toggle:Set()
		end)
		if Toggle.Default then
			Toggle:Set(Toggle.Default)
		end
		Library.SetFlags[Toggle.Flag] = function(Value)
			Toggle:Set(Value)
		end
		return Toggle
	end
	Library.Sections.Button = function(self, Data)
		Data = Data or { }
		local Button = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
			Name = Data.Name or Data.name,
			Callback = Data.Callback or Data.callback or function() end,
		}
		local Items = { } do
			Items["Button"] = Instances:Create("TextButton", {
				Parent = Button.Section.Elements["Content"].Instance,
				BorderColor3 = FromRGB(10, 10, 10),
				AutoButtonColor = false,
				Name = "\0",
				Position = UDim2New(0, 0, 1, 0),
				Size = UDim2New(1, 0, 0, 17),
				Selectable = false,
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(33, 33, 36)
			})  Items["Button"]:AddToTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
			Instances:Create("UIGradient", {
				Parent = Items["Button"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})
			Instances:Create("UIStroke", {
				Parent = Items["Button"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Button"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Button.Name,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BackgroundTransparency = 1,
				TextTruncate = Enum.TextTruncate.AtEnd,
				Position = UDim2New(0, 0, 0, -1),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Items["TextBorder"] = Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Button"]:OnHover(function()
				Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
				Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
			end)
			Items["Button"]:OnHoverLeave(function()
				Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme["Element"]})
				Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
			end)
		end
		function Button:Press()
			Library:SafeCall(Button.Callback)
			Items["Text"]:ChangeItemTheme({TextColor3 = "Accent"})
			Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Accent"})
			Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Accent})
			Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme.Accent})
			task.wait(0.1)
			Items["Text"]:ChangeItemTheme({TextColor3 = "Text"})
			Items["Button"]:ChangeItemTheme({BackgroundColor3 = "Element"})
			Items["Text"]:Tween(nil, {TextColor3 = Library.Theme.Text})
			Items["Button"]:Tween(nil, {BackgroundColor3 = Library.Theme.Element})
		end
		function Button:SetVisiblity(Bool)
			Items["Button"].Instance.Visible = Bool
		end
		Items["Button"]:Connect("MouseButton1Down", function()
			Button:Press()
		end)
		return Button
	end
	Library.Sections.Label = function(self, Data)
		Data = Data or { }
		local Label = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
			Name = Data.Name or Data.name,
			Alignment = Data.Alignment or Data.alignment or "Left",
			Count = 0
		}
		local Items = { } do
			Items["Label"] = Instances:Create("Frame", {
				Parent = Label.Section.Elements["Content"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 15),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Label"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Label.Name,
				Name = "\0",
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment[Label.Alignment],
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual,
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
			}):AddToTheme({Color = "Text Border"})
		end
		function Label:Colorpicker(Data)
			Data = Data or { }
			local Colorpicker = {
				Window = self.Window,
				Tab = self.Tab,
				Section = self.Section,
				Parent = Items["Label"],
				Name = Data.Name or Data.name or "Colorpicker",
				Flag = Data.Flag or Data.flag or Library:NextFlag(),
				Default = Data.Default or Data.default or Color3.fromRGB(255, 255, 255),
				Callback = Data.Callback or Data.callback or function() end,
				Alpha = Data.Alpha or Data.alpha or false,
				Count = self.Count,
				FadeSpeed = self.Window.FadeSpeed
			}
			self.Count = self.Count + 1
			Colorpicker.Count = self.Count
			local Extension = Library:CreateColorpicker(Colorpicker)
			return Colorpicker, Extension
		end
		function Label:Keybind(Data)
			Data = Data or { }
			local Keybind = {
				Window = self.Window,
				Tab = self.Tab,
				Section = self.Section,
				Parent = Items["Label"],
				Name = Data.Name or Data.name or "Keybind",
				Flag = Data.Flag or Data.flag or Library:NextFlag(),
				Default = Data.Default or Data.default or "MB2",
				Mode = Data.Mode or Data.mode or "Toggle",
				Callback = Data.Callback or Data.callback or function() end,
			}
			local Extension = Library:CreateKeybind(Keybind)
			return Keybind, Extension
		end
		return Label
	end
	Library.Sections.Dropdown = function(self, Data)
		Data = Data or { }
		local Dropdown = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
			Name = Data.Name or Data.name or "Dropdown",
			Flag = Data.Flag or Data.flag or Library:NextFlag(),
			Items = Data.Items or Data.items or { "One", "Two", "Three" },
			Default = Data.Default or Data.default or nil,
			Callback = Data.Callback or Data.callback or function() end,
			Multi = Data.Multi or Data.multi or false,
			Value = { },
			IsOpen = false,
			Options = { },
			Class = "Dropdown",
		}
		local Items = { } do
			Items["Dropdown"] = Instances:Create("Frame", {
				Parent = Dropdown.Section.Elements["Content"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 34),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Dropdown"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Dropdown.Name,
				Name = "\0",
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Size = UDim2New(1, 0, 0, 13),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["RealDropdown"] = Instances:Create("Frame", {
				Parent = Items["Dropdown"].Instance,
				AnchorPoint = Vector2New(0, 1),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 0),
				BorderColor3 = FromRGB(10, 10, 10),
				Size = UDim2New(1, 0, 0, 17),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(33, 33, 36)
			})  Items["RealDropdown"]:AddToTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Instances:Create("UIGradient", {
				Parent = Items["RealDropdown"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})
			Instances:Create("UIStroke", {
				Parent = Items["RealDropdown"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Open"] = Instances:Create("TextButton", {
				Parent = Items["RealDropdown"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "+",
				AutoButtonColor = false,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Right,
				Position = UDim2New(0, -4, 0, -1),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Open"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Open"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Value"] = Instances:Create("TextLabel", {
				Parent = Items["RealDropdown"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "--",
				Name = "\0",
				Size = UDim2New(1, -25, 1, 0),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextTruncate = Enum.TextTruncate.AtEnd,
				Position = UDim2New(0, 5, 0, -1),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Value"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Value"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["OptionHolder"] = Instances:Create("Frame", {
				Parent = Items["Dropdown"].Instance,
				Visible = false,
				BorderColor3 = FromRGB(10, 10, 10),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 5),
				Size = UDim2New(1, 0, 0, 0),
				BorderSizePixel = 2,
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundColor3 = FromRGB(20, 20, 25)
			})  Items["OptionHolder"]:AddToTheme({BackgroundColor3 = "Inline", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["OptionHolder"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIListLayout", {
				Parent = Items["OptionHolder"].Instance,
				SortOrder = Enum.SortOrder.LayoutOrder
			})
			Instances:Create("UIPadding", {
				Parent = Items["OptionHolder"].Instance,
				PaddingBottom = UDimNew(0, 2)
			})
			Items["RealDropdown"]:OnHover(function()
				Items["RealDropdown"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
				Items["RealDropdown"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
			end)
			Items["RealDropdown"]:OnHoverLeave(function()
				Items["RealDropdown"]:Tween(nil, {BackgroundColor3 = Library.Theme["Background"]})
				Items["RealDropdown"]:ChangeItemTheme({BackgroundColor3 = "Background", BorderColor3 = "Border"})
			end)
		end
		function Dropdown:Set(Option)
			if Dropdown.Multi then
				if type(Option) ~= "table" then return end
				Dropdown.Value = Option
				for Index, Value in Option do
					local OptionData = Dropdown.Options[Value]
					if not OptionData then return end
					OptionData.Selected = true
					OptionData:Toggle("Active")
				end
				Library.Flags[Dropdown.Flag] = Dropdown.Value
				Items["Value"].Instance.Text = TableConcat(Option, ", ")
			else
				if not Dropdown.Options[Option] then return end
				local OptionData = Dropdown.Options[Option]
				Dropdown.Value = OptionData.Name
				OptionData.Selected = true
				OptionData:Toggle("Active")
				for Index, Value in Dropdown.Options do
					if Value ~= OptionData then
						Value.Selected = false
						Value:Toggle("Inactive")
					end
				end
				Library.Flags[Dropdown.Flag] = Dropdown.Value
				Items["Value"].Instance.Text = Option
			end
			if Dropdown.Callback then
				Library:SafeCall(Dropdown.Callback, Option)
			end
		end
		function Dropdown:Get()
			return Dropdown.Value
		end
		function Dropdown:SetVisibility(Bool)
			Items["Dropdown"].Instance.Visible = Bool
		end
		function Dropdown:Add(Option)
			local OptionButton = Instances:Create("TextButton", {
				Parent = Items["OptionHolder"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "",
				AutoButtonColor = false,
				Name = "\0",
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2New(1, 0, 0, 15),
				ZIndex = 5,
				TextSize = 14,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			local OptionText = Instances:Create("TextLabel", {
				Parent = OptionButton.Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				TextTransparency = 0.48,
				Text = Option,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, -5, 1, 0),
				Position = UDim2New(0, 5, 0, 0),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				BorderSizePixel = 0,
				ZIndex = 5,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  OptionText:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = OptionText.Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			local OptionData = {
				Selected = false,
				Name = Option,
				Text = OptionText,
				Button = OptionButton
			}
			function OptionData:Toggle(State)
				if State == "Active" then
					OptionData.Text:ChangeItemTheme({TextColor3 = "Accent"})
					OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Accent, TextTransparency = 0})
				else
					OptionData.Text:ChangeItemTheme({TextColor3 = "Text"})
					OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Text, TextTransparency = 0.48})
				end
			end
			function OptionData:Set()
				OptionData.Selected = not OptionData.Selected
				if Dropdown.Multi then
					local Index = TableFind(Dropdown.Value, OptionData.Name)
					if Index then
						TableRemove(Dropdown.Value, Index)
					else
						TableInsert(Dropdown.Value, OptionData.Name)
					end
					Library.Flags[Dropdown.Flag] = Dropdown.Value
					OptionData:Toggle(Index and "Inactive" or "Active")
					local TextFormat = #Dropdown.Value > 0 and TableConcat(Dropdown.Value, ", ") or "--"
					Items["Value"].Instance.Text = TextFormat
				else
					if OptionData.Selected then
						Dropdown.Value = OptionData.Name
						Library.Flags[Dropdown.Flag] = Dropdown.Value
						OptionData:Toggle("Active")
						Items["Value"].Instance.Text = OptionData.Name
						for Index, Value in Dropdown.Options do
							if Value ~= OptionData then
								Value.Selected = false
								Value:Toggle("Inactive")
							end
						end
					else
						Dropdown.Value = nil
						OptionData:Toggle("Inactive")
						Items["Value"].Instance.Text = "--"
					end
				end
				if Dropdown.Callback then
					Library:SafeCall(Dropdown.Callback, Dropdown.Value)
				end
			end
			OptionButton:Connect("MouseButton1Down", function()
				OptionData:Set()
			end)
			Dropdown.Options[Option] = OptionData
			return OptionData
		end
		function Dropdown:Remove(Option)
			if Dropdown.Options[Option] then
				Dropdown.Options[Option].Button:Clean()
			end
		end
		function Dropdown:Refresh(List)
			for Index, Value in Dropdown.Options do
				Dropdown:Remove(Value.Name)
			end
			for Index, Value in List do
				Dropdown:Add(Value)
			end
		end
		local Debounce = false
		function Dropdown:SetOpen(Bool)
			if Debounce then return end
			Dropdown.IsOpen = Bool
			Debounce = true
			if Bool then
				Items["OptionHolder"].Instance.Visible = true
				Items["OptionHolder"].Instance.ZIndex = 15
				Items["Open"].Instance.Text = "-"
				Items["Open"].Instance.Position = UDim2New(0, -5, 0, -1)
			else
				Items["Open"].Instance.Text = "+"
				Items["Open"].Instance.Position = UDim2New(0, -4, 0, -1)
			end
			local Descendants = Items["OptionHolder"].Instance:GetDescendants()
			TableInsert(Descendants, Items["OptionHolder"].Instance)
			local NewTween
			for Index, Value in Descendants do
				local ValueIndex = Library:GetTransparencyPropertyFromItem(Value)
				if ValueIndex then
					if not StringFind(Value.ClassName, "UI") then
						Value.ZIndex = Bool and 15 or 1
					end
					if type(ValueIndex) == "table" then
						for _, Property in ValueIndex do
							NewTween = Library:FadeItem(Value, Property, Bool, Dropdown.Window.FadeSpeed)
						end
					else
						NewTween = Library:FadeItem(Value, ValueIndex, Bool, Dropdown.Window.FadeSpeed)
					end
				end
			end
			Library:Connect(NewTween.Tween.Completed, function()
				Debounce = false
				Items["OptionHolder"].Instance.Visible = Bool
				Items["OptionHolder"].Instance.ZIndex = Bool and 15 or 1
			end)
		end
		for Index, Value in Dropdown.Items do
			Dropdown:Add(Value)
		end
		Items["Open"]:Connect("MouseButton1Down", function()
			Dropdown:SetOpen(not Dropdown.IsOpen)
		end)
		if Dropdown.Default then
			Dropdown:Set(Dropdown.Default)
		end
		Library.SetFlags[Dropdown.Flag] = function(Value)
			Dropdown:Set(Value)
		end
		return Dropdown
	end
	Library.Sections.Textbox = function(self, Data)
		Data = Data or { }
		local Textbox = {
			Window = self.Window,
			Tab = self.Tab,
			Section = self,
			Name = Data.Name or Data.name or "Textbox",
			Flag = Data.Flag or Data.flag or Library:NextFlag(),
			Placeholder = Data.Placeholder or Data.placeholder or "...",
			Default = Data.Default or Data.default or "",
			Callback = Data.Callback or Data.callback or function() end,
			Value = "",
			Class = "Textbox"
		}
		local Items = { } do
			Items["Textbox"] = Instances:Create("Frame", {
				Parent = Textbox.Section.Elements["Content"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, 34),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["Text"] = Instances:Create("TextLabel", {
				Parent = Items["Textbox"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = Textbox.Name,
				Name = "\0",
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Size = UDim2New(1, 0, 0, 13),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Text"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Text"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Background"] = Instances:Create("Frame", {
				Parent = Items["Textbox"].Instance,
				AnchorPoint = Vector2New(0, 1),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 0),
				BorderColor3 = FromRGB(10, 10, 10),
				Size = UDim2New(1, 0, 0, 17),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(33, 33, 36)
			})  Items["Background"]:AddToTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
			Instances:Create("UIGradient", {
				Parent = Items["Background"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})
			Instances:Create("UIStroke", {
				Parent = Items["Background"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Items["Inline"] = Instances:Create("TextBox", {
				Parent = Items["Background"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "",
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BorderSizePixel = 0,
				ClearTextOnFocus = false,
				BackgroundTransparency = 1,
				PlaceholderColor3 = FromRGB(178, 178, 178),
				TextXAlignment = Enum.TextXAlignment.Left,
				PlaceholderText = Textbox.Placeholder,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  Items["Inline"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIPadding", {
				Parent = Items["Inline"].Instance,
				PaddingBottom = UDimNew(0, 3),
				PaddingLeft = UDimNew(0, 5)
			})
			Instances:Create("UIStroke", {
				Parent = Items["Inline"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["Background"]:OnHover(function()
				Items["Background"]:Tween(nil, {BackgroundColor3 = Library.Theme["Hovered Element"]})
				Items["Background"]:ChangeItemTheme({BackgroundColor3 = "Hovered Element", BorderColor3 = "Border"})
			end)
			Items["Background"]:OnHoverLeave(function()
				Items["Background"]:Tween(nil, {BackgroundColor3 = Library.Theme["Element"]})
				Items["Background"]:ChangeItemTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
			end)
		end
		function Textbox:Get()
			return Textbox.Value
		end
		function Textbox:SetVisibility(Bool)
			Items["Textbox"].Instance.Visible = Bool
		end
		function Textbox:Set(Value)
			Textbox.Value = Value
			Items["Inline"].Instance.Text = Textbox.Value
			Items["Inline"]:Tween(nil, {TextColor3 = Library.Theme.Text})
			Items["Inline"]:ChangeItemTheme({TextColor3 = "Text"})
			Library.Flags[Textbox.Flag] = Textbox.Value
			if Textbox.Callback then
				Library:SafeCall(Textbox.Callback, Textbox.Value)
			end
		end
		Items["Inline"]:Connect("Focused", function()
			Items["Inline"]:ChangeItemTheme({TextColor3 = "Accent"})
			Items["Inline"]:Tween(nil, {TextColor3 = Library.Theme.Accent})
		end)
		Items["Inline"]:Connect("FocusLost", function()
			Items["Inline"]:ChangeItemTheme({TextColor3 = "Text"})
			Items["Inline"]:Tween(nil, {TextColor3 = Library.Theme.Text})
			Textbox:Set(Items["Inline"].Instance.Text)
		end)
		if Textbox.Default then
			Textbox:Set(Textbox.Default)
		end
		Library.SetFlags[Textbox.Flag] = function(Value)
			Textbox:Set(Value)
		end
		return Textbox
	end
	Library.Sections.Listbox = function(self, Data)
		Data = Data or {}
		local Listbox = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
			Items = Data.Items or Data.items or { },
			Multi = Data.Multi or Data.multi or false,
			Default = Data.Default or Data.default or 1,
			Flag = Data.Flag or Data.flag or Library:NextFlag(),
			Callback = Data.Callback or Data.callback or function() end,
			Size = Data.Size or Data.size or 175,
			Value = { },
			Options = { },
			Class = "Listbox",
		}
		local Items = { } do
			Items["Listbox"] = Instances:Create("Frame", {
				Parent = Listbox.Section.Elements["Content"].Instance,
				Name = "\0",
				BackgroundTransparency = 1,
				Size = UDim2New(1, 0, 0, Listbox.Size),
				BorderColor3 = FromRGB(0, 0, 0),
				BorderSizePixel = 0,
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["RealListbox"] = Instances:Create("ScrollingFrame", {
				Parent = Items["Listbox"].Instance,
				ScrollBarImageColor3 = FromRGB(235, 157, 255),
				Active = true,
				AutomaticCanvasSize = Enum.AutomaticSize.Y,
				ScrollBarThickness = 1,
				AnchorPoint = Vector2New(0, 1),
				Size = UDim2New(1, 0, 1, 0),
				Name = "\0",
				Position = UDim2New(0, 0, 1, 0),
				BackgroundColor3 = FromRGB(15, 15, 20),
				BorderColor3 = FromRGB(10, 10, 10),
				BorderSizePixel = 2,
				CanvasSize = UDim2New(0, 0, 0, 0)
			})  Items["RealListbox"]:AddToTheme({ScrollBarImageColor3 = "Accent", BackgroundColor3 = "Background", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["RealListbox"].Instance,
				Color = FromRGB(27, 27, 32),
				Name = "\0",
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIListLayout", {
				Parent = Items["RealListbox"].Instance,
				SortOrder = Enum.SortOrder.LayoutOrder
			})
			Instances:Create("UIPadding", {
				Parent = Items["RealListbox"].Instance,
				PaddingBottom = UDimNew(0, 5),
				PaddingTop = UDimNew(0, 2)
			})
		end
		function Listbox:Set(Option)
			if Listbox.Multi then
				if type(Option) ~= "table" then return end
				Listbox.Value = Option
				Library.Flags[Listbox.Flag] = Listbox.Value
				for Index, Value in Option do
					local OptionData = Listbox.Options[Value]
					if not OptionData then return end
					OptionData.Selected = true
					OptionData:Toggle("Active")
				end
			else
				if not Listbox.Options[Option] then return end
				local OptionData = Listbox.Options[Option]
				Listbox.Value = OptionData.Name
				Library.Flags[Listbox.Flag] = Listbox.Value
				OptionData.Selected = true
				OptionData:Toggle("Active")
				for Index, Value in Listbox.Options do
					if Value ~= OptionData then
						Value.Selected = false
						Value:Toggle("Inactive")
					end
				end
			end
			if Listbox.Callback then
				Library:SafeCall(Listbox.Callback, Option)
			end
		end
		function Listbox:Get()
			return Listbox.Value
		end
		function Listbox:SetVisibility(Bool)
			Items["Listbox"].Instance.Visible = Bool
		end
		function Listbox:Remove(Option)
			if Listbox.Options[Option] then
				Listbox.Options[Option].Button:Clean()
			end
		end
		function Listbox:Refresh(List)
			for Index, Value in Listbox.Options do
				Listbox:Remove(Value.Name)
			end
			for Index, Value in List do
				Listbox:Add(Value)
			end
		end
		function Listbox:Add(Option)
			local OptionButton = Instances:Create("TextButton", {
				Parent = Items["RealListbox"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(0, 0, 0),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = "",
				AutoButtonColor = false,
				Name = "\0",
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2New(1, 0, 0, 15),
				ZIndex = 5,
				TextSize = 14,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			local OptionText = Instances:Create("TextLabel", {
				Parent = OptionButton.Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				TextTransparency = 0.48,
				Text = Option,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, -5, 1, 0),
				Position = UDim2New(0, 5, 0, 0),
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Center,
				BorderSizePixel = 0,
				ZIndex = 5,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})  OptionText:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = OptionText.Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			local OptionData = {
				Selected = false,
				Name = Option,
				Text = OptionText,
				Button = OptionButton
			}
			function OptionData:Toggle(State)
				if State == "Active" then
					OptionData.Text:ChangeItemTheme({TextColor3 = "Accent"})
					OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Accent, TextTransparency = 0})
				else
					OptionData.Text:ChangeItemTheme({TextColor3 = "Text"})
					OptionData.Text:Tween(nil, {TextColor3 = Library.Theme.Text, TextTransparency = 0.48})
				end
			end
			function OptionData:Set()
				OptionData.Selected = not OptionData.Selected
				if Listbox.Multi then
					local Index = TableFind(Listbox.Value, OptionData.Name)
					if Index then
						TableRemove(Listbox.Value, Index)
					else
						TableInsert(Listbox.Value, OptionData.Name)
					end
					OptionData:Toggle(Index and "Inactive" or "Active")
					local TextFormat = #Listbox.Value > 0 and TableConcat(Listbox.Value, ", ") or "--"
				else
					if OptionData.Selected then
						Listbox.Value = OptionData.Name
						OptionData:Toggle("Active")
						for Index, Value in Listbox.Options do
							if Value ~= OptionData then
								Value.Selected = false
								Value:Toggle("Inactive")
							end
						end
					else
						Listbox.Value = nil
						OptionData:Toggle("Inactive")
					end
				end
				if Listbox.Callback then
					Library:SafeCall(Listbox.Callback, Listbox.Value)
				end
			end
			OptionButton:Connect("MouseButton1Down", function()
				OptionData:Set()
			end)
			Listbox.Options[Option] = OptionData
			return OptionData
		end
		for Index, Value in Listbox.Items do
			Listbox:Add(Value)
		end
		if Listbox.Default then
			Listbox:Set(Listbox.Default)
		end
		Library.SetFlags[Listbox.Flag] = function(Value)
			Listbox:Set(Value)
		end
		return Listbox
	end
	Library.Sections.CurveEditor = function(self, Data)
		Data = Data or {}
		local CurveEditor = {
			Window = self.Window,
			Page = self.Page,
			Section = self,
			Name = Data.Name or Data.name or "Curve Editor",
			Flag = Data.Flag or Data.flag or Library:NextFlag(),
			Size = Data.Size or Data.size or 200,
			ControlPoint1X = Data.ControlPoint1X or Data.control_point_1_x or 0.3,
			ControlPoint1Y = Data.ControlPoint1Y or Data.control_point_1_y or 0.1,
			ControlPoint2X = Data.ControlPoint2X or Data.control_point_2_x or 0.7,
			ControlPoint2Y = Data.ControlPoint2Y or Data.control_point_2_y or 0.9,
			Callback = Data.Callback or Data.callback or function() end,
			Class = "CurveEditor"
		}
		local Items = {} do
			Items["CurveEditor"] = Instances:Create("Frame", {
				Parent = CurveEditor.Section.Elements["Content"].Instance,
				BackgroundTransparency = 1,
				Name = "\0",
				BorderColor3 = FromRGB(0, 0, 0),
				Size = UDim2New(1, 0, 0, CurveEditor.Size),
				BorderSizePixel = 0,
				BackgroundColor3 = FromRGB(255, 255, 255)
			})
			Items["Label"] = Instances:Create("TextLabel", {
				Parent = Items["CurveEditor"].Instance,
				FontFace = Library.Font,
				TextColor3 = FromRGB(215, 215, 215),
				BorderColor3 = FromRGB(0, 0, 0),
				Text = CurveEditor.Name,
				Name = "\0",
				BackgroundTransparency = 1,
				TextXAlignment = Enum.TextXAlignment.Left,
				Size = UDim2New(1, 0, 0, 13),
				BorderSizePixel = 0,
				TextSize = 12,
				BackgroundColor3 = FromRGB(255, 255, 255)
			}) Items["Label"]:AddToTheme({TextColor3 = "Text"})
			Instances:Create("UIStroke", {
				Parent = Items["Label"].Instance,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0"
			}):AddToTheme({Color = "Text Border"})
			Items["CurveFrame"] = Instances:Create("Frame", {
				Parent = Items["CurveEditor"].Instance,
				Name = "\0",
				Size = UDim2New(1, 0, 0, CurveEditor.Size - 20),
				Position = UDim2New(0, 0, 0, 15),
				BorderColor3 = FromRGB(10, 10, 10),
				BorderSizePixel = 2,
				BackgroundColor3 = FromRGB(33, 33, 36)
			}) Items["CurveFrame"]:AddToTheme({BackgroundColor3 = "Element", BorderColor3 = "Border"})
			Instances:Create("UIStroke", {
				Parent = Items["CurveFrame"].Instance,
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				LineJoinMode = Enum.LineJoinMode.Miter,
				Name = "\0",
				Color = FromRGB(27, 27, 32)
			}):AddToTheme({Color = "Outline"})
			Instances:Create("UIGradient", {
				Parent = Items["CurveFrame"].Instance,
				Rotation = 90,
				Color = RGBSequence{RGBSequenceKeypoint(0, FromRGB(255, 255, 255)), RGBSequenceKeypoint(1, FromRGB(100, 100, 100))}
			})
			Items["GridBackground"] = Instances:Create("Frame", {
				Parent = Items["CurveFrame"].Instance,
				Name = "\0",
				Size = UDim2New(1, -4, 1, -4),
				Position = UDim2New(0, 2, 0, 2),
				BackgroundColor3 = FromRGB(20, 20, 25),
				BorderSizePixel = 0
			}) Items["GridBackground"]:AddToTheme({BackgroundColor3 = "Inline"})
			for i = 0, 10 do
				local line_v = Instances:Create("Frame", {
					Parent = Items["GridBackground"].Instance,
					Name = "\0",
					Size = UDim2New(0, 1, 1, 0),
					Position = UDim2New(i / 10, 0, 0, 0),
					BackgroundColor3 = FromRGB(15, 15, 15),
					BorderSizePixel = 0,
					BackgroundTransparency = 0.7
				}) line_v:AddToTheme({BackgroundColor3 = "Outline"})
				local line_h = Instances:Create("Frame", {
					Parent = Items["GridBackground"].Instance,
					Name = "\0",
					Size = UDim2New(1, 0, 0, 1),
					Position = UDim2New(0, 0, i / 10, 0),
					BackgroundColor3 = FromRGB(15, 15, 15),
					BorderSizePixel = 0,
					BackgroundTransparency = 0.7
				}) line_h:AddToTheme({BackgroundColor3 = "Outline"})
			end
			Items["Canvas"] = Instances:Create("Frame", {
				Parent = Items["CurveFrame"].Instance,
				Name = "\0",
				Size = UDim2New(1, 0, 1, 0),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				ZIndex = 1
			})
			Items["CP1"] = Instances:Create("Frame", {
				Parent = Items["CurveFrame"].Instance,
				Name = "\0",
				Size = UDim2New(0, 12, 0, 12),
				BackgroundColor3 = FromRGB(235, 157, 255),
				BorderSizePixel = 0,
				ZIndex = 3
			}) Items["CP1"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UICorner", {
				Parent = Items["CP1"].Instance,
				CornerRadius = UDimNew(0, 6)
			})
			Instances:Create("UIStroke", {
				Parent = Items["CP1"].Instance,
				Color = FromRGB(27, 27, 32),
				Thickness = 1
			}):AddToTheme({Color = "Outline"})
			Items["CP1Button"] = Instances:Create("TextButton", {
				Parent = Items["CP1"].Instance,
				Size = UDim2New(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Text = "",
				Name = "\0"
			})
			Items["CP2"] = Instances:Create("Frame", {
				Parent = Items["CurveFrame"].Instance,
				Name = "\0",
				Size = UDim2New(0, 12, 0, 12),
				BackgroundColor3 = FromRGB(235, 157, 255),
				BorderSizePixel = 0,
				ZIndex = 3
			}) Items["CP2"]:AddToTheme({BackgroundColor3 = "Accent"})
			Instances:Create("UICorner", {
				Parent = Items["CP2"].Instance,
				CornerRadius = UDimNew(0, 6)
			})
			Instances:Create("UIStroke", {
				Parent = Items["CP2"].Instance,
				Color = FromRGB(27, 27, 32),
				Thickness = 1
			}):AddToTheme({Color = "Outline"})
			Items["CP2Button"] = Instances:Create("TextButton", {
				Parent = Items["CP2"].Instance,
				Size = UDim2New(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Text = "",
				Name = "\0"
			})
		end
		local dragging = nil
		local drag_connection = nil
		local end_connection = nil
		local curve_segments = {}
		local function update_curve()
			local cp1_x = CurveEditor.ControlPoint1X
			local cp1_y = CurveEditor.ControlPoint1Y
			local cp2_x = CurveEditor.ControlPoint2X
			local cp2_y = CurveEditor.ControlPoint2Y
			local size = Items["CurveFrame"].Instance.AbsoluteSize
			if size.X <= 0 or size.Y <= 0 then return end
			
			Items["CP1"].Instance.Position = UDim2New(cp1_x, -6, 1 - cp1_y, -6)
			Items["CP2"].Instance.Position = UDim2New(cp2_x, -6, 1 - cp2_y, -6)
			
			local segment_count = 80
			local last_x, last_y = nil, nil
			local segment_index = 1
			
			for i = 0, segment_count do
				local t = i / segment_count
				local u = 1 - t
				local tt = t * t
				local uu = u * u
				local uuu = uu * u
				local ttt = tt * t
				local x = (uuu * 0 + 3 * uu * t * cp1_x + 3 * u * tt * cp2_x + ttt * 1) * size.X
				local y = (1 - (uuu * 0 + 3 * uu * t * cp1_y + 3 * u * tt * cp2_y + ttt * 1)) * size.Y
				
				if last_x then
					local dx = x - last_x
					local dy = y - last_y
					local length = math.sqrt(dx * dx + dy * dy)
					
					if length > 0.1 then
						local segment = curve_segments[segment_index]
						if not segment then
							segment = Instances:Create("Frame", {
								Parent = Items["Canvas"].Instance,
								Name = "CurveSegment",
								Size = UDim2New(0, length, 0, 2.5),
								Position = UDim2New(0, last_x, 0, last_y - 1.25),
								BackgroundColor3 = FromRGB(255, 0, 0),
								BorderSizePixel = 0,
								AnchorPoint = Vector2New(0, 0.5),
								Rotation = math.deg(math.atan2(dy, dx)),
								ZIndex = 2
							})
							segment:AddToTheme({BackgroundColor3 = "Accent"})
							Instances:Create("UIStroke", {
								Parent = segment.Instance,
								Color = FromRGB(255, 0, 0),
								Thickness = 0.5,
								Transparency = 0.3
							}):AddToTheme({Color = "Accent"})
							Instances:Create("UICorner", {
								Parent = segment.Instance,
								CornerRadius = UDimNew(0, 1)
							})
							curve_segments[segment_index] = segment
						else
							segment.Instance.Size = UDim2New(0, length, 0, 2.5)
							segment.Instance.Position = UDim2New(0, last_x, 0, last_y - 1.25)
							segment.Instance.Rotation = math.deg(math.atan2(dy, dx))
							segment.Instance.Visible = true
						end
						segment_index = segment_index + 1
					end
				end
				last_x, last_y = x, y
			end
			
			for i = segment_index, #curve_segments do
				if curve_segments[i] then
					curve_segments[i].Instance.Visible = false
				end
			end
		end
		local function update_from_drag(cp_num, new_x, new_y)
			new_x = MathClamp(new_x, 0, 1)
			new_y = MathClamp(new_y, 0, 1)
			if cp_num == 1 then
				CurveEditor.ControlPoint1X = new_x
				CurveEditor.ControlPoint1Y = new_y
			else
				CurveEditor.ControlPoint2X = new_x
				CurveEditor.ControlPoint2Y = new_y
			end
			Library.Flags[CurveEditor.Flag] = {
				CP1X = CurveEditor.ControlPoint1X,
				CP1Y = CurveEditor.ControlPoint1Y,
				CP2X = CurveEditor.ControlPoint2X,
				CP2Y = CurveEditor.ControlPoint2Y
			}
			update_curve()
			if CurveEditor.Callback then
				Library:SafeCall(CurveEditor.Callback, CurveEditor.ControlPoint1X, CurveEditor.ControlPoint1Y, CurveEditor.ControlPoint2X, CurveEditor.ControlPoint2Y)
			end
		end
		local function stop_drag()
			if drag_connection then
				if drag_connection.Connection then
					drag_connection.Connection:Disconnect()
				end
				drag_connection = nil
			end
			if end_connection then
				if end_connection.Connection then
					end_connection.Connection:Disconnect()
				end
				end_connection = nil
			end
			dragging = nil
		end
		local function start_drag(cp_num)
			if dragging then 
				stop_drag()
			end
			dragging = cp_num
			local drag_input_connection
			drag_input_connection = UserInputService.InputChanged:Connect(function(move_input)
				if dragging == cp_num and (move_input.UserInputType == Enum.UserInputType.MouseMovement or move_input.UserInputType == Enum.UserInputType.Touch) then
					local mouse_pos = move_input.Position
					local curve_size = Items["CurveFrame"].Instance.AbsoluteSize
					local curve_pos = Items["CurveFrame"].Instance.AbsolutePosition
					if curve_size.X > 0 and curve_size.Y > 0 then
						local relative_x = MathClamp((mouse_pos.X - curve_pos.X) / curve_size.X, 0, 1)
						local relative_y = MathClamp((mouse_pos.Y - curve_pos.Y) / curve_size.Y, 0, 1)
						update_from_drag(cp_num, relative_x, 1 - relative_y)
					end
				end
			end)
			drag_connection = {Connection = drag_input_connection}
			local end_input_connection
			end_input_connection = UserInputService.InputEnded:Connect(function(end_input)
				if end_input.UserInputType == Enum.UserInputType.MouseButton1 or end_input.UserInputType == Enum.UserInputType.Touch then
					if drag_input_connection then
						drag_input_connection:Disconnect()
					end
					if end_input_connection then
						end_input_connection:Disconnect()
					end
					stop_drag()
				end
			end)
			end_connection = {Connection = end_input_connection}
		end
		Items["CP1Button"]:Connect("MouseButton1Down", function()
			start_drag(1)
		end)
		Items["CP2Button"]:Connect("MouseButton1Down", function()
			start_drag(2)
		end)
		Items["CurveFrame"].Instance:GetPropertyChangedSignal("AbsoluteSize"):Connect(update_curve)
		function CurveEditor:Set(CP1X, CP1Y, CP2X, CP2Y)
			if CP1X then CurveEditor.ControlPoint1X = MathClamp(CP1X, 0, 1) end
			if CP1Y then CurveEditor.ControlPoint1Y = MathClamp(CP1Y, 0, 1) end
			if CP2X then CurveEditor.ControlPoint2X = MathClamp(CP2X, 0, 1) end
			if CP2Y then CurveEditor.ControlPoint2Y = MathClamp(CP2Y, 0, 1) end
			update_curve()
			Library.Flags[CurveEditor.Flag] = {
				CP1X = CurveEditor.ControlPoint1X,
				CP1Y = CurveEditor.ControlPoint1Y,
				CP2X = CurveEditor.ControlPoint2X,
				CP2Y = CurveEditor.ControlPoint2Y
			}
		end
		function CurveEditor:Get()
			return CurveEditor.ControlPoint1X, CurveEditor.ControlPoint1Y, CurveEditor.ControlPoint2X, CurveEditor.ControlPoint2Y
		end
		function CurveEditor:SetVisibility(Bool)
			if Items["CurveEditor"] and Items["CurveEditor"].Instance then
				Items["CurveEditor"].Instance.Visible = Bool ~= false
			end
		end
		update_curve()
		Library.SetFlags[CurveEditor.Flag] = function(Value)
			if type(Value) == "table" then
				CurveEditor:Set(Value.CP1X, Value.CP1Y, Value.CP2X, Value.CP2Y)
			end
		end
		return CurveEditor
	end
end
local genv = getgenv()
if genv then
	genv.Library = Library
end

local Stranded = { 
		visuals_enabled = true,
		aimbot = {
		enabled = false,
		keybind = "Q",
		type = "Camera",
		method = "Closest to Mouse",
		mode = "Hold",
		sticky_aim = false,
		settings = {
			bone = "Head",
			prediction = false,
			prediction = 0.17,
			auto_prediction = false,
			smoothness = false,

			smoothness = 1,
		},
		easing = {
			type = "Linear",
			speed = 1,
			bezier_curves = false,
			bezier_curves_enabled = false,
			custom_easing = false,
			control_point_1_x = 0.3,
			control_point_1_y = 0.1,
			control_point_2_x = 0.7,
			control_point_2_y = 0.9,
			ease_in_quad = {0.55, 0.085, 0.68, 0.53},
			ease_out_quad = {0.25, 0.46, 0.45, 0.94},
			ease_in_out_quad = {0.455, 0.03, 0.515, 0.955},
			ease_in_cubic = {0.55, 0.055, 0.675, 0.19},
			ease_out_cubic = {0.215, 0.61, 0.355, 1},
			ease_in_out_cubic = {0.645, 0.045, 0.355, 1},
			ease_in_quart = {0.895, 0.03, 0.685, 0.22},
			ease_out_quart = {0.165, 0.84, 0.44, 1},
			ease_in_out_quart = {0.77, 0, 0.175, 1},
			ease_in_quint = {0.755, 0.05, 0.855, 0.06},
			ease_out_quint = {0.23, 1, 0.32, 1},
			ease_in_out_quint = {0.86, 0, 0.07, 1},
			ease_in_sine = {0.47, 0, 0.745, 0.715},
			ease_out_sine = {0.39, 0.575, 0.565, 1},
			ease_in_out_sine = {0.445, 0.05, 0.55, 0.95},
			ease_in_expo = {0.95, 0.05, 0.795, 0.035},
			ease_out_expo = {0.19, 1, 0.22, 1},
			ease_in_out_expo = {1, 0, 0, 1},
			ease_in_circ = {0.6, 0.04, 0.98, 0.335},
			ease_out_circ = {0.075, 0.82, 0.165, 1},
			ease_in_out_circ = {0.785, 0.135, 0.15, 0.86},
			ease_in_back = {0.6, -0.28, 0.735, 0.045},
			ease_out_back = {0.175, 0.885, 0.32, 1.275},
			ease_in_out_back = {0.68, -0.55, 0.265, 1.55},
		}
	},
	target_aim = {
		enabled = false,
		keybind = "E",
		Method = "FOV",
		settings = {
			bone = "Head",
			prediction = 0.17,
			auto_prediction = false,
			lookat = false,
			spectate = false,
			highlight_target = false,
			highlight_fill_color = Color3.fromRGB(255, 0, 0),
			highlight_outline_color = Color3.fromRGB(255, 255, 255),
			name_target = false,
			sticky_aim = false,
		},
	},
	triggerbot = {
		enabled = false,
		whitelist = {},
		keybind = "B",
		settings = {
			delay = 0.1,
			prediction = 0.17,
			auto_prediction = false,

		},
	},
	Mods = {
		checks = {
			Dead = false,
			Teamcheck = false,
			Wallcheck = false,
			Forcefield = false,
		},
		GunMods = {
			NoRecoil = false,
			NoSpread = false,
			RapidFire = false,
		},
	},
	target_strafe = {
		enabled = false,
		keybind = "E",
		type = "Custom",
		pattern = "Normal",
		speed = 10,
		height = 10,
		distance = 10,
	},
	desync = {
		enabled = false,
		active = false,
		keybind = Enum.KeyCode.F,
		break_move_direction = false,
		min_x = -10,
		max_x = 10,
		min_y = -10,
		max_y = 10,
		min_z = -10,
		max_z = 10,
		min_rotation = 0,
		max_rotation = 360,
		max_velocity = math.huge,
	},
	fakepos = {
		enabled = false,
		active = false,
		keybind = Enum.KeyCode.H,
		offset_x = 0,
		offset_y = -6,
		offset_z = 0,
		rotation = 90,
		extreme_mode = false,
		anticlip = false,
	},
	spinbot = {
		enabled = false,
		speed = 50,
		mode = "Normal",
		x_enabled = true,
		y_enabled = true,
		z_enabled = true,
		server_only = false,
	},
	anti_fling = {
		enabled = false,
	},
	server_hrp_visualizer = {
		enabled = false,
		transparency = 0.5,
		color = Color3.fromRGB(255, 0, 0),
		delay_simulation = 0.1,
	},

	hitbox_expander = {
		enabled = false,
		visualize = false,
		width = 37,
		length = 37,
		color = Color3.fromRGB(155, 125, 175),
		outline_color = Color3.fromRGB(155, 125, 175),
		fill_transparency = 0.5,
		outline_transparency = 0.3,
		whitelist = {},
	},
	fonts = {
	},
	box = {
		enabled = false,
		type = "Full",
		filled = false,
		color = Color3.fromRGB(0, 150, 255),
		outline_color = Color3.fromRGB(0, 0, 0),
		transparency = 0.6,
		thickness = 1.5,
		gradient = {
			enabled = true,
			top_color = Color3.fromRGB(0, 9, 139),
			bottom_color = Color3.fromRGB(255, 255, 255),
			rotation = 90,
			rotation_speed = 9,
		},
	},
	fov = {
		enabled = false,
		radius = 150,
		color = Color3.fromRGB(0, 150, 255),
		outline_color = Color3.fromRGB(0, 0, 0),
		thickness = 1,
		transparency = 0.4,
        lines = 64,
        filled = false,
		options = {
			animegirls = {
				enabled = false,
				type = "1",
			},
			label = {
				enabled = false,
				followtype = "Smooth",
				color = Color3.fromRGB(255, 255, 255),
				outline_color = Color3.fromRGB(0, 0, 0),
				size = 14,
			}
		},
		gradient = {
			enabled = true,
			top_color = Color3.fromRGB(0, 9, 139),
			bottom_color = Color3.fromRGB(255, 255, 255),
			rotation = 90,
			rotation_speed = 9,
		},

	},
	skeleton = {
		enabled = false,
		color = Color3.fromRGB(255, 255, 255),
		thickness = 1.2,
		transparency = 0.15,
		outline = {
			enabled = false,
			color = Color3.fromRGB(0, 0, 0),
			thickness = 2.5,
		},
	},
	health_bar = {
		enabled = false,
		width = 1,
		text = {
			enabled = false,
			show_percent = false,
			show_numeric = false,
			color = Color3.fromRGB(255, 255, 255),
			outline_color = Color3.fromRGB(0, 0, 0),
			size = 12,
		},
		gradient = {
			enabled = true,
			top_color = Color3.fromRGB(0, 255, 0),
			bottom_color = Color3.fromRGB(255, 0, 0),
			rotation = 90,
		},
	},
	armor_bar = {
		enabled = false,
		width = 1,
		max_armor = 100,
		text = {
			enabled = false,
			show_percent = false,
			show_numeric = false,
			color = Color3.fromRGB(255, 255, 255),
			outline_color = Color3.fromRGB(0, 0, 0),
			size = 12,
		},
		gradient = {
			enabled = true,
			top_color = Color3.fromRGB(0, 100, 255),
			bottom_color = Color3.fromRGB(100, 150, 255),
			rotation = 90,
		},
	},
	labels = {
		name = {
			enabled = false,
			color = Color3.fromRGB(255, 255, 255),
			outline_color = Color3.fromRGB(0, 0, 0),
			size = 14,
		},
		distance = {
			enabled = false,
			color = Color3.fromRGB(200, 200, 200),
			outline_color = Color3.fromRGB(0, 0, 0),
			size = 12,
		},
		tool = {
			enabled = false,
			color = Color3.fromRGB(255, 255, 150),
			outline_color = Color3.fromRGB(0, 0, 0),
			size = 11,
		},
		display_name = {
			enabled = false,
			color = Color3.fromRGB(255, 255, 0),
			outline_color = Color3.fromRGB(0, 0, 0),
			size = 13,
		},
	},
	chams = { 
		enabled = false,
		fill_color = Color3.fromRGB(0, 150, 255),
		outline_color = Color3.fromRGB(255, 255, 255),
		fill_transparency = 0.5,
		outline_transparency = 0,
	},
	lighting = {
		enabled = false,
		brightness = 2,
		ambience = {
			enabled = false,
			ambient = Color3.fromRGB(128, 128, 128),
			outdoor_ambient_enabled = false,
			outdoor_ambient = Color3.fromRGB(128, 128, 128),
		},
		clocktime = {
			clock_time = 12,
			geographic_latitude = 41.88,
		},
		color_shift = {
			top = Color3.fromRGB(0, 0, 0),
			bottom = Color3.fromRGB(0, 0, 0),
		},
		fog = {
			color = Color3.fromRGB(191, 191, 191),
			start = 0,
			ending = 500,
		},
		environment = {
			diffuse_scale = 1,
			specular_scale = 1,
		},
		shadows = {
			global_shadows = false,
			softness = 0.2,
		},
		quality = {
			exposure_compensation = 0,
			prioritize_lighting_quality = false,
		},
	},
	self_aura = {
		enabled = false,
		type = {"Angel Wings"}
	},
	self_material = {
		enabled = false,
		color = Color3.fromRGB(0, 150, 255),
		type = "Neon",
	},
	self_toolmaterial = {
		enabled = false,
		color = Color3.fromRGB(0, 150, 255),
		type = "Neon",
	},
	hitsounds = {
		enabled = false,
		volume = 100,
		type = "Bubble"
	},
	hiteffects = {
		enabled = false,
		type = "Pulse",
		color = Color3.fromRGB(255, 255, 255)
	},
	bullet_tracers = {
		enabled = false,
		type = "Lazar",
		time = 1,
		thickness = 1,
		color = Color3.fromRGB(255, 255, 255),
		length = 100
	},
	cframe = {
		enabled = false,
		keybinds = "Q",
		type = "Movedirection",
		speed = 100
	},
	fly = {
		enabled = false,
		keybinds = "F",
		type = "Movedirection",
		speed = 50
	},
	hipheight = {
		enabled = false,
		keybinds = "H",
		height = 0
	},
	jumppower = {
		enabled = false,
		power = 50
	},
	gravity = {
		enabled = false,
		keybinds = "G",
		gravity = 196.2
	},
	automation = {
		anti_afk = {
			enabled = false
		},
		anti_stomp = {
			enabled = false
		},
		autofarm = {
			enabled = false,
			saver = false
		},
		auto_collect = {
			enabled = false,
			range = 17
		},
		autobuy = {
			selected_gun = "[Rifle]",
			buy_ammo = false,
			auto_loadout = false,
			auto_armor = false,
			buying_single = false
		},
		auto_reload = {
			enabled = false
		}
	},
	utility = {
		chat_spammer = {
			enabled = false,
			type = "Custom",
			message = "spam",
			delay = 1
		},
		viewmodel_changer = {
			enabled = false,
			x_offset = 0,
			y_offset = 0,
			z_offset = 0
		},
		fov_changer = {
			enabled = false,
			fov = 70
		},
		animation_player = {
			enabled = false,
			animation_id = "rbxassetid://14352343065",
			speed = 1
		},
		avatar_changer = {
			enabled = false,
			user_id = 244844600
		},
		skin_changer = {
			enabled = false,
			skin = "Valentines"
		}
	}
}

local hitsound_sounds = {
	["Bubble"] = "rbxassetid://6534947588",
	["Lazer"] = "rbxassetid://130791043",
	["Pick"] = "rbxassetid://1347140027",
	["Pop"] = "rbxassetid://198598793",
	["Rust"] = "rbxassetid://1255040462",
	["Sans"] = "rbxassetid://3188795283",
	["Fart"] = "rbxassetid://130833677",
	["Big"] = "rbxassetid://5332005053",
	["Vine"] = "rbxassetid://5332680810",
	["UwU"] = "rbxassetid://8679659744",
	["Bruh"] = "rbxassetid://4578740568",
	["Skeet"] = "rbxassetid://5633695679",
	["Neverlose"] = "rbxassetid://6534948092",
	["Fatality"] = "rbxassetid://6534947869",
	["Bonk"] = "rbxassetid://5766898159",
	["Minecraft"] = "rbxassetid://5869422451",
	["Gamesense"] = "rbxassetid://4817809188",
	["RIFK7"] = "rbxassetid://9102080552",
	["Bamboo"] = "rbxassetid://3769434519",
	["Crowbar"] = "rbxassetid://546410481",
	["Weeb"] = "rbxassetid://6442965016",
	["Beep"] = "rbxassetid://8177256015",
	["Bambi"] = "rbxassetid://8437203821",
	["Stone"] = "rbxassetid://3581383408",
	["Old Fatality"] = "rbxassetid://6607142036",
	["Click"] = "rbxassetid://8053704437",
	["Ding"] = "rbxassetid://7149516994",
	["Snow"] = "rbxassetid://6455527632",
	["Laser"] = "rbxassetid://7837461331",
	["Mario"] = "rbxassetid://2815207981",
	["Steve"] = "rbxassetid://4965083997",
	["Call of Duty"] = "rbxassetid://5952120301",
	["Bat"] = "rbxassetid://3333907347",
	["TF2 Critical"] = "rbxassetid://296102734",
	["Saber"] = "rbxassetid://8415678813",
	["Baimware"] = "rbxassetid://3124331820",
	["Osu"] = "rbxassetid://7149255551",
	["TF2"] = "rbxassetid://2868331684",
	["Slime"] = "rbxassetid://6916371803",
	["Among Us"] = "rbxassetid://5700183626",
	["One"] = "rbxassetid://7380502345"
}

local esp
do
	local self = {}
	esp = self
	
	local cloneref_func = cloneref or function(obj)
		return obj
	end
	self.vars = {
		game = cloneref_func(game),
        players = nil,
		rs = nil,
		gs = nil,
		uis = game:GetService("UserInputService"),
		http = nil,
		core_gui = nil,
		local_player = nil,
        camera = nil,
	}
	
		self.hitsound_cache = {
			player_health = {},
			player_armor = {},
			connections = {},
			hit_effects = {}
		}
	
	self.funcs = { 
		get_font = function(font_enum)
			if not font_enum then
				font_enum = Enum.Font.Gotham
			end
			if typeof(font_enum) == "EnumItem" then
				local success, font_obj = pcall(function()
					if Font.fromEnum then
						return Font.fromEnum(font_enum)
					end
					return nil
				end)
				if success and font_obj then
					return font_obj
				end
				local font_family = tostring(font_enum):gsub("Enum.Font.", "")
				local font_paths = {
					"rbxasset://fonts/families/" .. font_family .. ".json",
					"rbxasset://fonts/families/Gotham.json"
				}
				for _, path in ipairs(font_paths) do
					success, font_obj = pcall(function()
						return Font.new(path)
					end)
					if success and font_obj then
						return font_obj
					end
				end
			end
			return font_enum
		end,
		load_image_from_github = function(github_url)
			if not github_url then return nil end
			local raw_url = "https://github.com/cherrygelato2019/images/blob/main/Hand-drawn-Anime-girl-character-on-transparent-background-PNG.png"
			return raw_url
		end,
		create_image_label = function(parent, image_url, size, position)
			local image_label = Instance.new("ImageLabel")
			image_label.Parent = parent
			image_label.Size = size or UDim2.new(0, 50, 0, 50)
			image_label.Position = position or UDim2.new(0, 0, 0, 0)
			image_label.BackgroundTransparency = 1
			image_label.BorderSizePixel = 0
			
			if image_url then
				if image_url:match("https://github.com/cherrygelato2019/images/raw/blob/main/Hand-drawn-Anime-girl-character-on-transparent-background-PNG.png") then
					local raw_url = self.funcs.load_image_from_github(image_url)
					image_label.Image = raw_url
				else
					image_label.Image = image_url
				end
			end
			
			return image_label
		end, 
		to_screen = function(pos)
			local cam = self.vars.camera
			if not cam then return nil, false, 0 end
			local screen_point, on_screen = cam:WorldToViewportPoint(pos)
			if not screen_point then return nil, false, 0 end
			return Vector2.new(screen_point.X, screen_point.Y), on_screen, screen_point.Z
		end,
		calc_box = function(pos)
			local cam = self.vars.camera
			if not cam then return nil, nil, false, false end
			local cam_pos = cam.CFrame.Position
			
			local dist = (cam_pos - pos).Magnitude
			if dist < 0.1 or dist > 6000000000 then
				return nil, nil, false, false
			end
			
			local up_calculation = CFrame.new(pos)
			local v_top = pos + (up_calculation.UpVector * 1.8) + cam.CFrame.UpVector
			local v_bottom = pos - (up_calculation.UpVector * 2.5) - cam.CFrame.UpVector

			local top_screen, top_rendered, top_z = self.funcs.to_screen(v_top)
			local bottom_screen, bottom_rendered, bottom_z = self.funcs.to_screen(v_bottom)
			
			if not top_screen or not bottom_screen then
				return nil, nil, false, false
			end
			
			if top_z <= 0 or bottom_z <= 0 then
				return nil, nil, false, false
			end
			
			local width = math.max(math.floor(math.abs(top_screen.X - bottom_screen.X)), 3)
			local height = math.max(math.floor(math.max(math.abs(bottom_screen.Y - top_screen.Y), width / 2)), 3)
			local box_size = Vector2.new(math.floor(math.max(height / 1.5, width)), height)
			local box_pos = Vector2.new(math.floor(top_screen.X * 0.5 + bottom_screen.X * 0.5 - box_size.X * 0.5), math.floor(math.min(top_screen.Y, bottom_screen.Y)))

			return box_size, box_pos, bottom_rendered, top_rendered
		end,
		make_text = function(parent)
			local label = Instance.new("TextLabel")
			label.Parent = parent
			label.Size = UDim2.new(0, 200, 0, 20)
			label.BackgroundTransparency = 1
			label.TextColor3 = Color3.fromRGB(255, 255, 255)
			label.TextStrokeTransparency = 0
			label.TextScaled = false
			label.TextSize = 12
			label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
			local font_result = self.funcs.get_font(Stranded.fonts.labels)
			local success = pcall(function()
				label.FontFace = font_result
			end)
			if not success then
				label.Font = Stranded.fonts.labels or Enum.Font.Gotham
			end
			label.TextXAlignment = Enum.TextXAlignment.Center
			label.TextYAlignment = Enum.TextYAlignment.Center
			return label
		end,
		create_cache = function(player)
			if not player then return end
			if self.cache[player] then
				local existing = self.cache[player]
				if existing.box and existing.box.full and existing.box.full.square then
					return existing
				end
			end
			
			local cache = {}
			cache.box = {}
			cache.bars = {}
			cache.text = {}
			cache.chams = {}
			cache.last_pos = Vector3.new(0, 0, 0)
			cache.last_size = Vector2.new(0, 0)
			cache.gradient_rotation = (Stranded.box.gradient.rotation ~= nil and type(Stranded.box.gradient.rotation) == "number") and Stranded.box.gradient.rotation or 90
			cache.root = nil
			cache.humanoid = nil
			cache.parts = {}
			cache.skeleton_frame_skip = 0
			
			cache.box.full = {
				square = Drawing.new("Square"),
				outline = Drawing.new("Square"),
			}
			
			local box_gui = Instance.new("ScreenGui")
			box_gui.Name = player.Name .. "_BoxGui"
			box_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
			box_gui.Parent = self.vars.core_gui
			
			local box_frame = Instance.new("Frame")
			box_frame.BackgroundColor3 = Color3.new(1, 1, 1)
			box_frame.BackgroundTransparency = Stranded.box.transparency
			box_frame.BorderSizePixel = 0
			box_frame.Name = "BoxFrame"
			box_frame.Parent = box_gui
			
			local box_gradient = Instance.new("UIGradient")
			if Stranded.box.gradient.enabled then
				box_gradient.Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Stranded.box.gradient.top_color),
					ColorSequenceKeypoint.new(1, Stranded.box.gradient.bottom_color)
				})
				box_gradient.Rotation = Stranded.box.gradient.rotation
				box_gradient.Parent = box_frame
			end
			
			cache.box.full.gui = box_gui
			cache.box.full.frame = box_frame
			cache.box.full.gradient = box_gradient
			
			cache.skeleton = {}
			for i = 1, #self.skeleton_conns do
				cache.skeleton[i] = {
					line = Drawing.new("Line"),
					outline = Drawing.new("Line"),
				}
			end
			
			local studs_gui = Instance.new("ScreenGui")
			studs_gui.Parent = self.vars.core_gui
			studs_gui.Name = player.Name .. "_StudsGui"
			
			local name_gui = Instance.new("ScreenGui")
			name_gui.Parent = self.vars.core_gui
			name_gui.Name = player.Name .. "_NameGui"
			
			local tool_gui = Instance.new("ScreenGui")
			tool_gui.Parent = self.vars.core_gui
			tool_gui.Name = player.Name .. "_ToolGui"
			
			local display_name_gui = Instance.new("ScreenGui")
			display_name_gui.Parent = self.vars.core_gui
			display_name_gui.Name = player.Name .. "_DisplayNameGui"
			
			cache.text.studs = self.funcs.make_text(studs_gui)
			cache.text.tool = self.funcs.make_text(tool_gui)
			cache.text.name = self.funcs.make_text(name_gui)
			cache.text.display_name = self.funcs.make_text(display_name_gui)
			
			if cache.text.display_name then
				cache.text.display_name.TextColor3 = Stranded.labels.display_name.color
				cache.text.display_name.TextStrokeColor3 = Stranded.labels.display_name.outline_color
				cache.text.display_name.TextSize = Stranded.labels.display_name.size
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() cache.text.display_name.FontFace = font_result end)
			end
			
			if cache.text.name then
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() cache.text.name.FontFace = font_result end)
			end
			
			if cache.text.tool then
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() cache.text.tool.FontFace = font_result end)
			end
			
			if cache.text.studs then
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() cache.text.studs.FontFace = font_result end)
			end
			
			local health_gui = Instance.new("ScreenGui")
			health_gui.Name = player.Name .. "_HealthBar"
			health_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
			health_gui.Parent = self.vars.core_gui
			
			local health_outline = Instance.new("Frame")
			health_outline.BackgroundColor3 = Color3.new(0, 0, 0)
			health_outline.BorderSizePixel = 0
			health_outline.Name = "Outline"
			health_outline.Parent = health_gui
			
			local health_fill = Instance.new("Frame")
			health_fill.BackgroundColor3 = Color3.new(1, 1, 1)
			health_fill.BackgroundTransparency = 0
			health_fill.BorderSizePixel = 0
			health_fill.Name = "Fill"
			health_fill.Parent = health_outline
			
			local health_gradient = Instance.new("UIGradient")
			if Stranded.health_bar.gradient.enabled then
				health_gradient.Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Stranded.health_bar.gradient.top_color),
					ColorSequenceKeypoint.new(1, Stranded.health_bar.gradient.bottom_color)
				})
				health_gradient.Rotation = Stranded.health_bar.gradient.rotation
				health_gradient.Parent = health_fill
			else
				health_fill.BackgroundColor3 = Stranded.health_bar.gradient.top_color
			end
			
			local health_text = Instance.new("TextLabel")
			health_text.Name = "HealthText"
			health_text.BackgroundTransparency = 1
			health_text.TextColor3 = Color3.fromRGB(0, 100, 0)
			health_text.TextStrokeTransparency = 0
			health_text.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
			health_text.TextSize = 10
			local font_result = self.funcs.get_font(Stranded.fonts.labels)
			pcall(function() health_text.FontFace = font_result end)
			health_text.TextXAlignment = Enum.TextXAlignment.Center
			health_text.TextYAlignment = Enum.TextYAlignment.Center
			health_text.Parent = health_fill
			
			cache.bars.health = {
				gui = health_gui,
				outline = health_outline,
				frame = health_fill,
				text = health_text,
				last_health = 1
			}
			
			local armor_gui = Instance.new("ScreenGui")
			armor_gui.Name = player.Name .. "_ArmorBar"
			armor_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
			armor_gui.Parent = self.vars.core_gui
			
			local armor_outline = Instance.new("Frame")
			armor_outline.BackgroundColor3 = Color3.new(0, 0, 0)
			armor_outline.BorderSizePixel = 0
			armor_outline.Name = "Outline"
			armor_outline.Parent = armor_gui
			
			local armor_fill = Instance.new("Frame")
			armor_fill.BackgroundColor3 = Color3.new(1, 1, 1)
			armor_fill.BackgroundTransparency = 0
			armor_fill.BorderSizePixel = 0
			armor_fill.Name = "Fill"
			armor_fill.Parent = armor_outline
			
			local armor_gradient = Instance.new("UIGradient")
			if Stranded.armor_bar.gradient.enabled then
				armor_gradient.Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Stranded.armor_bar.gradient.top_color),
					ColorSequenceKeypoint.new(1, Stranded.armor_bar.gradient.bottom_color)
				})
				armor_gradient.Rotation = Stranded.armor_bar.gradient.rotation
				armor_gradient.Parent = armor_fill
			else
				armor_fill.BackgroundColor3 = Stranded.armor_bar.gradient.top_color
			end
			
			local armor_text = Instance.new("TextLabel")
			armor_text.Name = "ArmorText"
			armor_text.BackgroundTransparency = 1
			armor_text.TextColor3 = Color3.fromRGB(0, 100, 255)
			armor_text.TextStrokeTransparency = 0
			armor_text.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
			armor_text.TextSize = 10
			local font_result = self.funcs.get_font(Stranded.fonts.labels)
			pcall(function() armor_text.FontFace = font_result end)
			armor_text.TextXAlignment = Enum.TextXAlignment.Center
			armor_text.TextYAlignment = Enum.TextYAlignment.Center
			armor_text.Parent = armor_fill
			
			cache.bars.armor = {
				gui = armor_gui,
				outline = armor_outline,
				frame = armor_fill,
				text = armor_text,
				last_armor = 0
			}

			self.cache[player] = cache
			self.cache_manager:set_data(player, cache)
		end,
		update_chams = function(player, cache, char)
			if not char then
				if cache.chams and cache.chams.highlight then
					cache.chams.highlight.Enabled = false
				end
				return
			end
			
			if not Stranded.visuals_enabled or not Stranded.chams.enabled then
				if cache.chams and cache.chams.highlight then
					cache.chams.highlight.Enabled = false
				end
				return
			end
			
			if not cache.chams.highlight then
				local highlight = Instance.new("Highlight")
				highlight.FillColor = Stranded.chams.fill_color
				highlight.OutlineColor = Stranded.chams.outline_color
				highlight.FillTransparency = Stranded.chams.fill_transparency
				highlight.OutlineTransparency = Stranded.chams.outline_transparency
				highlight.Adornee = char
				highlight.Parent = char
				cache.chams.highlight = highlight
			else
				local highlight = cache.chams.highlight
				if highlight then
					highlight.FillColor = Stranded.chams.fill_color
					highlight.OutlineColor = Stranded.chams.outline_color
					highlight.FillTransparency = Stranded.chams.fill_transparency
					highlight.OutlineTransparency = Stranded.chams.outline_transparency
					highlight.Enabled = true
					if highlight.Adornee ~= char then
						highlight.Adornee = char
					end
					if highlight.Parent ~= char then
						highlight.Parent = char
					end
				end
			end
		end,
		render = function(player)
			if not player then return end
			self.funcs.create_cache(player)
		end,
		clear = function(player)
			local cache = self.cache[player]
			if not cache then return end
			
			if cache.box and cache.box.full then
				cache.box.full.square.Visible = false
				cache.box.full.outline.Visible = false
				if cache.box.full.frame then
					cache.box.full.frame.Visible = false
				end
				if cache.box.full.gui then
					cache.box.full.gui:Destroy()
        end
    end
    
			if cache.skeleton then
				for _, v in pairs(cache.skeleton) do
					if v.line then v.line.Visible = false end
					if v.outline then v.outline.Visible = false end
        end
    end
    
			if cache.text then
				for _, v in pairs(cache.text) do
					if v then v.Visible = false end
        end
    end
    
			if cache.bars then
				for _, bar in pairs(cache.bars) do
					if bar and bar.frame then
						bar.frame.Visible = false
						bar.outline.Visible = false
						if bar.text then bar.text.Visible = false end
            end
        end
    end

			if cache.chams and cache.chams.highlight then
				cache.chams.highlight:Destroy()
				cache.chams.highlight = nil
			end

			self.cache_manager:remove(player)
		end,
		update_box = function(player, pos, size, cache)
			local full = cache.box and cache.box.full
			if not full then return end
			
			local square, outline = full.square, full.outline
			local frame = full.frame
			local gradient = full.gradient
			
			if not Stranded.visuals_enabled or not Stranded.box.enabled then
				if square then square.Visible = false end
				if outline then outline.Visible = false end
				if frame then frame.Visible = false end
				return
			end
			
			if Stranded.box.type == "Full" then
				outline.Visible = true
				outline.Position = pos - Vector2.new(1, 1)
				outline.Size = size + Vector2.new(2, 2)
				outline.Color = Stranded.box.outline_color
				outline.Thickness = 1
				outline.Filled = false
				outline.ZIndex = 2
				
				if Stranded.box.filled and frame and gradient then
					frame.Visible = true
					frame.Position = UDim2.new(0, pos.X, 0, pos.Y - self.gui_inset.Y)
					frame.Size = UDim2.new(0, size.X, 0, size.Y)
					frame.BackgroundTransparency = Stranded.box.transparency
					
					if Stranded.box.gradient.enabled then
						local rotation_speed = Stranded.box.gradient.rotation_speed or 0
						local base_rotation = (Stranded.box.gradient.rotation ~= nil) and Stranded.box.gradient.rotation or 90
						
						if not cache.gradient_rotation then
							cache.gradient_rotation = base_rotation
						end
						
						if rotation_speed ~= 0 then
							cache.gradient_rotation = cache.gradient_rotation + rotation_speed
							if cache.gradient_rotation >= 360 then
								cache.gradient_rotation = cache.gradient_rotation - 360
							elseif cache.gradient_rotation < 0 then
								cache.gradient_rotation = cache.gradient_rotation + 360
							end
						else
							cache.gradient_rotation = base_rotation
						end
						
						gradient.Color = ColorSequence.new({
							ColorSequenceKeypoint.new(0, Stranded.box.gradient.top_color),
							ColorSequenceKeypoint.new(1, Stranded.box.gradient.bottom_color)
						})
						gradient.Rotation = cache.gradient_rotation
						if not gradient.Parent then
							gradient.Parent = frame
						end
					else
						if gradient.Parent then
							gradient.Parent = nil
						end
						frame.BackgroundColor3 = Stranded.box.color
					end
					
					square.Visible = false
				else
					square.Visible = true
					square.Position = pos
					square.Size = size
					square.Color = Stranded.box.color
					square.Thickness = Stranded.box.filled and 0 or Stranded.box.thickness
					square.Filled = Stranded.box.filled
					square.Transparency = Stranded.box.transparency
					square.ZIndex = 3
					
					if frame then frame.Visible = false end
            end
        end
		end,
		update_labels = function(player, pos, size, cache, char, cam, root)
			if not Stranded.visuals_enabled then
				if cache.text and cache.text.name then cache.text.name.Visible = false end
				if cache.text and cache.text.display_name then cache.text.display_name.Visible = false end
				if cache.text and cache.text.tool then cache.text.tool.Visible = false end
				if cache.text and cache.text.studs then cache.text.studs.Visible = false end
				return
			end
			
			local name_label = cache.text.name
			local tool_label = cache.text.tool
			local studs_label = cache.text.studs
			local display_name_label = cache.text.display_name

			local gui_inset = self.gui_inset or Vector2.new(0, 0)
			local base_x = pos.X + (size.X / 2)
			local base_y = pos.Y
			local current_y = base_y - 20

			local name_enabled = Stranded.labels.name.enabled
			local display_name_enabled = Stranded.labels.display_name.enabled

			if name_enabled and display_name_enabled then
				name_label.Visible = true
				display_name_label.Visible = false
				name_label.Text = player.Name .. "\\" .. (player.DisplayName or player.Name)
				name_label.TextColor3 = Stranded.labels.name.color
				name_label.TextStrokeColor3 = Stranded.labels.name.outline_color
				name_label.TextSize = Stranded.labels.name.size
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() name_label.FontFace = font_result end)
				name_label.Size = UDim2.new(0, 0, 0, 20)
				name_label.TextXAlignment = Enum.TextXAlignment.Center
				local text_width = name_label.TextBounds.X
				name_label.Size = UDim2.new(0, text_width, 0, 20)
				name_label.Position = UDim2.new(0, base_x - (text_width / 2), 0, current_y - gui_inset.Y)
				current_y = current_y - 22
			elseif name_enabled then
				name_label.Visible = true
				display_name_label.Visible = false
				name_label.Text = player.Name
				name_label.TextColor3 = Stranded.labels.name.color
				name_label.TextStrokeColor3 = Stranded.labels.name.outline_color
				name_label.TextSize = Stranded.labels.name.size
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() name_label.FontFace = font_result end)
				name_label.Size = UDim2.new(0, 0, 0, 20)
				name_label.TextXAlignment = Enum.TextXAlignment.Center
				local text_width = name_label.TextBounds.X
				name_label.Size = UDim2.new(0, text_width, 0, 20)
				name_label.Position = UDim2.new(0, base_x - (text_width / 2), 0, current_y - gui_inset.Y)
				current_y = current_y - 22
			elseif display_name_enabled then
				name_label.Visible = false
				display_name_label.Visible = true
				display_name_label.Text = player.DisplayName or player.Name
				display_name_label.TextColor3 = Stranded.labels.display_name.color
				display_name_label.TextStrokeColor3 = Stranded.labels.display_name.outline_color
				display_name_label.TextSize = Stranded.labels.display_name.size
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() display_name_label.FontFace = font_result end)
				display_name_label.Size = UDim2.new(0, 0, 0, 20)
				display_name_label.TextXAlignment = Enum.TextXAlignment.Center
				local text_width = display_name_label.TextBounds.X
				display_name_label.Size = UDim2.new(0, text_width, 0, 20)
				display_name_label.Position = UDim2.new(0, base_x - (text_width / 2), 0, current_y - gui_inset.Y)
				current_y = current_y - 22
			else
				name_label.Visible = false
				display_name_label.Visible = false
			end

			local bottom_y = base_y + size.Y + 2

			if Stranded.labels.distance.enabled then
				studs_label.Visible = true
				local dist = (cam.CFrame.Position - root.Position).Magnitude
				local meters = dist * 0.28
				studs_label.Text = string.format("[%.0fm]", meters)
				studs_label.TextColor3 = Stranded.labels.distance.color
				studs_label.TextStrokeColor3 = Stranded.labels.distance.outline_color
				studs_label.TextSize = Stranded.labels.distance.size
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
				pcall(function() studs_label.FontFace = font_result end)
				studs_label.Size = UDim2.new(0, 0, 0, 20)
				studs_label.TextXAlignment = Enum.TextXAlignment.Center
				local text_width = studs_label.TextBounds.X
				local text_height = studs_label.TextBounds.Y
				studs_label.Size = UDim2.new(0, text_width, 0, text_height)
				studs_label.Position = UDim2.new(0, base_x - (text_width / 2), 0, bottom_y - gui_inset.Y)
				
				if Stranded.labels.tool.enabled then
					tool_label.Visible = true
					local tool = char:FindFirstChildOfClass("Tool")
					tool_label.Text = tool and tool.Name or "none"
					tool_label.TextColor3 = Stranded.labels.tool.color
					tool_label.TextStrokeColor3 = Stranded.labels.tool.outline_color
					tool_label.TextSize = Stranded.labels.tool.size
					local font_result = self.funcs.get_font(Stranded.fonts.labels)
					pcall(function() tool_label.FontFace = font_result end)
					tool_label.Size = UDim2.new(0, 0, 0, 20)
					tool_label.TextXAlignment = Enum.TextXAlignment.Center
					local tool_text_width = tool_label.TextBounds.X
					local tool_text_height = tool_label.TextBounds.Y
					tool_label.Size = UDim2.new(0, tool_text_width, 0, tool_text_height)
					tool_label.Position = UDim2.new(0, base_x - (tool_text_width / 2), 0, bottom_y + text_height + 1 - gui_inset.Y)
				else
					tool_label.Visible = false
				end
			else
				studs_label.Visible = false
				if Stranded.labels.tool.enabled then
					tool_label.Visible = true
					local tool = char:FindFirstChildOfClass("Tool")
					tool_label.Text = tool and tool.Name or "none"
					tool_label.TextColor3 = Stranded.labels.tool.color
					tool_label.TextStrokeColor3 = Stranded.labels.tool.outline_color
					tool_label.TextSize = Stranded.labels.tool.size
					local font_result = self.funcs.get_font(Stranded.fonts.labels)
					pcall(function() tool_label.FontFace = font_result end)
					tool_label.Size = UDim2.new(0, 0, 0, 20)
					tool_label.TextXAlignment = Enum.TextXAlignment.Center
					local tool_text_width = tool_label.TextBounds.X
					local tool_text_height = tool_label.TextBounds.Y
					tool_label.Size = UDim2.new(0, tool_text_width, 0, tool_text_height)
					tool_label.Position = UDim2.new(0, base_x - (tool_text_width / 2), 0, bottom_y - gui_inset.Y)
				else
					tool_label.Visible = false
				end
			end
		end,
		cache_character_parts = function(char, cache)
			if not cache.parts then
				cache.parts = {}
			else
				for k in pairs(cache.parts) do
					cache.parts[k] = nil
				end
			end
			
			local part_names = {}
			for _, connection in ipairs(self.skeleton_conns) do
				part_names[connection.from] = true
				part_names[connection.to] = true
			end
			
			local missing_parts = {}
			for name in pairs(part_names) do
				local obj = char:FindFirstChild(name)
				if obj and obj:IsA("BasePart") then
					cache.parts[name] = obj
				elseif obj and obj:IsA("Accessory") then
					local handle = obj:FindFirstChild("Handle")
					if handle then
						cache.parts[name] = handle
					else
						missing_parts[name] = true
					end
				else
					missing_parts[name] = true
				end
			end
			
			if next(missing_parts) then
				local descendants = char:GetDescendants()
				for _, descendant in ipairs(descendants) do
					if descendant:IsA("BasePart") and missing_parts[descendant.Name] then
						cache.parts[descendant.Name] = descendant
						missing_parts[descendant.Name] = nil
						if not next(missing_parts) then
							break
						end
					end
				end
			end
		end,
		get_part_from_name = function(char, name, cache)
			if cache and cache.parts then
				return cache.parts[name]
			end
			return nil
		end,
		update_skeleton = function(player, cache, char)
			if not Stranded.visuals_enabled or not Stranded.skeleton.enabled then
				if cache.skeleton then
					for _, skeleton_data in pairs(cache.skeleton) do
						if skeleton_data.line then skeleton_data.line.Visible = false end
						if skeleton_data.outline then skeleton_data.outline.Visible = false end
					end
				end
				return
			end
			
			if not cache.parts then
				return
			end
			
			cache.skeleton_frame_skip = (cache.skeleton_frame_skip or 0) + 1
			if cache.skeleton_frame_skip % 2 ~= 0 then
				return
			end
			
			local humanoid = cache.humanoid
			if not humanoid or humanoid.Health <= 0 then
				for _, skeleton_data in pairs(cache.skeleton) do
					if skeleton_data.line then
						skeleton_data.line.Visible = false
					end
					if skeleton_data.outline then
						skeleton_data.outline.Visible = false
					end
				end
				return
			end
			
			for connection_index, connection in ipairs(self.skeleton_conns) do
				local skeleton_data = cache.skeleton[connection_index]
				if skeleton_data and skeleton_data.line then
					local from_part = cache.parts[connection.from]
					local to_part = cache.parts[connection.to]
					
					if from_part and to_part and from_part.Parent and to_part.Parent then
						local from_pos, from_on_screen = self.funcs.to_screen(from_part.Position)
						local to_pos, to_on_screen = self.funcs.to_screen(to_part.Position)
						
						if from_pos and to_pos and from_on_screen and to_on_screen then
							local line = skeleton_data.line
							local outline = skeleton_data.outline
							
							if line then
								line.Visible = true
								line.From = from_pos
								line.To = to_pos
								line.Color = Stranded.skeleton.color
								line.Thickness = Stranded.skeleton.thickness
								line.Transparency = Stranded.skeleton.transparency or 0
								line.ZIndex = 5
							end
							
							if Stranded.skeleton.outline.enabled and outline then
								outline.Visible = true
								outline.From = from_pos
								outline.To = to_pos
								outline.Color = Stranded.skeleton.outline.color
								outline.Thickness = Stranded.skeleton.outline.thickness
								outline.Transparency = 0
								outline.ZIndex = 4
							elseif outline then
								outline.Visible = false
							end
						else
							if skeleton_data.line then
								skeleton_data.line.Visible = false
							end
							if skeleton_data.outline then
								skeleton_data.outline.Visible = false
							end
						end
					else
						if skeleton_data.line then
							skeleton_data.line.Visible = false
						end
						if skeleton_data.outline then
							skeleton_data.outline.Visible = false
						end
					end
				end
			end
		end,
		update_health = function(player, pos, size, cache, humanoid)
			if not Stranded.visuals_enabled or not Stranded.health_bar.enabled then
				if cache.bars and cache.bars.health then
					local health = cache.bars.health
					if health.outline then health.outline.Visible = false end
					if health.frame then health.frame.Visible = false end
					if health.text then health.text.Visible = false end
				end
				return
			end
			
			if not humanoid then return end
			
			local target = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
			local last = cache.bars.health.last_health or target
			local lerped = last + (target - last) * 0.05
			cache.bars.health.last_health = lerped
			
			local bar_h = size.Y
			local bar_w = Stranded.health_bar.width
			local base_x = pos.X
			local y = pos.Y - self.gui_inset.Y
			
			local outline = cache.bars.health.outline
			local fill = cache.bars.health.frame
			local text = cache.bars.health.text
			
			if outline and fill then
				local x = base_x - (bar_w + 3)
				
				outline.Visible = true
				outline.Position = UDim2.new(0, x - 1, 0, y - 1)
				outline.Size = UDim2.new(0, bar_w + 2, 0, bar_h + 2)
				
				fill.Visible = true
				fill.Position = UDim2.new(0, 1, 0, (1 - lerped) * bar_h + 1)
				fill.Size = UDim2.new(0, bar_w, 0, lerped * bar_h)
				
				if text then
					if Stranded.health_bar.text.enabled then
						local percent = math.floor(target * 100)
						if Stranded.health_bar.text.show_percent then
							text.Text = percent .. "%"
						elseif Stranded.health_bar.text.show_numeric then
							text.Text = tostring(math.floor(humanoid.Health)) .. "/" .. tostring(math.floor(humanoid.MaxHealth))
						else
							text.Text = percent .. "%"
						end
						text.Visible = true
						text.Position = UDim2.new(0, -15, 0, 0)
						text.Size = UDim2.new(1, 0, 0, 12)
						text.TextColor3 = Stranded.health_bar.text.color
						text.TextStrokeColor3 = Stranded.health_bar.text.outline_color
						text.TextSize = Stranded.health_bar.text.size
					else
						text.Visible = false
					end
				end
			end
		end,
		update_armor = function(player, pos, size, cache, char)
			if not Stranded.visuals_enabled or not Stranded.armor_bar.enabled then
				if cache.bars and cache.bars.armor then
					local armor = cache.bars.armor
					if armor.outline then armor.outline.Visible = false end
					if armor.frame then armor.frame.Visible = false end
					if armor.text then armor.text.Visible = false end
				end
				return
			end
			
			if not char then return end
			
			local body_effects = char:FindFirstChild("BodyEffects")
			local armor_value = body_effects and body_effects:FindFirstChild("Armor")
			if not armor_value then
				if cache.bars.armor then
					if cache.bars.armor.outline then cache.bars.armor.outline.Visible = false end
					if cache.bars.armor.frame then cache.bars.armor.frame.Visible = false end
					if cache.bars.armor.text then cache.bars.armor.text.Visible = false end
				end
				return
			end
			
			local armor = armor_value.Value or 0
			local max_armor = Stranded.armor_bar.max_armor
			local target = math.clamp(armor / max_armor, 0, 1)
			local last = cache.bars.armor.last_armor or target
			local lerped = last + (target - last) * 0.05
			cache.bars.armor.last_armor = lerped
			
			local bar_h = Stranded.armor_bar.width
			local bar_w = size.X
			local base_x = pos.X
			local base_y = pos.Y - self.gui_inset.Y
			local y = base_y + size.Y + 3
			
			local outline = cache.bars.armor.outline
			local fill = cache.bars.armor.frame
			local text = cache.bars.armor.text
			
			if outline and fill then
				local x = base_x
				
				outline.Visible = true
				outline.Position = UDim2.new(0, x - 1, 0, y - 1)
				outline.Size = UDim2.new(0, bar_w + 2, 0, bar_h + 2)
				
				fill.Visible = true
				fill.Position = UDim2.new(0, 1, 0, 1)
				fill.Size = UDim2.new(0, lerped * bar_w, 0, bar_h)
				
				if text then
					if Stranded.armor_bar.text.enabled then
						local percent = math.floor(target * 100)
						if Stranded.armor_bar.text.show_percent then
							text.Text = percent .. "%"
						elseif Stranded.armor_bar.text.show_numeric then
							text.Text = tostring(math.floor(armor)) .. "/" .. tostring(max_armor)
						else
							text.Text = percent .. "%"
						end
						text.Visible = true
						text.Position = UDim2.new(0, -8, 0, 0)
						text.Size = UDim2.new(1, 0, 1, 0)
						text.TextXAlignment = Enum.TextXAlignment.Left
						text.TextYAlignment = Enum.TextYAlignment.Center
						text.TextColor3 = Stranded.armor_bar.text.color
						text.TextStrokeColor3 = Stranded.armor_bar.text.outline_color
						text.TextSize = Stranded.armor_bar.text.size
					else
						text.Visible = false
					end
				end
			end
		end,
		hide_all = function(cache)
			local box_full = cache.box and cache.box.full
			if box_full then
				if box_full.square then box_full.square.Visible = false end
				if box_full.outline then box_full.outline.Visible = false end
				if box_full.frame then box_full.frame.Visible = false end
			end
			local health = cache.bars and cache.bars.health
			if health then
				if health.outline then health.outline.Visible = false end
				if health.frame then health.frame.Visible = false end
				if health.text then health.text.Visible = false end
			end
			local armor = cache.bars and cache.bars.armor
			if armor then
				if armor.outline then armor.outline.Visible = false end
				if armor.frame then armor.frame.Visible = false end
				if armor.text then armor.text.Visible = false end
			end
			if cache.text then
				for _, v in pairs(cache.text) do
					if v then v.Visible = false end
				end
			end
			if cache.skeleton then
				for _, v in pairs(cache.skeleton) do
					if v.line then v.line.Visible = false end
					if v.outline then v.outline.Visible = false end
				end
			end
		end,
		update_fov = function()
			if not Stranded.fov or not Stranded.fov.enabled then return end
			
			if not self.fov_cache then
				self.fov_cache = {
					circle = Drawing.new("Circle"),
					outline = Drawing.new("Circle"),
					gui = nil,
					frame = nil,
					gradient = nil,
					gradient_rotation = (Stranded.fov.gradient and Stranded.fov.gradient.rotation) or 90,
					label = nil,
					label_gui = nil,
					label_pos = Vector2.new(0, 0),
				}
			end
			
			if Stranded.fov.options.label.enabled and not self.fov_cache.label then
				local label_gui = Instance.new("ScreenGui")
				label_gui.Name = "FOVLabelGui"
				label_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
				label_gui.Parent = self.vars.core_gui
				
				local label = Instance.new("TextLabel")
				label.Name = "FOVLabel"
				label.Parent = label_gui
				label.BackgroundTransparency = 1
				label.Text = "Stranded . lol"
				label.TextColor3 = Stranded.fov.options.label.color
				label.TextStrokeTransparency = 0
				label.TextStrokeColor3 = Stranded.fov.options.label.outline_color
				label.TextSize = Stranded.fov.options.label.size
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
			local success = pcall(function()
				label.FontFace = font_result
			end)
			if not success then
				label.Font = Stranded.fonts.labels or Enum.Font.Gotham
			end
				label.TextXAlignment = Enum.TextXAlignment.Center
				label.TextYAlignment = Enum.TextYAlignment.Center
				label.Size = UDim2.new(0, 0, 0, 20)
				
				self.fov_cache.label = label
				self.fov_cache.label_gui = label_gui
			elseif not Stranded.fov.options.label.enabled and self.fov_cache.label then
				if self.fov_cache.label_gui then
					self.fov_cache.label_gui:Destroy()
				end
				self.fov_cache.label = nil
				self.fov_cache.label_gui = nil
			end
			
			if Stranded.fov.filled and not self.fov_cache.frame then
				local fov_gui = Instance.new("ScreenGui")
				fov_gui.Name = "FOVGui"
				fov_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
				fov_gui.Parent = self.vars.core_gui
				
				local fov_frame = Instance.new("Frame")
				fov_frame.BackgroundColor3 = Color3.new(1, 1, 1)
				fov_frame.BackgroundTransparency = Stranded.fov.transparency
				fov_frame.BorderSizePixel = 0
				fov_frame.Name = "FOVFrame"
				fov_frame.Parent = fov_gui
				
				local fov_corner = Instance.new("UICorner")
				fov_corner.CornerRadius = UDim.new(1, 0)
				fov_corner.Parent = fov_frame
				
				local fov_gradient = Instance.new("UIGradient")
				if Stranded.fov.gradient.enabled then
					fov_gradient.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, Stranded.fov.gradient.top_color),
						ColorSequenceKeypoint.new(1, Stranded.fov.gradient.bottom_color)
					})
					fov_gradient.Rotation = Stranded.fov.gradient.rotation
					fov_gradient.Parent = fov_frame
				end
				
				self.fov_cache.gui = fov_gui
				self.fov_cache.frame = fov_frame
				self.fov_cache.gradient = fov_gradient
			elseif not Stranded.fov.filled and self.fov_cache.frame then
				if self.fov_cache.gui then
					self.fov_cache.gui:Destroy()
				end
				self.fov_cache.gui = nil
				self.fov_cache.frame = nil
				self.fov_cache.gradient = nil
			end
			
			local circle = self.fov_cache.circle
			local outline = self.fov_cache.outline
			local mouse = self.vars.uis:GetMouseLocation()
			local radius = Stranded.fov.radius
			local mouse_pos = Vector2.new(mouse.X, mouse.Y)
			
			if Stranded.fov.filled and self.fov_cache.frame then
				local frame = self.fov_cache.frame
				local gradient = self.fov_cache.gradient
				local gui_inset = self.gui_inset or Vector2.new(0, 0)
				
				frame.Visible = true
				frame.Position = UDim2.new(0, mouse_pos.X - radius, 0, mouse_pos.Y - radius - gui_inset.Y)
				frame.Size = UDim2.new(0, radius * 2, 0, radius * 2)
				frame.BackgroundTransparency = Stranded.fov.transparency
				
				if Stranded.fov.gradient.enabled and gradient then
					local rotation_speed = Stranded.fov.gradient.rotation_speed or 0
					local base_rotation = (Stranded.fov.gradient.rotation ~= nil) and Stranded.fov.gradient.rotation or 90
					
					if not self.fov_cache.gradient_rotation then
						self.fov_cache.gradient_rotation = base_rotation
					end
					
					if rotation_speed ~= 0 then
						self.fov_cache.gradient_rotation = self.fov_cache.gradient_rotation + rotation_speed
						if self.fov_cache.gradient_rotation >= 360 then
							self.fov_cache.gradient_rotation = self.fov_cache.gradient_rotation - 360
						elseif self.fov_cache.gradient_rotation < 0 then
							self.fov_cache.gradient_rotation = self.fov_cache.gradient_rotation + 360
						end
					else
						self.fov_cache.gradient_rotation = base_rotation
					end
					
					gradient.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, Stranded.fov.gradient.top_color),
						ColorSequenceKeypoint.new(1, Stranded.fov.gradient.bottom_color)
					})
					gradient.Rotation = self.fov_cache.gradient_rotation
					if not gradient.Parent then
						gradient.Parent = frame
					end
				else
					if gradient and gradient.Parent then
						gradient.Parent = nil
					end
				end
				
				circle.Visible = false
				outline.Visible = false
			else
				if self.fov_cache.frame then
					self.fov_cache.frame.Visible = false
				end
				
				circle.Position = mouse_pos
				circle.Radius = radius
				circle.Thickness = Stranded.fov.filled and 0 or Stranded.fov.thickness
				circle.Filled = Stranded.fov.filled
				circle.Visible = true
			end
			
			outline.Position = mouse_pos
			outline.Radius = radius
			outline.Visible = true
			
			if Stranded.fov.options.label.enabled and self.fov_cache.label then
				local label = self.fov_cache.label
				local gui_inset = self.gui_inset or Vector2.new(0, 0)
				local target_pos = Vector2.new(mouse_pos.X, mouse_pos.Y + 15)
				
				label.TextColor3 = Stranded.fov.options.label.color
				label.TextStrokeColor3 = Stranded.fov.options.label.outline_color
				label.TextSize = Stranded.fov.options.label.size
				local font_result = self.funcs.get_font(Stranded.fonts.labels)
			local success = pcall(function()
				label.FontFace = font_result
			end)
			if not success then
				label.Font = Stranded.fonts.labels or Enum.Font.Gotham
			end
				
				label.Size = UDim2.new(0, 0, 0, 20)
				local text_width = label.TextBounds.X
				label.Size = UDim2.new(0, text_width, 0, 20)
				
				if not self.fov_cache.label_pos then
					self.fov_cache.label_pos = target_pos
				end
				
				if Stranded.fov.options.label.followtype == "Smooth" then
					local current_pos = self.fov_cache.label_pos or target_pos
					local lerp_speed = 0.15
					self.fov_cache.label_pos = current_pos + (target_pos - current_pos) * lerp_speed
					label.Position = UDim2.new(0, self.fov_cache.label_pos.X - (text_width / 2), 0, self.fov_cache.label_pos.Y - gui_inset.Y)
				else
					self.fov_cache.label_pos = target_pos
					label.Position = UDim2.new(0, target_pos.X - (text_width / 2), 0, target_pos.Y - gui_inset.Y)
				end
				
				label.Visible = true
			elseif self.fov_cache and self.fov_cache.label then
				self.fov_cache.label.Visible = false
			end
		end,
		update_animegirls = function()
			if not Stranded.fov.options.animegirls.enabled then return end
			
			if not self.animegirls_cache then
				local anime_gui = Instance.new("ScreenGui")
				anime_gui.Name = "AnimeGirlsGui"
				anime_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
				anime_gui.Parent = self.vars.core_gui
				
				local anime_label = Instance.new("ImageLabel")
				anime_label.Name = "AnimeGirl"
				anime_label.Size = UDim2.new(0, 100, 0, 100)
				anime_label.Position = UDim2.new(0, 0, 0, 0)
				anime_label.BackgroundTransparency = 1
				anime_label.BorderSizePixel = 0
				anime_label.Parent = anime_gui
				
				local github_url = "https://github.com/cherrygelato2019/images/blob/main/Hand-drawn-Anime-girl-character-on-transparent-background-PNG.png"
				local raw_url = self.funcs.load_image_from_github(github_url)
				anime_label.Image = raw_url
				
				self.animegirls_cache = {
					gui = anime_gui,
					label = anime_label,
				}
			end
			
			local mouse = self.vars.uis:GetMouseLocation()
			local label = self.animegirls_cache.label
			
			label.Position = UDim2.new(0, mouse.X - 50, 0, mouse.Y - 50)
			label.Visible = true
		end,
		fix_corrupted_fog_values = function()
			if not Stranded.lighting then
				Stranded.lighting = {}
			end
			if not Stranded.lighting.fog then
				Stranded.lighting.fog = {}
			end
			if not Stranded.lighting.ambience then
				Stranded.lighting.ambience = {}
			end
			if Stranded.lighting.ambience.enabled == nil then
				Stranded.lighting.ambience.enabled = false
			end
			if Stranded.lighting.ambience.outdoor_ambient_enabled == nil then
				Stranded.lighting.ambience.outdoor_ambient_enabled = false
			end
			local fog_start = Stranded.lighting.fog.start
			if type(fog_start) ~= "number" or fog_start ~= fog_start then
				Stranded.lighting.fog.start = 0
			end
			local fog_ending = Stranded.lighting.fog.ending
			if type(fog_ending) ~= "number" or fog_ending ~= fog_ending then
				Stranded.lighting.fog.ending = 500
			end
		end,
		update_lighting = function()
			local lighting_service = self.vars.game:GetService("Lighting")
			if not lighting_service then return end
			
			self.funcs.fix_corrupted_fog_values()
			
			if not Stranded.lighting or not Stranded.lighting.enabled then return end
			
			local lighting_config = Stranded.lighting
			
			if lighting_config.brightness ~= nil then
				lighting_service.Brightness = lighting_config.brightness
			end
			
			if lighting_config.ambience and lighting_config.ambience.enabled and lighting_config.ambience.ambient then
				lighting_service.Ambient = lighting_config.ambience.ambient
			end
			
			if lighting_config.ambience and lighting_config.ambience.outdoor_ambient_enabled and lighting_config.ambience.outdoor_ambient then
				lighting_service.OutdoorAmbient = lighting_config.ambience.outdoor_ambient
			end
			
			if lighting_config.clocktime and lighting_config.clocktime.clock_time ~= nil then
				lighting_service.ClockTime = lighting_config.clocktime.clock_time
			end
			
			if lighting_config.clocktime and lighting_config.clocktime.geographic_latitude ~= nil then
				lighting_service.GeographicLatitude = lighting_config.clocktime.geographic_latitude
			end
			
			if lighting_config.color_shift and lighting_config.color_shift.enabled and lighting_config.color_shift.top then
				lighting_service.ColorShift_Top = lighting_config.color_shift.top
			end
			
			if lighting_config.color_shift and lighting_config.color_shift.enabled and lighting_config.color_shift.bottom then
				lighting_service.ColorShift_Bottom = lighting_config.color_shift.bottom
			end
			
			if lighting_config.fog and lighting_config.fog.enabled and lighting_config.fog.color then
				lighting_service.FogColor = lighting_config.fog.color
			end
			
			if lighting_config.fog then
				local fog_start = lighting_config.fog.start
				if fog_start ~= nil and type(fog_start) == "number" and fog_start == fog_start then
					lighting_service.FogStart = fog_start
				end
				
				local fog_ending = lighting_config.fog.ending
				if fog_ending ~= nil and type(fog_ending) == "number" and fog_ending == fog_ending then
					lighting_service.FogEnd = fog_ending
				end
			end
			
			if lighting_config.shadows and lighting_config.shadows.global_shadows ~= nil then
				lighting_service.GlobalShadows = lighting_config.shadows.global_shadows
			end
			
			if lighting_config.shadows and lighting_config.shadows.softness_enabled and lighting_config.shadows.softness ~= nil then
				lighting_service.ShadowSoftness = lighting_config.shadows.softness
			end
			
			if lighting_config.environment and lighting_config.environment.enabled then
				if lighting_config.environment.diffuse_scale ~= nil then
					lighting_service.EnvironmentDiffuseScale = lighting_config.environment.diffuse_scale
				end
				
				if lighting_config.environment.specular_scale ~= nil then
					lighting_service.EnvironmentSpecularScale = lighting_config.environment.specular_scale
				end
			end
			
			if lighting_config.quality then
				local lighting_style = lighting_config.quality.lighting_style
				if lighting_style and typeof(lighting_style) == "EnumItem" then
					pcall(function()
						lighting_service.LightingStyle = lighting_style
					end)
				end
				
				if lighting_config.quality.exposure_compensation ~= nil then
					lighting_service.ExposureCompensation = lighting_config.quality.exposure_compensation
				end
				
				if lighting_config.quality.prioritize_lighting_quality ~= nil then
					lighting_service.PrioritizeLightingQuality = lighting_config.quality.prioritize_lighting_quality
				end
			end
		end,
		create_aura_effect = function(aura_type, attachment, parent_part)
			local emitters = {}
			local extra_attachments = {}
			
			if aura_type == "Angel Wings" then
				attachment.Name = "ParticleAttachment"
				attachment.CFrame = CFrame.new(0, 0, 0, 0.965, 0.259, 0, -0.259, 0.965, 0, 0, 0, 1)
				attachment.Axis = Vector3.new(0.966, -0.259, 0)
				attachment.SecondaryAxis = Vector3.new(0.259, 0.966, 0)
				
				local particleEmitter = Instance.new("ParticleEmitter")
				particleEmitter.Name = "ParticleEmitter"
				particleEmitter.Texture = "rbxassetid://14054635072"
				particleEmitter.LockedToPart = true
				particleEmitter.Brightness = 1
				particleEmitter.LightEmission = 1
				particleEmitter.LightInfluence = 0
				particleEmitter.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
				particleEmitter.Size = NumberSequence.new(4)
				particleEmitter.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(1, 1)})
				particleEmitter.Lifetime = NumberRange.new(1)
				particleEmitter.Rate = 10
				particleEmitter.Rotation = NumberRange.new(0, 360)
				particleEmitter.RotSpeed = NumberRange.new(30, 60)
				particleEmitter.Speed = NumberRange.new(0.01)
				particleEmitter.SpreadAngle = Vector2.new(0.1)
				particleEmitter.Parent = attachment
				table.insert(emitters, particleEmitter)
				
			elseif aura_type == "Particle Aura" then
				local ringAttachment = Instance.new("Attachment")
				ringAttachment.Name = "ParticleAttachment"
				ringAttachment.Parent = parent_part
				ringAttachment.CFrame = CFrame.new(0, -3, 0)
				ringAttachment.Axis = Vector3.new(1, 0, 0)
				ringAttachment.SecondaryAxis = Vector3.new(0, 1, 0)
				table.insert(extra_attachments, ringAttachment)
				
				local whiteColor = ColorSequence.new(Color3.new(1, 1, 1))
				local emitterProps = {
					Brightness = 2, Color = whiteColor, LightEmission = 1, LightInfluence = 0,
					Orientation = Enum.ParticleOrientation.VelocityPerpendicular, LockedToPart = true,
					EmissionDirection = Enum.NormalId.Top, Lifetime = NumberRange.new(2, 2), Rate = 20,
					Rotation = NumberRange.new(0, 360), Speed = NumberRange.new(0.001, 0.001), SpreadAngle = Vector2.new(0.001, 0.001)
				}
				
				local sizeLarge = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.3, 2), NumberSequenceKeypoint.new(0.6, 5), NumberSequenceKeypoint.new(0.8, 8), NumberSequenceKeypoint.new(1, 12)})
				local sizeSmall = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.3, 1), NumberSequenceKeypoint.new(0.6, 2.5), NumberSequenceKeypoint.new(0.8, 4), NumberSequenceKeypoint.new(1, 6)})
				local squashLight = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0.2)})
				local squashHeavy = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 2)})
				local transFade = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.2, 0.3), NumberSequenceKeypoint.new(1, 1)})
				local transQuick = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 1)})
				local transMidFade = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.2, 0.6), NumberSequenceKeypoint.new(1, 1)})
				
				local emitter1 = Instance.new("ParticleEmitter")
				emitter1.Name = "ParticleEmitter1"
				for k, v in pairs(emitterProps) do emitter1[k] = v end
				emitter1.Size = sizeLarge
				emitter1.Squash = squashLight
				emitter1.Texture = "rbxassetid://7216855136"
				emitter1.Transparency = transFade
				emitter1.RotSpeed = NumberRange.new(-40, 40)
				emitter1.Parent = ringAttachment
				table.insert(emitters, emitter1)
				
				local emitter2 = Instance.new("ParticleEmitter")
				emitter2.Name = "ParticleEmitter2"
				for k, v in pairs(emitterProps) do emitter2[k] = v end
				emitter2.Size = sizeSmall
				emitter2.Squash = squashLight
				emitter2.Texture = "https://assetgame.roblox.com/asset/?id=12713358087&assetName=crescent"
				emitter2.Transparency = transQuick
				emitter2.RotSpeed = NumberRange.new(-600, 600)
				emitter2.Parent = ringAttachment
				table.insert(emitters, emitter2)
				
				local emitter3 = Instance.new("ParticleEmitter")
				emitter3.Name = "ParticleEmitter3"
				for k, v in pairs(emitterProps) do emitter3[k] = v end
				emitter3.Size = sizeSmall
				emitter3.Squash = squashHeavy
				emitter3.Texture = "rbxassetid://7216849325"
				emitter3.Transparency = transMidFade
				emitter3.RotSpeed = NumberRange.new(-30, 30)
				emitter3.Parent = ringAttachment
				table.insert(emitters, emitter3)
				
			elseif aura_type == "Earthquake" then
				local transparency1 = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0.863), NumberSequenceKeypoint.new(1, 1)})
				local transparency2 = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5, 0.225), NumberSequenceKeypoint.new(1, 1)})
				
				local attachmentOffsets = {
					CFrame.new(2.9, 0.42, 0.65, 1, 0, 0, 0, 0, -1, 0, 1, 0),
					CFrame.new(0.91, 0.42, -2.98, 1, 0, 0, 0, 0, -1, 0, 1, 0),
					CFrame.new(0.84, 0.06, 2.57, 0, 0, 1, 1, 0, 0, 0, 1, 0),
					CFrame.new(2.67, -0.84, -1.51, 0, 0, 1, 1, 0, 0, 0, 1, 0),
					CFrame.new(-1.63, 1.88, 2.09, 0, 0, 1, 1, 0, 0, 0, 1, 0),
					CFrame.new(-1.68, -0.18, -2.84, 0, 0, 1, 1, 0, 0, 0, 1, 0),
					CFrame.new(-3.29, 0.2, 0.32, 0, 0, 1, 1, 0, 0, 0, 1, 0),
					CFrame.new(-0.87, -0.53, 1.34, 0, 0, 1, 1, 0, 0, 0, 1, 0),
					CFrame.new(-3.21, 0.91, -2.04, 0, 0, 1, 1, 0, 0, 0, 1, 0)
				}
				
				local wingAttachments = {}
				for i, offset in ipairs(attachmentOffsets) do
					local wingAttachment = Instance.new("Attachment")
					wingAttachment.Name = "ParticleAttachment" .. i
					wingAttachment.Parent = parent_part
					wingAttachment.CFrame = offset
					wingAttachment.Axis = Vector3.new(1, 0, 0)
					wingAttachment.SecondaryAxis = Vector3.new(0, 0, 1)
					
					local emitter1 = Instance.new("ParticleEmitter")
					emitter1.Name = "ParticleEmitter1"
					emitter1.Parent = wingAttachment
					emitter1.Brightness = 10
					emitter1.Size = NumberSequence.new(1)
					emitter1.Squash = NumberSequence.new(0)
					emitter1.LockedToPart = true
					emitter1.Color = ColorSequence.new(Color3.new(1, 1, 1))
					emitter1.LightEmission = 1
					emitter1.LightInfluence = 0.65
					emitter1.Orientation = Enum.ParticleOrientation.FacingCamera
					emitter1.EmissionDirection = Enum.NormalId.Top
					emitter1.Lifetime = NumberRange.new(1)
					emitter1.Rate = 5
					emitter1.Speed = NumberRange.new(0.001)
					emitter1.SpreadAngle = Vector2.new(0.1, 0.1)
					emitter1.Texture = "rbxassetid://9922864240"
					emitter1.Transparency = transparency1
					table.insert(emitters, emitter1)
					
					local emitter2 = Instance.new("ParticleEmitter")
					emitter2.Name = "ParticleEmitter2"
					emitter2.Parent = wingAttachment
					emitter2.Brightness = 2
					emitter2.Size = NumberSequence.new(0.75)
					emitter2.Squash = NumberSequence.new(0)
					emitter2.LockedToPart = true
					emitter2.Color = ColorSequence.new(Color3.new(1, 1, 1))
					emitter2.LightEmission = 1
					emitter2.LightInfluence = 0
					emitter2.Orientation = Enum.ParticleOrientation.FacingCamera
					emitter2.EmissionDirection = Enum.NormalId.Top
					emitter2.Lifetime = NumberRange.new(1)
					emitter2.Rate = 5
					emitter2.Speed = NumberRange.new(0.001)
					emitter2.SpreadAngle = Vector2.new(0.1, 0.1)
					emitter2.Texture = "rbxassetid://16444981264"
					emitter2.Transparency = transparency2
					table.insert(emitters, emitter2)
					
					table.insert(extra_attachments, wingAttachment)
					wingAttachments[i] = wingAttachment
				end
				
				local textures = {
					{ "rbxassetid://15687629443", 0.5, -2, NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.018,0.3),NumberSequenceKeypoint.new(0.019,0),NumberSequenceKeypoint.new(0.991,0),NumberSequenceKeypoint.new(0.992,0.3),NumberSequenceKeypoint.new(1,0.3)}), 0.15, 0.15 },
					{ "rbxassetid://15687532616", 0.5, -0.8, NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.018,1),NumberSequenceKeypoint.new(0.019,0),NumberSequenceKeypoint.new(0.798,0),NumberSequenceKeypoint.new(0.847,0.546),NumberSequenceKeypoint.new(1,1)}), 0.3, 0.15 },
					{ "rbxassetid://16726908900", 1, -0.8, NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.018,1),NumberSequenceKeypoint.new(0.019,0.2),NumberSequenceKeypoint.new(0.798,0.2),NumberSequenceKeypoint.new(0.847,0.546),NumberSequenceKeypoint.new(1,1)}), 0.25, 0.25 },
					{ "rbxassetid://623219622", 0.5, -0.8, NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.018,1),NumberSequenceKeypoint.new(0.019,0.2),NumberSequenceKeypoint.new(0.798,0.2),NumberSequenceKeypoint.new(0.847,0.546),NumberSequenceKeypoint.new(1,1)}), 0.25, 0.25 }
				}
				
				for _, pair in ipairs({
					{wingAttachments[2], wingAttachments[4]}, {wingAttachments[4], wingAttachments[1]}, {wingAttachments[1], wingAttachments[3]}, {wingAttachments[3], wingAttachments[8]},
					{wingAttachments[3], wingAttachments[5]}, {wingAttachments[5], wingAttachments[7]}, {wingAttachments[7], wingAttachments[9]}, {wingAttachments[7], wingAttachments[6]}
				}) do 
					for i = 1, 4 do 
						local selected = textures[i]
						local beam = Instance.new("Beam")
						beam.Parent = parent_part
						beam.Attachment0 = pair[1]
						beam.Attachment1 = pair[2]
						beam.FaceCamera = true
						beam.Segments = 10
						beam.Brightness = 5
						beam.Color = ColorSequence.new(Color3.new(1, 1, 1))
						beam.LightEmission = 1
						beam.LightInfluence = 0
						beam.Texture = selected[1]
						beam.TextureLength = selected[2]
						beam.TextureSpeed = selected[3]
						beam.Transparency = selected[4]
						beam.Width0 = selected[5]
						beam.Width1 = selected[6]
					end 
				end
				
			elseif aura_type == "Halo" then
				local head = parent_part:FindFirstChild("Head")
				if not head then return end
				
				local haloAttachment = Instance.new("Attachment")
				haloAttachment.Name = "CustomAttachment"
				haloAttachment.CFrame = CFrame.new(-0.05, 0.933012962, 0.25881958, 
					0.965931654, -0.249973103, 0.0670034066, 
					0.258797228, 0.933025956, -0.249973089, 
					-2.9373914e-05, 0.258797228, 0.965931654)
				haloAttachment.Axis = Vector3.new(0.9659316539764404, 0.25879722833633423, -0.000029373914003372192)
				haloAttachment.SecondaryAxis = Vector3.new(-0.2499731034040451, 0.9330259561538696, 0.25879722833633423)
				haloAttachment.Parent = head
				table.insert(extra_attachments, haloAttachment)
				
				local emitter1 = Instance.new("ParticleEmitter")
				emitter1.Name = "ParticleEmitter1"
				emitter1.Brightness = 2
				emitter1.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
				emitter1.LightEmission = 1
				emitter1.LightInfluence = 0
				emitter1.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
				emitter1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2.5), NumberSequenceKeypoint.new(1, 3)})
				emitter1.Squash = NumberSequence.new(0)
				emitter1.Texture = "rbxassetid://8819682608"
				emitter1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.2, 0), NumberSequenceKeypoint.new(0.8, 0), NumberSequenceKeypoint.new(1, 1)})
				emitter1.EmissionDirection = Enum.NormalId.Top
				emitter1.Lifetime = NumberRange.new(1, 1)
				emitter1.Rate = 7
				emitter1.Rotation = NumberRange.new(0, 360)
				emitter1.RotSpeed = NumberRange.new(-400, 400)
				emitter1.Speed = NumberRange.new(0.001)
				emitter1.SpreadAngle = Vector2.new(5, 5)
				emitter1.Shape = Enum.ParticleEmitterShape.Box
				emitter1.LockedToPart = true
				emitter1.Parent = haloAttachment
				table.insert(emitters, emitter1)
				
				local emitter2 = Instance.new("ParticleEmitter")
				emitter2.Name = "ParticleEmitter2"
				emitter2.Brightness = 2
				emitter2.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
				emitter2.LightEmission = 1
				emitter2.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
				emitter2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2), NumberSequenceKeypoint.new(1, 3)})
				emitter2.Squash = NumberSequence.new(0)
				emitter2.Texture = "rbxassetid://8819682608"
				emitter2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.2, 0), NumberSequenceKeypoint.new(0.8, 0), NumberSequenceKeypoint.new(1, 1)})
				emitter2.EmissionDirection = Enum.NormalId.Top
				emitter2.Lifetime = NumberRange.new(1, 1)
				emitter2.Rate = 7
				emitter2.Rotation = NumberRange.new(0, 360)
				emitter2.RotSpeed = NumberRange.new(-400, 400)
				emitter2.Speed = NumberRange.new(0.001)
				emitter2.SpreadAngle = Vector2.new(5, 5)
				emitter2.Shape = Enum.ParticleEmitterShape.Box
				emitter2.LockedToPart = true
				emitter2.Parent = haloAttachment
				table.insert(emitters, emitter2)
			elseif aura_type == "Saturn Ring" then
				local attachment1 = Instance.new("Attachment")
				attachment1.Name = "ParticleAttachment1"
				attachment1.CFrame = CFrame.new(2, 0.5, 1) * CFrame.fromMatrix(Vector3.new(), Vector3.new(0.965929627, 0, 0.258804798), Vector3.new(0, 1, 0), Vector3.new(-0.258804798, 0, 0.965929627))
				attachment1.Axis = Vector3.new(0.9659296274185181, 0, 0.2588047981262207)
				attachment1.SecondaryAxis = Vector3.new(0, 1, 0)
				attachment1.Parent = parent_part
				table.insert(extra_attachments, attachment1)
				
				local emitter1 = Instance.new("ParticleEmitter")
				emitter1.Name = "ParticleEmitter1"
				emitter1.Brightness = 2
				emitter1.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
				emitter1.LightEmission = 1
				emitter1.LightInfluence = 0
				emitter1.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
				emitter1.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2.75), NumberSequenceKeypoint.new(1, 3.5)})
				emitter1.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
				emitter1.Texture = "http://www.roblox.com/asset/?id=13267054240"
				emitter1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.944444), NumberSequenceKeypoint.new(0.5, 0.2), NumberSequenceKeypoint.new(0.8, 0.8), NumberSequenceKeypoint.new(1, 1)})
				emitter1.LockedToPart = true
				emitter1.EmissionDirection = Enum.NormalId.Front
				emitter1.Lifetime = NumberRange.new(1, 1)
				emitter1.Rate = 4
				emitter1.Rotation = NumberRange.new(-15, -15)
				emitter1.Speed = NumberRange.new(0.05000000074505806, 0.05000000074505806)
				emitter1.Parent = attachment1
				table.insert(emitters, emitter1)
				
				local attachment2 = Instance.new("Attachment")
				attachment2.Name = "ParticleAttachment2"
				attachment2.CFrame = CFrame.new(-2, 0.5, 1) * CFrame.fromMatrix(Vector3.new(), Vector3.new(0.965929627, 0, -0.258804798), Vector3.new(0, 1, 0), Vector3.new(0.258804798, 0, 0.965929627))
				attachment2.Axis = Vector3.new(0.9659296274185181, 0, -0.2588047981262207)
				attachment2.SecondaryAxis = Vector3.new(0, 1, 0)
				attachment2.Parent = parent_part
				table.insert(extra_attachments, attachment2)
				
				local emitter2 = Instance.new("ParticleEmitter")
				emitter2.Name = "ParticleEmitter2"
				emitter2.Brightness = 2
				emitter2.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
				emitter2.LightEmission = 1
				emitter2.LightInfluence = 0
				emitter2.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
				emitter2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 2.75), NumberSequenceKeypoint.new(1, 3.5)})
				emitter2.Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0)})
				emitter2.Texture = "http://www.roblox.com/asset/?id=13267054240"
				emitter2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.944444), NumberSequenceKeypoint.new(0.5, 0.2), NumberSequenceKeypoint.new(0.8, 0.8), NumberSequenceKeypoint.new(1, 1)})
				emitter2.LockedToPart = true
				emitter2.EmissionDirection = Enum.NormalId.Back
				emitter2.Lifetime = NumberRange.new(1, 1)
				emitter2.Rate = 4
				emitter2.Rotation = NumberRange.new(-15, -15)
				emitter2.Speed = NumberRange.new(0.05000000074505806, 0.05000000074505806)
				emitter2.Parent = attachment2
				table.insert(emitters, emitter2)
			end
			
			return emitters, extra_attachments
		end,
		update_self_material = function()
			local local_player = self.vars.local_player
			if not local_player then return end
			
			local char = local_player.Character
			if not char then return end
			
			if Stranded.self_material.enabled then
				local material_type = Enum.Material[Stranded.self_material.type] or Enum.Material.Neon
				for _, part in ipairs(char:GetDescendants()) do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						part.Material = material_type
						part.Color = Stranded.self_material.color
					end
				end
			end
		end,
		update_self_tool_material = function()
			local local_player = self.vars.local_player
			if not local_player then return end
			
			local char = local_player.Character
			if not char then return end
			
			if Stranded.self_toolmaterial.enabled then
				local material_type = Enum.Material[Stranded.self_toolmaterial.type] or Enum.Material.Neon
				local tool = char:FindFirstChildOfClass("Tool")
				if tool then
					for _, part in ipairs(tool:GetDescendants()) do
						if part:IsA("BasePart") then
							part.Material = material_type
							part.Color = Stranded.self_toolmaterial.color
						end
					end
				end
			end
		end,
		play_hitsound = function()
			if not Stranded.hitsounds.enabled then return end
			
			local sound_id = hitsound_sounds[Stranded.hitsounds.type]
			if not sound_id then return end
			
			task.spawn(function()
				local sound = Instance.new("Sound")
				sound.SoundId = sound_id
				sound.Volume = math.clamp(Stranded.hitsounds.volume / 100, 0, 1)
				sound.Parent = workspace
				
				local success, err = pcall(function()
					sound:Play()
				end)
				
				if not success then
					warn("Hitsound play error:", err)
					sound:Destroy()
					return
				end
				
				sound.Ended:Connect(function()
					if sound and sound.Parent then
						sound:Destroy()
					end
				end)
				
				task.spawn(function()
					task.wait(5)
					if sound and sound.Parent then
						sound:Destroy()
					end
				end)
			end)
		end,
		create_hit_effect = function(player)
			if not Stranded.hiteffects.enabled then return end
			if not player then return end
			
			local success, err = pcall(function()
				local char = player.Character
				if not char or not char.Parent then return end
				
				local root_part = char:FindFirstChild("HumanoidRootPart")
				if not root_part then return end
				
				if self.hitsound_cache.hit_effects[player] then
					local old_effect = self.hitsound_cache.hit_effects[player]
					if old_effect and old_effect.Parent then
						old_effect:Destroy()
					end
					self.hitsound_cache.hit_effects[player] = nil
				end
				
				local effect_type = Stranded.hiteffects.type or "Pulse"
				local hit_color = Stranded.hiteffects.color or Color3.fromRGB(255, 255, 255)
				local debris_service = self.vars.game:GetService("Debris")
				local tween_service = self.vars.game:GetService("TweenService")
				
				if effect_type == "Pulse" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightEmission = 1
					particle.LightInfluence = 0
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.5, 0.3),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Color = ColorSequence.new(hit_color)
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 2),
						NumberSequenceKeypoint.new(0.5, 3),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Rotation = NumberRange.new(0, 360)
					particle.RotSpeed = NumberRange.new(-180, 180)
					particle.Enabled = false
					particle.Rate = 0
					particle.Lifetime = NumberRange.new(0.4, 0.6)
					particle.Speed = NumberRange.new(8, 15)
					particle.SpreadAngle = Vector2.new(360, 360)
					particle.Texture = "rbxassetid://2916153928"
					particle.Shape = Enum.ParticleEmitterShape.Sphere
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(30)
					debris_service:AddItem(attachment, 1)
					
					local highlight = Instance.new("Highlight")
					highlight.Adornee = char
					highlight.FillColor = hit_color
					highlight.OutlineColor = hit_color
					highlight.FillTransparency = 0.3
					highlight.OutlineTransparency = 0
					highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
					highlight.Enabled = true
					highlight.Parent = char
					
					self.hitsound_cache.hit_effects[player] = highlight
					
					task.spawn(function()
						for i = 0.3, 1, 0.05 do
							if highlight and highlight.Parent and highlight.Adornee then
								highlight.FillTransparency = i
								highlight.OutlineTransparency = i * 0.3
								task.wait(0.05)
							else
								break
							end
						end
						if highlight and highlight.Parent then
							highlight:Destroy()
						end
						if self.hitsound_cache.hit_effects[player] == highlight then
							self.hitsound_cache.hit_effects[player] = nil
						end
					end)
				
				elseif effect_type == "Clone" then
					char.Archivable = true
					local clone = char:Clone()
					clone.Parent = workspace
					local humanoid = clone:FindFirstChildOfClass("Humanoid")
					if humanoid then
						humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
					end
					
					for _, v in pairs(clone:GetDescendants()) do
						if v:IsA("BasePart") then
							v.Material = Enum.Material.ForceField
							v.Color = hit_color
							v.CanCollide = false
							v.Anchored = true
							v.CanQuery = false
							v.CanTouch = false
						elseif v:IsA("Accessory") or v:IsA("Tool") then
							v:Destroy()
						end
					end
					
					if char.PrimaryPart then
						clone:PivotTo(char.PrimaryPart.CFrame)
					end
					char.Archivable = false
					debris_service:AddItem(clone, 0.5)
					
				elseif effect_type == "Explosion" then
					local attachment = Instance.new("Attachment", root_part)
					
					local main_particle = Instance.new("ParticleEmitter", attachment)
					main_particle.LightEmission = 1
					main_particle.LightInfluence = 0
					main_particle.Lifetime = NumberRange.new(0.2, 0.4)
					main_particle.Speed = NumberRange.new(20, 35)
					main_particle.Brightness = 4
					main_particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.1, 3),
						NumberSequenceKeypoint.new(0.3, 4),
						NumberSequenceKeypoint.new(1, 0)
					})
					main_particle.Color = ColorSequence.new(hit_color)
					main_particle.Enabled = false
					main_particle.Rate = 0
					main_particle.Acceleration = Vector3.new(0, 20, 0)
					main_particle.Texture = "rbxassetid://15194500627"
					main_particle.Rotation = NumberRange.new(-180, 180)
					main_particle.SpreadAngle = Vector2.new(360, 360)
					main_particle.Shape = Enum.ParticleEmitterShape.Sphere
					main_particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					main_particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					local spark_particle = Instance.new("ParticleEmitter", attachment)
					spark_particle.LightEmission = 1
					spark_particle.LightInfluence = 0
					spark_particle.Lifetime = NumberRange.new(0.3, 0.5)
					spark_particle.Speed = NumberRange.new(25, 40)
					spark_particle.Brightness = 3
					spark_particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 1),
						NumberSequenceKeypoint.new(1, 0)
					})
					spark_particle.Color = ColorSequence.new(hit_color, Color3.new(hit_color.R * 0.7, hit_color.G * 0.7, hit_color.B * 0.7))
					spark_particle.Enabled = false
					spark_particle.Rate = 0
					spark_particle.Texture = "rbxassetid://2916153928"
					spark_particle.Rotation = NumberRange.new(0, 360)
					spark_particle.SpreadAngle = Vector2.new(360, 360)
					spark_particle.Shape = Enum.ParticleEmitterShape.Sphere
					spark_particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					spark_particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					main_particle:Emit(40)
					spark_particle:Emit(25)
					debris_service:AddItem(attachment, 1)
					
				elseif effect_type == "Cum" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightInfluence = 0.5
					particle.Lifetime = NumberRange.new(0.8, 1.2)
					particle.SpreadAngle = Vector2.new(360, 360)
					particle.Speed = NumberRange.new(15, 25)
					particle.Brightness = 2
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 1),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Color = ColorSequence.new(hit_color)
					particle.Enabled = false
					particle.Rate = 0
					particle.Acceleration = Vector3.new(0, -50, 0)
					particle.Texture = "rbxassetid://8297030850"
					particle.Orientation = Enum.ParticleOrientation.VelocityParallel
					
					particle:Emit(15)
					debris_service:AddItem(attachment, 1.5)
					
				elseif effect_type == "Shockwave" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.Color = ColorSequence.new(Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 255, 0))
					particle.LightEmission = 1
					particle.LightInfluence = 0
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.5),
						NumberSequenceKeypoint.new(0.3, 2),
						NumberSequenceKeypoint.new(1, 4)
					})
					particle.Lifetime = NumberRange.new(0.5)
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.5, 0.3),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Enabled = false
					particle.Rate = 0
					particle.Speed = NumberRange.new(3, 6)
					particle.RotSpeed = NumberRange.new(0, 100)
					particle.SpreadAngle = Vector2.new(360, 360)
					particle.Texture = "rbxassetid://2916153928"
					particle.Shape = Enum.ParticleEmitterShape.Sphere
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(50)
					debris_service:AddItem(attachment, 1)
					
				elseif effect_type == "Smoke" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightEmission = 0.8
					particle.LightInfluence = 0
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.3),
						NumberSequenceKeypoint.new(0.4, 0.2),
						NumberSequenceKeypoint.new(0.7, 0.5),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Color = ColorSequence.new(hit_color)
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.5),
						NumberSequenceKeypoint.new(0.3, 2),
						NumberSequenceKeypoint.new(0.7, 3),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Rotation = NumberRange.new(0, 360)
					particle.RotSpeed = NumberRange.new(-80, 80)
					particle.Enabled = false
					particle.Rate = 0
					particle.Lifetime = NumberRange.new(1.2, 1.8)
					particle.Speed = NumberRange.new(3, 6)
					particle.Acceleration = Vector3.new(0, 5, 0)
					particle.Texture = "rbxassetid://303195022"
					particle.Shape = Enum.ParticleEmitterShape.Box
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(30)
					debris_service:AddItem(attachment, 2)
					
				elseif effect_type == "Burst" then
					local attachment = Instance.new("Attachment", root_part)
					
					local core_particle = Instance.new("ParticleEmitter", attachment)
					core_particle.LightEmission = 1.5
					core_particle.LightInfluence = 0
					core_particle.Lifetime = NumberRange.new(0.3, 0.5)
					core_particle.Speed = NumberRange.new(10, 20)
					core_particle.Brightness = 5
					core_particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.1, 4),
						NumberSequenceKeypoint.new(0.4, 5),
						NumberSequenceKeypoint.new(1, 0)
					})
					core_particle.Color = ColorSequence.new(hit_color)
					core_particle.Enabled = false
					core_particle.Rate = 0
					core_particle.Texture = "rbxassetid://2916153928"
					core_particle.Rotation = NumberRange.new(0, 360)
					core_particle.SpreadAngle = Vector2.new(360, 360)
					core_particle.Shape = Enum.ParticleEmitterShape.Sphere
					core_particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					core_particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					local spike_particle = Instance.new("ParticleEmitter", attachment)
					spike_particle.LightEmission = 1
					spike_particle.LightInfluence = 0
					spike_particle.Lifetime = NumberRange.new(0.2, 0.4)
					spike_particle.Speed = NumberRange.new(15, 30)
					spike_particle.Brightness = 4
					spike_particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 1.5),
						NumberSequenceKeypoint.new(1, 0)
					})
					spike_particle.Color = ColorSequence.new(hit_color, Color3.new(hit_color.R * 0.8, hit_color.G * 0.8, hit_color.B * 0.8))
					spike_particle.Enabled = false
					spike_particle.Rate = 0
					spike_particle.Texture = "rbxassetid://2916153928"
					spike_particle.Rotation = NumberRange.new(0, 360)
					spike_particle.SpreadAngle = Vector2.new(360, 360)
					spike_particle.Shape = Enum.ParticleEmitterShape.Sphere
					spike_particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					spike_particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					core_particle:Emit(20)
					spike_particle:Emit(40)
					debris_service:AddItem(attachment, 1)
					
				elseif effect_type == "Electric" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightEmission = 1.5
					particle.LightInfluence = 0
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.3, 0.2),
						NumberSequenceKeypoint.new(0.7, 0.5),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Color = ColorSequence.new(Color3.fromRGB(0, 150, 255), hit_color)
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.1, 2),
						NumberSequenceKeypoint.new(0.5, 1.5),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Rotation = NumberRange.new(0, 360)
					particle.RotSpeed = NumberRange.new(-360, 360)
					particle.Enabled = false
					particle.Rate = 0
					particle.Lifetime = NumberRange.new(0.3, 0.5)
					particle.Speed = NumberRange.new(12, 25)
					particle.SpreadAngle = Vector2.new(360, 360)
					particle.Texture = "rbxassetid://2916153928"
					particle.Shape = Enum.ParticleEmitterShape.Sphere
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(35)
					debris_service:AddItem(attachment, 1)
					
				elseif effect_type == "Fire" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightEmission = 1.2
					particle.LightInfluence = 0.3
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.2),
						NumberSequenceKeypoint.new(0.3, 0.1),
						NumberSequenceKeypoint.new(0.7, 0.4),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Color = ColorSequence.new(Color3.fromRGB(255, 100, 0), Color3.fromRGB(255, 200, 0))
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 2),
						NumberSequenceKeypoint.new(0.5, 3),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Rotation = NumberRange.new(0, 360)
					particle.RotSpeed = NumberRange.new(-200, 200)
					particle.Enabled = false
					particle.Rate = 0
					particle.Lifetime = NumberRange.new(0.4, 0.7)
					particle.Speed = NumberRange.new(10, 20)
					particle.Acceleration = Vector3.new(0, 10, 0)
					particle.SpreadAngle = Vector2.new(360, 360)
					particle.Texture = "rbxassetid://15194500627"
					particle.Shape = Enum.ParticleEmitterShape.Sphere
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(40)
					debris_service:AddItem(attachment, 1)
					
				elseif effect_type == "Ice" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightEmission = 1.3
					particle.LightInfluence = 0
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.4, 0.2),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Color = ColorSequence.new(Color3.fromRGB(150, 200, 255), Color3.fromRGB(200, 230, 255))
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 2.5),
						NumberSequenceKeypoint.new(0.6, 3),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Rotation = NumberRange.new(0, 360)
					particle.RotSpeed = NumberRange.new(-150, 150)
					particle.Enabled = false
					particle.Rate = 0
					particle.Lifetime = NumberRange.new(0.4, 0.6)
					particle.Speed = NumberRange.new(8, 18)
					particle.SpreadAngle = Vector2.new(360, 360)
					particle.Texture = "rbxassetid://2916153928"
					particle.Shape = Enum.ParticleEmitterShape.Sphere
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(35)
					debris_service:AddItem(attachment, 1)
					
				elseif effect_type == "Shatter" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightEmission = 1
					particle.LightInfluence = 0
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.1),
						NumberSequenceKeypoint.new(0.5, 0.3),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Color = ColorSequence.new(hit_color, Color3.new(hit_color.R * 0.6, hit_color.G * 0.6, hit_color.B * 0.6))
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.1, 1.5),
						NumberSequenceKeypoint.new(0.5, 2),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Rotation = NumberRange.new(0, 360)
					particle.RotSpeed = NumberRange.new(-300, 300)
					particle.Enabled = false
					particle.Rate = 0
					particle.Lifetime = NumberRange.new(0.3, 0.5)
					particle.Speed = NumberRange.new(20, 35)
					particle.SpreadAngle = Vector2.new(360, 360)
					particle.Texture = "rbxassetid://2916153928"
					particle.Shape = Enum.ParticleEmitterShape.Sphere
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(45)
					debris_service:AddItem(attachment, 1)
					
				elseif effect_type == "Beam" then
					local attachment = Instance.new("Attachment", root_part)
					local particle = Instance.new("ParticleEmitter", attachment)
					particle.LightEmission = 1.5
					particle.LightInfluence = 0
					particle.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.5, 0.2),
						NumberSequenceKeypoint.new(1, 1)
					})
					particle.Color = ColorSequence.new(hit_color)
					particle.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 3),
						NumberSequenceKeypoint.new(0.8, 2),
						NumberSequenceKeypoint.new(1, 0)
					})
					particle.Rotation = NumberRange.new(0, 360)
					particle.RotSpeed = NumberRange.new(0)
					particle.Enabled = false
					particle.Rate = 0
					particle.Lifetime = NumberRange.new(0.5, 0.7)
					particle.Speed = NumberRange.new(5, 10)
					particle.SpreadAngle = Vector2.new(45, 45)
					particle.Texture = "rbxassetid://2916153928"
					particle.Shape = Enum.ParticleEmitterShape.Box
					particle.ShapeInOut = Enum.ParticleEmitterShapeInOut.Outward
					particle.ShapeStyle = Enum.ParticleEmitterShapeStyle.Volume
					
					particle:Emit(25)
					debris_service:AddItem(attachment, 1)
			end
			end)
			
			if not success then
				warn("Hit effect error:", err)
			end
		end,
		create_bullet_tracer = function(from, to, tracer_type, color, thickness, duration)
			if not Stranded.bullet_tracers.enabled then return end
			
			local success, err = pcall(function()
				local ZeroPart = Instance.new("Part")
				local MainPart = Instance.new("Part")
				local OnePart = Instance.new("Part")
				local ZeroAttachment = Instance.new("Attachment", ZeroPart)
				local OneAttachment = Instance.new("Attachment", OnePart)
				local beam = Instance.new("Beam")
				
				MainPart.Parent = workspace
				MainPart.Size = Vector3.new(0, 0, 0)
				MainPart.Massless = true
				MainPart.Transparency = 1
				MainPart.CanCollide = false
				MainPart.Position = from
				MainPart.Anchored = true
				MainPart.CanQuery = false
				MainPart.CanTouch = false
				
				ZeroPart.Parent = MainPart
				ZeroPart.Size = Vector3.new(0, 0, 0)
				ZeroPart.Massless = true
				ZeroPart.Transparency = 1
				ZeroPart.CanCollide = false
				ZeroPart.Position = from
				ZeroPart.Anchored = true
				ZeroPart.CanQuery = false
				ZeroPart.CanTouch = false
				
				OnePart.Parent = MainPart
				OnePart.Size = Vector3.new(0, 0, 0)
				OnePart.Massless = true
				OnePart.Transparency = 1
				OnePart.CanCollide = false
				OnePart.Position = to
				OnePart.Anchored = true
				OnePart.CanQuery = false
				OnePart.CanTouch = false
				
				beam.Attachment0 = ZeroAttachment
				beam.Attachment1 = OneAttachment
				beam.Parent = MainPart
				beam.FaceCamera = true
				beam.LightEmission = 1
				beam.LightInfluence = 1
				beam.ZOffset = -1
				
				if tracer_type == "Lazar" then
					beam.Texture = "rbxassetid://446111271"
					beam.TextureMode = Enum.TextureMode.Wrap
					beam.TextureLength = 10
					beam.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(1, 0)
					})
					beam.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, color),
						ColorSequenceKeypoint.new(1, Color3.new(color.R * 0.3, color.G * 0.3, color.B * 0.3))
					})
					beam.Width0 = thickness
					beam.Width1 = thickness
					
				elseif tracer_type == "Line" then
					beam.Texture = ""
					beam.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.5, 0.2),
						NumberSequenceKeypoint.new(1, 1)
					})
					beam.Color = ColorSequence.new(color)
					beam.Width0 = thickness
					beam.Width1 = thickness * 0.5
					
				elseif tracer_type == "Glow" then
					beam.Texture = "rbxassetid://446111271"
					beam.TextureMode = Enum.TextureMode.Wrap
					beam.TextureLength = 5
					beam.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.3, 0.1),
						NumberSequenceKeypoint.new(0.7, 0.3),
						NumberSequenceKeypoint.new(1, 1)
					})
					beam.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
						ColorSequenceKeypoint.new(0.5, color),
						ColorSequenceKeypoint.new(1, Color3.new(color.R * 0.5, color.G * 0.5, color.B * 0.5))
					})
					beam.Width0 = thickness * 1.5
					beam.Width1 = thickness * 0.8
					
				elseif tracer_type == "Energy" then
					beam.Texture = "rbxassetid://446111271"
					beam.TextureMode = Enum.TextureMode.Wrap
					beam.TextureLength = 20
					beam.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.2),
						NumberSequenceKeypoint.new(0.2, 0),
						NumberSequenceKeypoint.new(0.8, 0),
						NumberSequenceKeypoint.new(1, 0.5)
					})
					beam.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 150, 255)),
						ColorSequenceKeypoint.new(0.5, color),
						ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 150))
					})
					beam.Width0 = thickness * 2
					beam.Width1 = thickness * 1.5
					
				elseif tracer_type == "Plasma" then
					beam.Texture = "rbxassetid://446111271"
					beam.TextureMode = Enum.TextureMode.Wrap
					beam.TextureLength = 15
					beam.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0.1),
						NumberSequenceKeypoint.new(0.3, 0),
						NumberSequenceKeypoint.new(0.7, 0),
						NumberSequenceKeypoint.new(1, 0.3)
					})
					beam.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 100, 0)),
						ColorSequenceKeypoint.new(0.3, color),
						ColorSequenceKeypoint.new(0.7, color),
						ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 200, 0))
					})
					beam.Width0 = thickness * 1.8
					beam.Width1 = thickness * 1.2
					
				elseif tracer_type == "Neon" then
					beam.Texture = ""
					beam.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0),
						NumberSequenceKeypoint.new(0.2, 0.1),
						NumberSequenceKeypoint.new(0.8, 0.1),
						NumberSequenceKeypoint.new(1, 0.5)
					})
					beam.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, color),
						ColorSequenceKeypoint.new(0.5, Color3.new(math.min(color.R + 0.3, 1), math.min(color.G + 0.3, 1), math.min(color.B + 0.3, 1))),
						ColorSequenceKeypoint.new(1, color)
					})
					beam.Width0 = thickness * 1.3
					beam.Width1 = thickness * 1.3
				end
				
				beam.Enabled = true
				
				task.delay(duration, function()
					if MainPart and MainPart.Parent then
						MainPart:Destroy()
					end
				end)
			end)
			
			if not success then
				warn("Bullet tracer error:", err)
			end
		end,
		setup_bullet_tracer_detection = function()
			if not self.vars.local_player then return end
			
			task.spawn(function()
				while true do
					task.wait()
					
					local char = self.vars.local_player.Character
					if char then
						local gun = char:FindFirstChildOfClass("Tool")
						if gun and gun:FindFirstChild("Ammo") then
							local last_ammo = gun.Ammo.Value
							local ammo_connection
							
							ammo_connection = gun.Ammo:GetPropertyChangedSignal("Value"):Connect(function()
								if gun.Ammo.Value < last_ammo then
									local on_hit
									
									on_hit = workspace.Ignored.Siren.Radius.DescendantAdded:Connect(function(object)
										if object.Name == "BULLET_RAYS" then
											if not object:GetAttribute("OwnerCharacter") or object:GetAttribute("OwnerCharacter") ~= char.Name then
												return
											end
											
											local ignore_list = {char, gun.Handle}
											on_hit:Disconnect()
											
											task.delay(0.05, function()
												local position = object.CFrame.Position
												local look_vector = object.CFrame.LookVector
												
												local raycast_params = RaycastParams.new()
												raycast_params.FilterType = Enum.RaycastFilterType.Exclude
												raycast_params.IgnoreWater = true
												raycast_params.FilterDescendantsInstances = ignore_list
												
												local ray_result = workspace:Raycast(position, look_vector * 1000, raycast_params)
												if not ray_result then 
													if Stranded.bullet_tracers.enabled then
														object:Destroy()
														local end_pos = position + (look_vector * Stranded.bullet_tracers.length)
														esp.funcs.create_bullet_tracer(
															position,
															end_pos,
															Stranded.bullet_tracers.type,
															Stranded.bullet_tracers.color,
															Stranded.bullet_tracers.thickness,
															Stranded.bullet_tracers.time
														)
													end
													return 
												end
												
												local hit_pos = ray_result.Position
												
												if Stranded.bullet_tracers.enabled then
													object:Destroy()
													esp.funcs.create_bullet_tracer(
														position,
														hit_pos,
														Stranded.bullet_tracers.type,
														Stranded.bullet_tracers.color,
														Stranded.bullet_tracers.thickness,
														Stranded.bullet_tracers.time
													)
												end
											end)
									end
								end)
							end
							last_ammo = gun.Ammo.Value
						end)
						
						repeat
							task.wait()
						until not gun or not gun.Ammo or gun.Ammo.Value >= last_ammo
						
						if ammo_connection then
							ammo_connection:Disconnect()
						end
						end
					end
				end
			end)
		end,
		check_player = function(player, target_part)
			if not player or not player.Character then return false end
			
			local char = player.Character
			local humanoid = char:FindFirstChildOfClass("Humanoid")
			if not humanoid then return false end
			
			if Stranded.Mods.checks.Dead then
				if humanoid.Health <= 0 then return false end
			end
			
			if Stranded.Mods.checks.Teamcheck then
				if self.vars.local_player and self.vars.local_player.Team and player.Team then
					if self.vars.local_player.Team == player.Team then
						return false
					end
				end
			end
			
			if Stranded.Mods.checks.Wallcheck then
				if target_part then
					local camera = self.vars.camera or workspace.CurrentCamera
					if camera then
						local origin = camera.CFrame.Position
						local target_pos = target_part.Position
						local direction = (target_pos - origin).Unit
						local distance = (target_pos - origin).Magnitude
						
						local raycast_params = RaycastParams.new()
						raycast_params.FilterType = Enum.RaycastFilterType.Blacklist
						raycast_params.FilterDescendantsInstances = {self.vars.local_player.Character, camera}
						raycast_params.IgnoreWater = true
						
						local ray_result = workspace:Raycast(origin, direction * distance, raycast_params)
						if ray_result then
							local hit_part = ray_result.Instance
							if hit_part and hit_part.Parent ~= char then
								return false
							end
						end
					end
				end
			end
			
			if Stranded.Mods.checks.Forcefield then
				local forcefield = char:FindFirstChildOfClass("ForceField")
				if forcefield then
					return false
				end
			end
			
			return true
		end,
		get_closest_player = function(method)
			if not self.vars.local_player or not self.vars.local_player.Character then return nil end
			
			local local_char = self.vars.local_player.Character
			local local_root = local_char:FindFirstChild("HumanoidRootPart")
			if not local_root then return nil end
			
			local camera = self.vars.camera or workspace.CurrentCamera
			if not camera then return nil end
			
			local closest_player = nil
			local closest_distance = math.huge
			local closest_screen_distance = math.huge
			
			for _, player in ipairs(self.vars.players:GetPlayers()) do
				if player == self.vars.local_player then
				elseif not player.Character then
				else
					local char = player.Character
					local humanoid = char:FindFirstChildOfClass("Humanoid")
					local root = char:FindFirstChild("HumanoidRootPart")
					
					if humanoid and root and self.funcs.check_player(player, root) then
						if method == "Closest to Mouse" then
							local screen_pos, on_screen = camera:WorldToViewportPoint(root.Position)
							if on_screen then
								local mouse = self.vars.uis:GetMouseLocation()
								local screen_distance = (Vector2.new(screen_pos.X, screen_pos.Y) - mouse).Magnitude
								
								if screen_distance < closest_screen_distance then
									closest_screen_distance = screen_distance
									closest_player = player
								end
							end
						elseif method == "Closest to Player" then
							local distance = (local_root.Position - root.Position).Magnitude
							if distance < closest_distance then
								closest_distance = distance
								closest_player = player
							end
						end
					end
				end
			end
			
			return closest_player
		end,
		get_aimbot_target_bone = function(player)
			if not player or not player.Character then return nil end
			
			local char = player.Character
			local bone_name = Stranded.aimbot.settings.bone or "Head"
			
			if bone_name == "Head" then
				return char:FindFirstChild("Head")
			elseif bone_name == "HumanoidRootPart" then
				return char:FindFirstChild("HumanoidRootPart")
			else
				local humanoid = char:FindFirstChildOfClass("Humanoid")
				if humanoid and humanoid.RootPart then
					return humanoid.RootPart:FindFirstChild(bone_name) or humanoid.RootPart
				end
			end
			
			return char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
		end,
		get_target_aim_bone = function(player)
			if not player or not player.Character then return nil end
			
			local char = player.Character
			local bone_name = Stranded.target_aim.settings.bone or "Head"
			
			if bone_name == "Head" then
				return char:FindFirstChild("Head")
			elseif bone_name == "HumanoidRootPart" then
				return char:FindFirstChild("HumanoidRootPart")
			else
				local humanoid = char:FindFirstChildOfClass("Humanoid")
				if humanoid and humanoid.RootPart then
					return humanoid.RootPart:FindFirstChild(bone_name) or humanoid.RootPart
				end
			end
			
			return char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
		end,
		get_target_aim_closest_player = function()
			if not Stranded.target_aim.enabled then return nil end
			
			local method = Stranded.target_aim.Method or "FOV"
			
			if method == "FOV" then
				local ClosestDistance, ClosestPart = nil, nil
				local MousePosition = self.vars.uis:GetMouseLocation()
				local camera = self.vars.camera or workspace.CurrentCamera
				if not camera then return nil end
				
				local hit_part_name = Stranded.target_aim.settings.bone or "Head"
				local fov_radius = Stranded.fov and Stranded.fov.radius or 150
				
				for _, Player in next, self.vars.players:GetPlayers() do
					if Player ~= self.vars.local_player and Player.Character then
						local Character = Player.Character
						local HitPart = Character:FindFirstChild(hit_part_name)
						
						if HitPart and self.funcs.check_player(Player, HitPart) then
							local ScreenPosition, Visible = camera:WorldToScreenPoint(HitPart.Position)
							if Visible then
								local Distance = (MousePosition - Vector2.new(ScreenPosition.X, ScreenPosition.Y)).Magnitude
								if Distance <= fov_radius and (not ClosestDistance or Distance < ClosestDistance) then
									ClosestDistance, ClosestPart = Distance, HitPart
								end
							end
						end
					end
				end
				
				return ClosestPart
			elseif method == "Closest to Mouse" then
				local closest_player = self.funcs.get_closest_player("Closest to Mouse")
				if closest_player and closest_player.Character then
					local hit_part_name = Stranded.target_aim.settings.bone or "Head"
					return closest_player.Character:FindFirstChild(hit_part_name)
				end
				return nil
			else
				local closest_player = self.funcs.get_closest_player("Closest to Player")
				if closest_player and closest_player.Character then
					local hit_part_name = Stranded.target_aim.settings.bone or "Head"
					return closest_player.Character:FindFirstChild(hit_part_name)
				end
				return nil
			end
		end,
		target_aim_update = function()
			if not self.target_aim_cache then
				self.target_aim_cache = {
					highlight = nil,
					name_label = nil,
					last_target = nil,
					fov_circle = nil,
					sticky_target_part = nil,
					last_should_aim = false
				}
			end
			
			if not self.target_aim_cache.fov_circle then
				if Drawing then
					self.target_aim_cache.fov_circle = Drawing.new("Circle")
					self.target_aim_cache.fov_circle.Color = Color3.fromRGB(255, 0, 0)
					self.target_aim_cache.fov_circle.Thickness = 1
					self.target_aim_cache.fov_circle.Filled = false
					self.target_aim_cache.fov_circle.Transparency = 1
					self.target_aim_cache.fov_circle.Visible = false
				end
			end
			
			local fov_visible = Stranded.fov and Stranded.fov.visible or false
			local fov_radius = Stranded.fov and Stranded.fov.radius or 150
			
			if self.target_aim_cache.fov_circle then
				self.target_aim_cache.fov_circle.Visible = fov_visible and Stranded.target_aim.enabled
				self.target_aim_cache.fov_circle.Position = self.vars.uis:GetMouseLocation()
				self.target_aim_cache.fov_circle.Radius = fov_radius
			end
			
			if not Stranded.target_aim.enabled then
				if Stranded.target_aim.settings.spectate then
					local camera = workspace.CurrentCamera
					if camera and self.vars.local_player and self.vars.local_player.Character then
						local humanoid = self.vars.local_player.Character:FindFirstChildOfClass("Humanoid")
						if humanoid then
							camera.CameraSubject = humanoid
						end
					end
				end
				
				if self.target_aim_cache.highlight then
					self.target_aim_cache.highlight:Destroy()
					self.target_aim_cache.highlight = nil
				end
				if self.target_aim_cache.name_label then
					self.target_aim_cache.name_label:Destroy()
					self.target_aim_cache.name_label = nil
				end
				self.target_aim_cache.last_target = nil
				if not Stranded.target_aim.settings.sticky_aim then
					self.target_aim_cache.sticky_target_part = nil
				end
				return
			end
			
			local hotkey_flag = Library.Flags["Target Aim Hotkey"]
			local should_aim = false
			
			if hotkey_flag then
				local mode = hotkey_flag.Mode or "Hold"
				if mode == "Always" then
					should_aim = true
				elseif mode == "Toggle" then
					should_aim = hotkey_flag.Toggled or false
				elseif mode == "Hold" then
					local key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
					
					if not key_code then
						local keybind_str = Stranded.target_aim.keybind or "E"
						local success, result = pcall(function()
							return Enum.KeyCode[keybind_str]
						end)
						if success and result then
							key_code = result
						else
							key_code = Enum.KeyCode.E
						end
					end
					
					if key_code then
						should_aim = self.vars.uis:IsKeyDown(key_code)
					end
				end
			else
				local keybind_str = Stranded.target_aim.keybind or "E"
				local success, result = pcall(function()
					return Enum.KeyCode[keybind_str]
				end)
				if success and result then
					should_aim = self.vars.uis:IsKeyDown(result)
				end
			end
			
			local sticky_aim = Stranded.target_aim.settings.sticky_aim
			local last_should_aim = self.target_aim_cache.last_should_aim or false
			
			if sticky_aim and not should_aim and last_should_aim then
				self.target_aim_cache.sticky_target_part = nil
			end
			
			self.target_aim_cache.last_should_aim = should_aim
			
			local target_part = nil
			
			if sticky_aim and should_aim then
				if self.target_aim_cache.sticky_target_part then
					local cached_part = self.target_aim_cache.sticky_target_part
					if cached_part and cached_part.Parent and cached_part.Parent:IsDescendantOf(workspace) then
						local humanoid = cached_part.Parent:FindFirstChildOfClass("Humanoid")
						if humanoid and humanoid.Health > 0 then
							target_part = cached_part
						else
							self.target_aim_cache.sticky_target_part = nil
						end
					else
						self.target_aim_cache.sticky_target_part = nil
					end
				end
				
				if not target_part then
					target_part = self.funcs.get_target_aim_closest_player()
					if target_part then
						self.target_aim_cache.sticky_target_part = target_part
					end
				end
			elseif not sticky_aim and should_aim then
				target_part = self.funcs.get_target_aim_closest_player()
			end
			
			local target_player = nil
			if target_part and target_part.Parent then
				for _, player in ipairs(self.vars.players:GetPlayers()) do
					if player.Character == target_part.Parent then
						target_player = player
						break
					end
				end
			end
			
			if target_player ~= self.target_aim_cache.last_target then
				if self.target_aim_cache.highlight then
					self.target_aim_cache.highlight:Destroy()
					self.target_aim_cache.highlight = nil
				end
				if self.target_aim_cache.name_label then
					self.target_aim_cache.name_label:Destroy()
					self.target_aim_cache.name_label = nil
				end
			end
			
			if Stranded.target_aim.settings.lookat and should_aim and target_part then
				if self.vars.local_player and self.vars.local_player.Character then
					local local_char = self.vars.local_player.Character
					local local_root = local_char:FindFirstChild("HumanoidRootPart")
					
					if local_root then
						local target_position = target_part.Position
						
						if Stranded.target_aim.settings.prediction and Stranded.target_aim.settings.prediction > 0 then
							local target_root = target_part.Parent and target_part.Parent:FindFirstChild("HumanoidRootPart")
							if target_root then
								local target_velocity = Vector3.new(0, 0, 0)
								local body_velocity = target_root:FindFirstChildOfClass("BodyVelocity") or target_root:FindFirstChildOfClass("LinearVelocity")
								if body_velocity then
									target_velocity = body_velocity.Vector or body_velocity.MaxForce
								else
									local humanoid = target_part.Parent:FindFirstChildOfClass("Humanoid")
									if humanoid and humanoid.MoveDirection then
										target_velocity = humanoid.MoveDirection * (humanoid.WalkSpeed or 16)
									end
								end
								
								local prediction = Stranded.target_aim.settings.prediction or 0.17
								target_position = target_position + (target_velocity * prediction)
							end
						end
						
						local current_cframe = local_root.CFrame
						local direction = (target_position - current_cframe.Position)
						direction = Vector3.new(direction.X, 0, direction.Z)
						if direction.Magnitude > 0.001 then
							direction = direction.Unit
							local new_cframe = CFrame.new(current_cframe.Position, current_cframe.Position + direction)
							local_root.CFrame = new_cframe
						end
					end
				end
			end
			
			if Stranded.target_aim.settings.spectate and should_aim and target_player and target_player.Character then
				local camera = workspace.CurrentCamera
				if camera then
					local humanoid = target_player.Character:FindFirstChildOfClass("Humanoid")
					if humanoid then
						camera.CameraSubject = humanoid
					end
				end
			elseif Stranded.target_aim.settings.spectate and (not should_aim or not target_player) then
				local camera = workspace.CurrentCamera
				if camera and self.vars.local_player and self.vars.local_player.Character then
					local humanoid = self.vars.local_player.Character:FindFirstChildOfClass("Humanoid")
					if humanoid then
						camera.CameraSubject = humanoid
					end
				end
			end
			
			if Stranded.target_aim.settings.highlight_target and should_aim and target_player and target_player.Character then
				if not self.target_aim_cache.highlight then
					local highlight = Instance.new("Highlight")
					highlight.FillTransparency = 0.5
					highlight.OutlineTransparency = 0
					highlight.FillColor = Stranded.target_aim.settings.highlight_fill_color or Color3.fromRGB(255, 0, 0)
					highlight.OutlineColor = Stranded.target_aim.settings.highlight_outline_color or Color3.fromRGB(255, 255, 255)
					highlight.Parent = target_player.Character
					self.target_aim_cache.highlight = highlight
				else
					if self.target_aim_cache.highlight.Parent ~= target_player.Character then
						self.target_aim_cache.highlight.Parent = target_player.Character
					end
					self.target_aim_cache.highlight.FillColor = Stranded.target_aim.settings.highlight_fill_color or Color3.fromRGB(255, 0, 0)
					self.target_aim_cache.highlight.OutlineColor = Stranded.target_aim.settings.highlight_outline_color or Color3.fromRGB(255, 255, 255)
				end
			elseif not Stranded.target_aim.settings.highlight_target and self.target_aim_cache.highlight then
				self.target_aim_cache.highlight:Destroy()
				self.target_aim_cache.highlight = nil
			end
			
			if Stranded.target_aim.settings.name_target and should_aim and target_player and target_player.Character then
				local head = target_player.Character:FindFirstChild("Head")
				if head then
					if not self.target_aim_cache.name_label then
						local billboard = Instance.new("BillboardGui")
						billboard.Size = UDim2.new(0, 200, 0, 50)
						billboard.StudsOffset = Vector3.new(0, 3, 0)
						billboard.AlwaysOnTop = true
						billboard.Adornee = head
						billboard.Parent = head
						
						local name_label = Instance.new("TextLabel")
						name_label.Size = UDim2.new(1, 0, 1, 0)
						name_label.BackgroundTransparency = 1
						name_label.Text = target_player.Name
						name_label.TextColor3 = Color3.fromRGB(255, 255, 255)
						name_label.TextStrokeTransparency = 0
						name_label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
						name_label.TextSize = 14
						name_label.Font = Enum.Font.GothamBold
						name_label.Parent = billboard
						
						self.target_aim_cache.name_label = billboard
					else
						if self.target_aim_cache.name_label.Adornee ~= head then
							self.target_aim_cache.name_label.Adornee = head
						end
						local text_label = self.target_aim_cache.name_label:FindFirstChildOfClass("TextLabel")
						if text_label then
							text_label.Text = target_player.Name
						end
					end
				end
			elseif not Stranded.target_aim.settings.name_target and self.target_aim_cache.name_label then
				self.target_aim_cache.name_label:Destroy()
				self.target_aim_cache.name_label = nil
			end
			
			self.target_aim_cache.last_target = target_player
		end,
		get_target_aim_part = function()
			if not Stranded.target_aim.enabled then
				return nil
			end
			
			local hotkey_flag = Library.Flags["Target Aim Hotkey"]
			local should_aim = false
			
			if hotkey_flag then
				local mode = hotkey_flag.Mode or "Hold"
				if mode == "Always" then
					should_aim = true
				elseif mode == "Toggle" then
					should_aim = hotkey_flag.Toggled or false
				elseif mode == "Hold" then
					local key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
					
					if not key_code then
						local keybind_str = Stranded.target_aim.keybind or "E"
						local success, result = pcall(function()
							return Enum.KeyCode[keybind_str]
						end)
						if success and result then
							key_code = result
						else
							key_code = Enum.KeyCode.E
						end
					end
					
					if key_code then
						should_aim = self.vars.uis:IsKeyDown(key_code)
					end
				end
			else
				local keybind_str = Stranded.target_aim.keybind or "E"
				local success, result = pcall(function()
					return Enum.KeyCode[keybind_str]
				end)
				if success and result then
					should_aim = self.vars.uis:IsKeyDown(result)
				end
			end
			
			if not should_aim then
				return nil
			end
			
			return self.funcs.get_target_aim_closest_player()
		end,
		target_strafe_update = function()
			if not Stranded.target_strafe.enabled then
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				return
			end
			
			local local_char = self.vars.local_player.Character
			local local_root = local_char:FindFirstChild("HumanoidRootPart")
			
			if not local_root then
				return
			end
			
			local hotkey_flag = nil
			if Library and Library.Flags then
				hotkey_flag = Library.Flags["Target Strafe Hotkey"]
			end
			local should_strafe = false
			
			if hotkey_flag then
				local mode = hotkey_flag.Mode or "Hold"
				if mode == "Always" then
					should_strafe = true
				elseif mode == "Toggle" then
					should_strafe = hotkey_flag.Toggled or false
				elseif mode == "Hold" then
					local key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
					
					if not key_code then
						local keybind_str = Stranded.target_strafe.keybind or "E"
						local success, result = pcall(function()
							return Enum.KeyCode[keybind_str]
						end)
						if success and result then
							key_code = result
						else
							key_code = Enum.KeyCode.E
						end
					end
					
					if key_code then
						should_strafe = self.vars.uis:IsKeyDown(key_code)
					end
				end
			else
				local keybind_str = Stranded.target_strafe.keybind or "E"
				local success, result = pcall(function()
					return Enum.KeyCode[keybind_str]
				end)
				if success and result then
					should_strafe = self.vars.uis:IsKeyDown(result)
				end
			end
			
			if not should_strafe then
				if self.target_strafe_cache then
					self.target_strafe_cache.sticky_target_part = nil
					self.target_strafe_cache.sticky_target_player = nil
				end
				return
			end
			
			if not self.target_strafe_cache then
				self.target_strafe_cache = {
					rotation_angle = 0,
					last_update = tick(),
					sticky_target_part = nil,
					sticky_target_player = nil
				}
			end
			
			local target_part = nil
			local target_player = nil
			
			if self.target_strafe_cache.sticky_target_part and self.target_strafe_cache.sticky_target_part.Parent then
				target_part = self.target_strafe_cache.sticky_target_part
				target_player = self.target_strafe_cache.sticky_target_player
				
				if target_player and target_player.Character ~= target_part.Parent then
					target_part = nil
					target_player = nil
					self.target_strafe_cache.sticky_target_part = nil
					self.target_strafe_cache.sticky_target_player = nil
				elseif target_part then
					local humanoid = target_part.Parent:FindFirstChildOfClass("Humanoid")
					if not humanoid or humanoid.Health <= 0 then
						target_part = nil
						target_player = nil
						self.target_strafe_cache.sticky_target_part = nil
						self.target_strafe_cache.sticky_target_player = nil
					end
				end
			end
			
			if not target_part then
				if Script and Script.Targeting and Script.Targeting.Target then
					target_player = Script.Targeting.Target
					if target_player and target_player.Character then
						target_part = target_player.Character:FindFirstChild("HumanoidRootPart") or target_player.Character:FindFirstChild("Head")
					end
				elseif self.target_aim_cache and self.target_aim_cache.sticky_target_part then
					target_part = self.target_aim_cache.sticky_target_part
					if target_part and target_part.Parent then
						for _, player in ipairs(self.vars.players:GetPlayers()) do
							if player.Character == target_part.Parent then
								target_player = player
								break
							end
						end
					end
				end
				
				if not target_part then
					local closest_player = nil
					local closest_distance = math.huge
					local camera = self.vars.camera or workspace.CurrentCamera
					local mouse = self.vars.local_player:GetMouse()
					
					for _, player in ipairs(self.vars.players:GetPlayers()) do
						if player ~= self.vars.local_player and player.Character then
							local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
							if humanoid and humanoid.Health > 0 then
								local root = player.Character:FindFirstChild("HumanoidRootPart")
								if root then
									local screen_pos, on_screen = camera:WorldToViewportPoint(root.Position)
									if on_screen then
										local dist = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screen_pos.X, screen_pos.Y)).Magnitude
										if dist < closest_distance then
											closest_distance = dist
											closest_player = player
										end
									end
								end
							end
						end
					end
					
					if closest_player and closest_player.Character then
						target_player = closest_player
						target_part = closest_player.Character:FindFirstChild("HumanoidRootPart") or closest_player.Character:FindFirstChild("Head")
					end
				end
			end
			
			if not target_part or not target_part.Parent then
				if self.target_strafe_cache then
					self.target_strafe_cache.sticky_target_part = nil
					self.target_strafe_cache.sticky_target_player = nil
				end
				return
			end
			
			if target_player and not self.funcs.check_player(target_player, target_part) then
				if self.target_strafe_cache then
					self.target_strafe_cache.sticky_target_part = nil
					self.target_strafe_cache.sticky_target_player = nil
				end
				return
			end
			
			if target_part and target_player then
				self.target_strafe_cache.sticky_target_part = target_part
				self.target_strafe_cache.sticky_target_player = target_player
			end
			
			local current_time = tick()
			local last_update = self.target_strafe_cache.last_update or current_time
			local delta_time = math.max(current_time - last_update, 0.001)
			self.target_strafe_cache.last_update = current_time
			
			local strafe_type = Stranded.target_strafe.type or "Custom"
			local pattern = Stranded.target_strafe.pattern or "Normal"
			
			local strafe_speed = Stranded.target_strafe.speed or 10
			local strafe_height = Stranded.target_strafe.height or 10
			local strafe_radius = Stranded.target_strafe.distance or 10
			
			if strafe_type == "Random" then
				local max_speed = Stranded.target_strafe.speed or 10
				local max_height = Stranded.target_strafe.height or 10
				local max_distance = Stranded.target_strafe.distance or 10
				
				strafe_speed = math.random(1, max_speed)
				strafe_height = math.random(1, max_height)
				strafe_radius = math.random(1, max_distance)
			end
			
			local target_position = target_part.Position
			local horizontal_offset_x = 0
			local horizontal_offset_z = 0
			local vertical_offset_y = strafe_height
			
			if pattern == "Normal" then
				self.target_strafe_cache.rotation_angle = (self.target_strafe_cache.rotation_angle + (delta_time * strafe_speed * 0.5)) % (math.pi * 2)
				local rotation_time = self.target_strafe_cache.rotation_angle
				horizontal_offset_x = math.cos(rotation_time) * strafe_radius
				horizontal_offset_z = math.sin(rotation_time) * strafe_radius
				vertical_offset_y = strafe_height
			elseif pattern == "Trigonometric" then
				local time = tick() * strafe_speed
				horizontal_offset_x = math.cos(time) * strafe_radius
				horizontal_offset_z = math.sin(time) * strafe_radius
				vertical_offset_y = math.sin(time) * strafe_height
			elseif pattern == "Elliptical" then
				self.target_strafe_cache.rotation_angle = (self.target_strafe_cache.rotation_angle + (delta_time * strafe_speed * 0.5)) % (math.pi * 2)
				local rotation_time = self.target_strafe_cache.rotation_angle
				local ellipse_x_radius = strafe_radius
				local ellipse_z_radius = strafe_radius * 0.6
				horizontal_offset_x = math.cos(rotation_time) * ellipse_x_radius
				horizontal_offset_z = math.sin(rotation_time) * ellipse_z_radius
				vertical_offset_y = math.sin(rotation_time * 1.5) * strafe_height * 0.4 + strafe_height
			elseif pattern == "Figure-8" then
				self.target_strafe_cache.rotation_angle = (self.target_strafe_cache.rotation_angle + (delta_time * strafe_speed * 0.5)) % (math.pi * 2)
				local rotation_time = self.target_strafe_cache.rotation_angle
				horizontal_offset_x = math.sin(rotation_time) * strafe_radius
				horizontal_offset_z = math.sin(rotation_time * 2) * strafe_radius * 0.5
				vertical_offset_y = math.cos(rotation_time) * strafe_height * 0.3 + strafe_height
			end
			
			local orbit_position = target_position + Vector3.new(horizontal_offset_x, vertical_offset_y, horizontal_offset_z)
			local orbit_cframe = CFrame.new(orbit_position)
			
			local_root.CFrame = orbit_cframe
			local_root.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		end,
		cframe_movement_update = function()
			if not Stranded.cframe then
				return
			end
			
			if not Stranded.cframe.enabled then
				if self.cframe_movement_cache and self.cframe_movement_cache.original_walkspeed then
					local local_player = self.vars.local_player
					if local_player and local_player.Character then
						local humanoid = local_player.Character:FindFirstChildOfClass("Humanoid")
						if humanoid then
							humanoid.WalkSpeed = self.cframe_movement_cache.original_walkspeed
							self.cframe_movement_cache.original_walkspeed = nil
						end
					end
				end
				
				local local_player = self.vars.local_player
				if local_player and local_player.Character then
					for _, part in ipairs(local_player.Character:GetDescendants()) do
						if part:IsA("BasePart") and not part.CanCollide then
							if part.Parent == local_player.Character or part.Parent:IsA("Model") and part.Parent.Parent == local_player.Character then
								part.CanCollide = true
							end
						end
					end
				end
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				return
			end
			
			local local_char = self.vars.local_player.Character
			local local_root = local_char:FindFirstChild("HumanoidRootPart")
			
			if not local_root then
				return
			end
			
			local hotkey_flag = nil
			if Library and Library.Flags then
				hotkey_flag = Library.Flags["CFrame Hotkey"]
			end
			local should_move = false
			
			if hotkey_flag then
				local mode = hotkey_flag.Mode or "Hold"
				if mode == "Always" then
					should_move = true
				elseif mode == "Toggle" then
					should_move = hotkey_flag.Toggled or false
				elseif mode == "Hold" then
					local key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
					
					if not key_code then
						local keybind_str = Stranded.cframe.keybinds or "Q"
						local success, result = pcall(function()
							return Enum.KeyCode[keybind_str]
						end)
						if success and result then
							key_code = result
						else
							key_code = Enum.KeyCode.Q
						end
					end
					
					if key_code then
						should_move = self.vars.uis:IsKeyDown(key_code)
					end
				end
			else
				local keybind_str = Stranded.cframe.keybinds or "Q"
				local success, result = pcall(function()
					return Enum.KeyCode[keybind_str]
				end)
				if success and result then
					should_move = self.vars.uis:IsKeyDown(result)
				end
			end
			
			if not should_move then
				return
			end
			
			local movement_type = Stranded.cframe.type or "Movedirection"
			local speed = Stranded.cframe.speed or 100
			
			if movement_type == "WalkSpeed" then
				local humanoid = local_char:FindFirstChildOfClass("Humanoid")
				if humanoid then
					if not self.cframe_movement_cache then
						self.cframe_movement_cache = {
							last_update = tick(),
							original_walkspeed = humanoid.WalkSpeed
						}
					elseif not self.cframe_movement_cache.original_walkspeed then
						self.cframe_movement_cache.original_walkspeed = humanoid.WalkSpeed
					end
					humanoid.WalkSpeed = speed
				end
			elseif movement_type == "Movedirection" then
				local uis = self.vars.uis
				local w_pressed = uis:IsKeyDown(Enum.KeyCode.W)
				local a_pressed = uis:IsKeyDown(Enum.KeyCode.A)
				local s_pressed = uis:IsKeyDown(Enum.KeyCode.S)
				local d_pressed = uis:IsKeyDown(Enum.KeyCode.D)
				
				if not w_pressed and not a_pressed and not s_pressed and not d_pressed then
					return
				end
				local camera = self.vars.camera or workspace.CurrentCamera
				if not camera then
					return
				end
				
				local camera_cframe = camera.CFrame
				local look_direction = camera_cframe.LookVector
				local right_direction = camera_cframe.RightVector
				
				local horizontal_look = Vector3.new(look_direction.X, 0, look_direction.Z)
				local horizontal_look_magnitude = horizontal_look.Magnitude
				if horizontal_look_magnitude > 0 then
					horizontal_look = horizontal_look / horizontal_look_magnitude
				else
					horizontal_look = Vector3.new(0, 0, -1)
				end
				
				local horizontal_right = Vector3.new(right_direction.X, 0, right_direction.Z)
				local horizontal_right_magnitude = horizontal_right.Magnitude
				if horizontal_right_magnitude > 0 then
					horizontal_right = horizontal_right / horizontal_right_magnitude
				else
					horizontal_right = Vector3.new(1, 0, 0)
				end
				
				if not self.cframe_movement_cache then
					self.cframe_movement_cache = {
						last_update = tick()
					}
				end
				
				local current_time = tick()
				local delta_time = current_time - self.cframe_movement_cache.last_update
				self.cframe_movement_cache.last_update = current_time
				
				if delta_time > 0.1 then
					delta_time = 0.016
				end
				
				local move_distance = speed * delta_time
				local move_vector = Vector3.new(0, 0, 0)
				
				if w_pressed then
					move_vector = move_vector + (horizontal_look * move_distance)
				end
				if s_pressed then
					move_vector = move_vector - (horizontal_look * move_distance)
				end
				if a_pressed then
					move_vector = move_vector - (horizontal_right * move_distance)
				end
				if d_pressed then
					move_vector = move_vector + (horizontal_right * move_distance)
				end
				
				local new_position = local_root.Position + move_vector
				local current_cframe = local_root.CFrame
				local new_cframe = CFrame.new(new_position) * (current_cframe - current_cframe.Position)
				
				local_root.CFrame = new_cframe
			elseif movement_type == "Noclip" then
				local uis = self.vars.uis
				local w_pressed = uis:IsKeyDown(Enum.KeyCode.W)
				local a_pressed = uis:IsKeyDown(Enum.KeyCode.A)
				local s_pressed = uis:IsKeyDown(Enum.KeyCode.S)
				local d_pressed = uis:IsKeyDown(Enum.KeyCode.D)
				
				for _, part in ipairs(local_char:GetDescendants()) do
					if part:IsA("BasePart") and part.CanCollide then
						part.CanCollide = false
					end
				end
				
				if not w_pressed and not a_pressed and not s_pressed and not d_pressed then
					return
				end
				
				local camera = self.vars.camera or workspace.CurrentCamera
				if not camera then
					return
				end
				
				local camera_cframe = camera.CFrame
				local look_direction = camera_cframe.LookVector
				local right_direction = camera_cframe.RightVector
				
				local horizontal_look = Vector3.new(look_direction.X, 0, look_direction.Z)
				local horizontal_look_magnitude = horizontal_look.Magnitude
				if horizontal_look_magnitude > 0 then
					horizontal_look = horizontal_look / horizontal_look_magnitude
				else
					horizontal_look = Vector3.new(0, 0, -1)
				end
				
				local horizontal_right = Vector3.new(right_direction.X, 0, right_direction.Z)
				local horizontal_right_magnitude = horizontal_right.Magnitude
				if horizontal_right_magnitude > 0 then
					horizontal_right = horizontal_right / horizontal_right_magnitude
				else
					horizontal_right = Vector3.new(1, 0, 0)
				end
				
				if not self.cframe_movement_cache then
					self.cframe_movement_cache = {
						last_update = tick()
					}
				end
				
				local current_time = tick()
				local delta_time = current_time - self.cframe_movement_cache.last_update
				self.cframe_movement_cache.last_update = current_time
				
				if delta_time > 0.1 then
					delta_time = 0.016
				end
				
				local move_distance = speed * delta_time
				local move_vector = Vector3.new(0, 0, 0)
				
				if w_pressed then
					move_vector = move_vector + (horizontal_look * move_distance)
				end
				if s_pressed then
					move_vector = move_vector - (horizontal_look * move_distance)
				end
				if a_pressed then
					move_vector = move_vector - (horizontal_right * move_distance)
				end
				if d_pressed then
					move_vector = move_vector + (horizontal_right * move_distance)
				end
				
				local new_position = local_root.Position + move_vector
				local current_cframe = local_root.CFrame
				local new_cframe = CFrame.new(new_position) * (current_cframe - current_cframe.Position)
				
				local_root.CFrame = new_cframe
			end
		end,
		fly_movement_update = function()
			if not Stranded.fly then
				return
			end
			
			if not Stranded.fly.enabled then
				local local_player = self.vars.local_player
				if local_player and local_player.Character then
					for _, part in ipairs(local_player.Character:GetDescendants()) do
						if part:IsA("BasePart") and not part.CanCollide then
							if part.Parent == local_player.Character or part.Parent:IsA("Model") and part.Parent.Parent == local_player.Character then
								part.CanCollide = true
							end
						end
					end
				end
				if self.fly_movement_cache then
					self.fly_movement_cache.last_velocity = nil
				end
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				return
			end
			
			local local_char = self.vars.local_player.Character
			local local_root = local_char:FindFirstChild("HumanoidRootPart")
			
			if not local_root then
				return
			end
			
			local hotkey_flag = nil
			if Library and Library.Flags then
				hotkey_flag = Library.Flags["Fly Hotkey"]
			end
			local should_fly = false
			
			if hotkey_flag then
				local mode = hotkey_flag.Mode or "Hold"
				if mode == "Always" then
					should_fly = true
				elseif mode == "Toggle" then
					should_fly = hotkey_flag.Toggled or false
				elseif mode == "Hold" then
					local key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
					
					if not key_code then
						local keybind_str = Stranded.fly.keybinds or "F"
						local success, result = pcall(function()
							return Enum.KeyCode[keybind_str]
						end)
						if success and result then
							key_code = result
						else
							key_code = Enum.KeyCode.F
						end
					end
					
					if key_code then
						should_fly = self.vars.uis:IsKeyDown(key_code)
					end
				end
			else
				local keybind_str = Stranded.fly.keybinds or "F"
				local success, result = pcall(function()
					return Enum.KeyCode[keybind_str]
				end)
				if success and result then
					should_fly = self.vars.uis:IsKeyDown(result)
				end
			end
			
			if not should_fly then
				-- Don't interfere with normal movement when fly keybind is not held
				return
			end
			
			local fly_type = Stranded.fly.type or "Movedirection"
			local speed = Stranded.fly.speed or 50
			
			if fly_type == "Movedirection" then
				local uis = self.vars.uis
				local w_pressed = uis:IsKeyDown(Enum.KeyCode.W)
				local a_pressed = uis:IsKeyDown(Enum.KeyCode.A)
				local s_pressed = uis:IsKeyDown(Enum.KeyCode.S)
				local d_pressed = uis:IsKeyDown(Enum.KeyCode.D)
				local space_pressed = uis:IsKeyDown(Enum.KeyCode.Space)
				local shift_pressed = uis:IsKeyDown(Enum.KeyCode.LeftShift)
				
				local move_vector = Vector3.new(0, 0, 0)
				
				-- Counteract gravity to keep player floating when no keys pressed
				local current_velocity = local_root.AssemblyLinearVelocity
				if not w_pressed and not a_pressed and not s_pressed and not d_pressed and not space_pressed and not shift_pressed then
					-- Only counteract vertical velocity (gravity), keep horizontal momentum
					move_vector = Vector3.new(current_velocity.X, 0, current_velocity.Z)
					local_root.AssemblyLinearVelocity = move_vector
					return
				end
				
				local camera = self.vars.camera or workspace.CurrentCamera
				if not camera then
					return
				end
				
				local camera_cframe = camera.CFrame
				local look_direction = camera_cframe.LookVector
				local right_direction = camera_cframe.RightVector
				local up_direction = camera_cframe.UpVector
				
				-- Reset move_vector for movement keys
				move_vector = Vector3.new(0, 0, 0)
				
				-- Use full 3D direction for W/S (includes vertical component based on where you look)
				if w_pressed then
					move_vector = move_vector + (look_direction * speed)
				end
				if s_pressed then
					move_vector = move_vector - (look_direction * speed)
				end
				
				-- Use horizontal right for A/D (strafe left/right)
				local horizontal_right = Vector3.new(right_direction.X, 0, right_direction.Z)
				local horizontal_right_magnitude = horizontal_right.Magnitude
				if horizontal_right_magnitude > 0 then
					horizontal_right = horizontal_right / horizontal_right_magnitude
				else
					horizontal_right = Vector3.new(1, 0, 0)
				end
				
				if a_pressed then
					move_vector = move_vector - (horizontal_right * speed)
				end
				if d_pressed then
					move_vector = move_vector + (horizontal_right * speed)
				end
				
				-- Space/Shift for additional vertical control
				if space_pressed then
					move_vector = move_vector + (Vector3.new(0, 1, 0) * speed)
				end
				if shift_pressed then
					move_vector = move_vector - (Vector3.new(0, 1, 0) * speed)
				end
				
				local_root.AssemblyLinearVelocity = move_vector
			elseif fly_type == "Noclip" then
				local uis = self.vars.uis
				local w_pressed = uis:IsKeyDown(Enum.KeyCode.W)
				local a_pressed = uis:IsKeyDown(Enum.KeyCode.A)
				local s_pressed = uis:IsKeyDown(Enum.KeyCode.S)
				local d_pressed = uis:IsKeyDown(Enum.KeyCode.D)
				local space_pressed = uis:IsKeyDown(Enum.KeyCode.Space)
				local shift_pressed = uis:IsKeyDown(Enum.KeyCode.LeftShift)
				
				for _, part in ipairs(local_char:GetDescendants()) do
					if part:IsA("BasePart") and part.CanCollide then
						part.CanCollide = false
					end
				end
				
				if not w_pressed and not a_pressed and not s_pressed and not d_pressed and not space_pressed and not shift_pressed then
					-- Don't interfere with normal movement when no keys pressed
					return
				end
				
				local camera = self.vars.camera or workspace.CurrentCamera
				if not camera then
					return
				end
				
				local camera_cframe = camera.CFrame
				local look_direction = camera_cframe.LookVector
				local right_direction = camera_cframe.RightVector
				
				local horizontal_look = Vector3.new(look_direction.X, 0, look_direction.Z)
				local horizontal_look_magnitude = horizontal_look.Magnitude
				if horizontal_look_magnitude > 0 then
					horizontal_look = horizontal_look / horizontal_look_magnitude
				else
					horizontal_look = Vector3.new(0, 0, -1)
				end
				
				local horizontal_right = Vector3.new(right_direction.X, 0, right_direction.Z)
				local horizontal_right_magnitude = horizontal_right.Magnitude
				if horizontal_right_magnitude > 0 then
					horizontal_right = horizontal_right / horizontal_right_magnitude
				else
					horizontal_right = Vector3.new(1, 0, 0)
				end
				
				if not self.fly_movement_cache then
					self.fly_movement_cache = {
						last_update = tick()
					}
				end
				
				local current_time = tick()
				local delta_time = current_time - self.fly_movement_cache.last_update
				self.fly_movement_cache.last_update = current_time
				
				if delta_time > 0.1 then
					delta_time = 0.016
				end
				
				local move_distance = speed * delta_time
				local move_vector = Vector3.new(0, 0, 0)
				
				if w_pressed then
					move_vector = move_vector + (horizontal_look * move_distance)
				end
				if s_pressed then
					move_vector = move_vector - (horizontal_look * move_distance)
				end
				if a_pressed then
					move_vector = move_vector - (horizontal_right * move_distance)
				end
				if d_pressed then
					move_vector = move_vector + (horizontal_right * move_distance)
				end
				if space_pressed then
					move_vector = move_vector + (Vector3.new(0, 1, 0) * move_distance)
				end
				if shift_pressed then
					move_vector = move_vector - (Vector3.new(0, 1, 0) * move_distance)
				end
				
				local new_position = local_root.Position + move_vector
				local current_cframe = local_root.CFrame
				local new_cframe = CFrame.new(new_position) * (current_cframe - current_cframe.Position)
				
				local_root.CFrame = new_cframe
			elseif fly_type == "Velocity" then
				local uis = self.vars.uis
				local w_pressed = uis:IsKeyDown(Enum.KeyCode.W)
				local a_pressed = uis:IsKeyDown(Enum.KeyCode.A)
				local s_pressed = uis:IsKeyDown(Enum.KeyCode.S)
				local d_pressed = uis:IsKeyDown(Enum.KeyCode.D)
				local space_pressed = uis:IsKeyDown(Enum.KeyCode.Space)
				local shift_pressed = uis:IsKeyDown(Enum.KeyCode.LeftShift)
				
				local move_vector = Vector3.new(0, 0, 0)
				
				-- Counteract gravity to keep player floating when no keys pressed
				local current_velocity = local_root.AssemblyLinearVelocity
				if not w_pressed and not a_pressed and not s_pressed and not d_pressed and not space_pressed and not shift_pressed then
					-- Only counteract vertical velocity (gravity), keep horizontal momentum
					move_vector = Vector3.new(current_velocity.X, 0, current_velocity.Z)
					local_root.AssemblyLinearVelocity = move_vector
					return
				end
				
				local camera = self.vars.camera or workspace.CurrentCamera
				if not camera then
					return
				end
				
				local camera_cframe = camera.CFrame
				local look_direction = camera_cframe.LookVector
				local right_direction = camera_cframe.RightVector
				local up_direction = camera_cframe.UpVector
				
				-- Reset move_vector for movement keys
				move_vector = Vector3.new(0, 0, 0)
				
				-- Use full 3D direction for W/S (includes vertical component based on where you look)
				if w_pressed then
					move_vector = move_vector + (look_direction * speed)
				end
				if s_pressed then
					move_vector = move_vector - (look_direction * speed)
				end
				
				-- Use horizontal right for A/D (strafe left/right)
				local horizontal_right = Vector3.new(right_direction.X, 0, right_direction.Z)
				local horizontal_right_magnitude = horizontal_right.Magnitude
				if horizontal_right_magnitude > 0 then
					horizontal_right = horizontal_right / horizontal_right_magnitude
				else
					horizontal_right = Vector3.new(1, 0, 0)
				end
				
				if a_pressed then
					move_vector = move_vector - (horizontal_right * speed)
				end
				if d_pressed then
					move_vector = move_vector + (horizontal_right * speed)
				end
				
				-- Space/Shift for additional vertical control
				if space_pressed then
					move_vector = move_vector + (Vector3.new(0, 1, 0) * speed)
				end
				if shift_pressed then
					move_vector = move_vector - (Vector3.new(0, 1, 0) * speed)
				end
				
				local_root.AssemblyLinearVelocity = move_vector
			end
		end,
		hipheight_update = function()
			if not Stranded.hipheight then
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				if self.hipheight_cache then
					self.hipheight_cache.original_hipheight = nil
					self.hipheight_cache.last_character = nil
				end
				return
			end
			
			local local_char = self.vars.local_player.Character
			local humanoid = local_char:FindFirstChildOfClass("Humanoid")
			
			if not humanoid then
				return
			end
			
			-- Reset cache if character changed
			if self.hipheight_cache and self.hipheight_cache.last_character ~= local_char then
				self.hipheight_cache.original_hipheight = nil
				self.hipheight_cache.last_character = local_char
			end
			
			if not Stranded.hipheight.enabled then
				if self.hipheight_cache and self.hipheight_cache.original_hipheight then
					humanoid.HipHeight = self.hipheight_cache.original_hipheight
					self.hipheight_cache.original_hipheight = nil
				end
				return
			end
			
			local hotkey_flag = nil
			if Library and Library.Flags then
				hotkey_flag = Library.Flags["HipHeight Hotkey"]
			end
			
			local should_apply = false
			local key_code = nil
			
			if hotkey_flag then
				local mode = hotkey_flag.Mode or "Hold"
				if mode == "Always" then
					should_apply = true
				elseif mode == "Toggle" then
					if hotkey_flag.Toggled then
						should_apply = true
					end
				elseif mode == "Hold" then
					key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
					if key_code then
						should_apply = self.vars.uis:IsKeyDown(key_code)
					end
				end
			else
				local keybind_str = Stranded.hipheight.keybinds or "H"
				local success, result = pcall(function()
					return Enum.KeyCode[keybind_str]
				end)
				if success and result then
					key_code = result
					should_apply = self.vars.uis:IsKeyDown(key_code)
				else
					should_apply = true
				end
			end
			
			if should_apply then
				if not self.hipheight_cache then
					self.hipheight_cache = {
						original_hipheight = humanoid.HipHeight,
						last_character = local_char,
						last_applied_height = nil
					}
				elseif not self.hipheight_cache.original_hipheight then
					self.hipheight_cache.original_hipheight = humanoid.HipHeight
					self.hipheight_cache.last_character = local_char
					self.hipheight_cache.last_applied_height = nil
				end
				
				local height = Stranded.hipheight.height or 0
				-- Only update if the value changed to prevent bobbing
				if self.hipheight_cache.last_applied_height ~= height then
					humanoid.HipHeight = height
					self.hipheight_cache.last_applied_height = height
				end
			else
				if self.hipheight_cache and self.hipheight_cache.original_hipheight then
					-- Only restore if it's not already the original value
					if math.abs(humanoid.HipHeight - self.hipheight_cache.original_hipheight) > 0.01 then
						humanoid.HipHeight = self.hipheight_cache.original_hipheight
					end
					self.hipheight_cache.last_applied_height = nil
				end
			end
		end,
		jumppower_update = function()
			if not Stranded.jumppower then
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				if self.jumppower_cache then
					self.jumppower_cache.original_jumppower = nil
					self.jumppower_cache.last_character = nil
				end
				return
			end
			
			local local_char = self.vars.local_player.Character
			local humanoid = local_char:FindFirstChildOfClass("Humanoid")
			
			if not humanoid then
				return
			end
			
			-- Reset cache if character changed
			if self.jumppower_cache and self.jumppower_cache.last_character ~= local_char then
				self.jumppower_cache.original_jumppower = nil
				self.jumppower_cache.last_character = local_char
			end
			
			if not Stranded.jumppower.enabled then
				if self.jumppower_cache and self.jumppower_cache.original_jumppower then
					humanoid.JumpPower = self.jumppower_cache.original_jumppower
					self.jumppower_cache.original_jumppower = nil
				end
				return
			end
			
			if not self.jumppower_cache then
				self.jumppower_cache = {
					original_jumppower = humanoid.JumpPower,
					last_character = local_char
				}
			elseif not self.jumppower_cache.original_jumppower then
				self.jumppower_cache.original_jumppower = humanoid.JumpPower
				self.jumppower_cache.last_character = local_char
			end
			
			local power = Stranded.jumppower.power or 50
			humanoid.JumpPower = power
		end,
		gravity_update = function()
			if not Stranded.gravity then
				return
			end
			
			if not Stranded.gravity.enabled then
				if self.gravity_cache and self.gravity_cache.original_gravity then
					local success = pcall(function()
						workspace.Gravity = self.gravity_cache.original_gravity
					end)
					if success then
						self.gravity_cache.original_gravity = nil
					end
				end
				return
			end
			
			local hotkey_flag = nil
			if Library and Library.Flags then
				hotkey_flag = Library.Flags["Gravity Hotkey"]
			end
			local should_apply = false
			
			if hotkey_flag then
				local mode = hotkey_flag.Mode or "Hold"
				if mode == "Always" then
					should_apply = true
				elseif mode == "Toggle" then
					should_apply = hotkey_flag.Toggled or false
				elseif mode == "Hold" then
					local key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
					
					if not key_code then
						local keybind_str = Stranded.gravity.keybinds or "G"
						local success, result = pcall(function()
							return Enum.KeyCode[keybind_str]
						end)
						if success and result then
							key_code = result
						else
							key_code = Enum.KeyCode.G
						end
					end
					
					if key_code then
						should_apply = self.vars.uis:IsKeyDown(key_code)
					end
				end
			else
				local keybind_str = Stranded.gravity.keybinds or "G"
				local success, result = pcall(function()
					return Enum.KeyCode[keybind_str]
				end)
				if success and result then
					should_apply = self.vars.uis:IsKeyDown(result)
				end
			end
			
			if should_apply then
				if not self.gravity_cache then
					self.gravity_cache = {
						original_gravity = workspace.Gravity,
						last_update = tick()
					}
				elseif not self.gravity_cache.original_gravity then
					self.gravity_cache.original_gravity = workspace.Gravity
					self.gravity_cache.last_update = tick()
				end
				
				local gravity_value = Stranded.gravity.gravity or 196.2
				local original_gravity = self.gravity_cache.original_gravity or 196.2
				
				-- Try to set workspace gravity first
				local success = pcall(function()
					workspace.Gravity = gravity_value
				end)
				
				-- If workspace.Gravity is read-only, apply gravity manually to character
				if not success and self.vars.local_player and self.vars.local_player.Character then
					local hrp = self.vars.local_player.Character:FindFirstChild("HumanoidRootPart")
					if hrp then
						local current_time = tick()
						local delta_time = current_time - (self.gravity_cache.last_update or current_time)
						self.gravity_cache.last_update = current_time
						
						if delta_time > 0.1 then
							delta_time = 0.016
						end
						
						local current_velocity = hrp.AssemblyLinearVelocity
						local gravity_diff = (gravity_value - original_gravity) * delta_time
						hrp.AssemblyLinearVelocity = Vector3.new(current_velocity.X, current_velocity.Y + gravity_diff, current_velocity.Z)
					end
				end
			else
				if self.gravity_cache and self.gravity_cache.original_gravity then
					local success = pcall(function()
						workspace.Gravity = self.gravity_cache.original_gravity
					end)
					if success then
						self.gravity_cache.original_gravity = nil
						self.gravity_cache.last_update = nil
					end
				end
			end
		end,
		anti_afk_update = function()
			if not Stranded.automation or not Stranded.automation.anti_afk then
				return
			end
			
			if not Stranded.automation.anti_afk.enabled then
				return
			end
			
			if self.vars.local_player and not self.anti_afk_connected then
				self.anti_afk_connected = true
				self.vars.local_player.Idled:Connect(function()
					if Stranded.automation and Stranded.automation.anti_afk and Stranded.automation.anti_afk.enabled then
						for i = 1, 10 do
							game:GetService("VirtualUser"):Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
							task.wait(0.2)
							game:GetService("VirtualUser"):Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
							task.wait(0.2)
						end
					end
				end)
			end
		end,
		anti_stomp_update = function()
			if not Stranded.automation or not Stranded.automation.anti_stomp then
				return
			end
			
			if not Stranded.automation.anti_stomp.enabled then
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				return
			end
			
			local character = self.vars.local_player.Character
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			
			if not humanoid then
				return
			end
			
			if not self.anti_stomp_cache then
				self.anti_stomp_cache = {
					humanoid = nil
				}
			end
			
			if self.anti_stomp_cache.humanoid ~= humanoid then
				self.anti_stomp_connected = false
				self.anti_stomp_cache.humanoid = humanoid
			end
			
			if not self.anti_stomp_connected then
				self.anti_stomp_connected = true
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
				humanoid.Seated:Connect(function()
					if Stranded.automation and Stranded.automation.anti_stomp and Stranded.automation.anti_stomp.enabled then
						humanoid.Sit = false
						humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
						task.wait(0.3)
						humanoid.Jump = true
					end
				end)
			end
			
			if humanoid.Seated then
				humanoid.Sit = false
				humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
				humanoid.Jump = true
			end
		end,
		autofarm_update = function()
			if not Stranded.automation or not Stranded.automation.autofarm then
				return
			end
			
			if not Stranded.automation.autofarm.enabled then
				if self.autofarm_cache then
					if self.autofarm_cache.rendering_disabled then
						game:GetService("RunService"):Set3dRenderingEnabled(true)
						self.autofarm_cache.rendering_disabled = false
					end
					self.autofarm_cache.farming = false
				end
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				return
			end
			
			if Stranded.automation.autofarm.saver then
				if not self.autofarm_cache then
					self.autofarm_cache = {}
				end
				if not self.autofarm_cache.rendering_disabled then
					game:GetService("RunService"):Set3dRenderingEnabled(false)
					self.autofarm_cache.rendering_disabled = true
				end
			else
				if self.autofarm_cache and self.autofarm_cache.rendering_disabled then
					game:GetService("RunService"):Set3dRenderingEnabled(true)
					self.autofarm_cache.rendering_disabled = false
				end
			end
			
			if self.vars.local_player then
				self.vars.local_player.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
				self.vars.local_player.CameraMaxZoomDistance = 6
				self.vars.local_player.CameraMinZoomDistance = 6
			end
			
			pcall(function() 
				UserSettings().GameSettings.MasterVolume = 0 
			end)
			pcall(function() 
				settings().Rendering.QualityLevel = "Level01" 
			end)
			
			if not self.autofarm_cache then
				self.autofarm_cache = {}
			end
			
			if not self.autofarm_cache.farming then
				self.autofarm_cache.farming = true
				
				task.spawn(function()
					local cashiers = workspace:FindFirstChild("Cashiers")
					local drop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Drop")
					
					if not cashiers or not drop then
						self.autofarm_cache.farming = false
						return
					end
					
					local get_cashier = function()
						for i, v in pairs(cashiers:GetChildren()) do
							if v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 then
								if i == 15 and (Vector3.new(-625, 10, -286) - v.Head.Position).Magnitude <= 20 then
									v:MoveTo(Vector3.new(-622.948, 24, -286.52))
									for x, z in pairs(v:GetChildren()) do
										if (z:IsA("Part")) or (z:IsA("BasePart")) then
											z.CanCollide = false
										end
									end
								elseif i == 16 and (Vector3.new(-625, 10, -286) - v.Head.Position).Magnitude <= 20 then
									v:MoveTo(Vector3.new(-629.948, 24, -286.52))
									for x, z in pairs(v:GetChildren()) do
										if (z:IsA("Part")) or (z:IsA("BasePart")) then
											z.CanCollide = false
										end
									end
								end
								return v
							end
						end
						return nil
					end
					
					local click = function(part)
						if not part or not part:FindFirstChild("ClickDetector") then
							return
						end
						
						local input = game:GetService("VirtualInputManager")
						local t = os.time()
						
						if part:GetAttribute("OriginalPos") == nil then
							part:SetAttribute("OriginalPos", part.Position)
						end
						
						repeat
							part.CFrame = (workspace.Camera.CFrame + workspace.Camera.CFrame.LookVector * 1) * CFrame.Angles(math.rad(90), 0, 0)
							input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, true, game, 1)
							task.wait()
							input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, false, game, 1)
						until (part == nil) or (part:FindFirstChild("ClickDetector") == nil) or (os.time() - t >= 2)
					end
					
					local get_cash = function()
						local found = {}
						local local_player = self.vars.local_player
						if not local_player or not local_player.Character or not local_player.Character:FindFirstChild("HumanoidRootPart") then
							return found
						end
						
						for i, v in pairs(drop:GetChildren()) do
							if v.Name == "MoneyDrop" then
								local pos = nil
								if v:GetAttribute("OriginalPos") ~= nil then
									pos = v:GetAttribute("OriginalPos")
								else
									pos = v.Position
								end
								if (pos - local_player.Character.HumanoidRootPart.Position).Magnitude <= 17 then
									found[#found + 1] = v
								end
							end
						end
						return found
					end
					
					local to = function(cf)
						local local_player = self.vars.local_player
						if local_player and local_player.Character and local_player.Character:FindFirstChild("HumanoidRootPart") then
							local_player.Character.HumanoidRootPart.CFrame = cf
							local_player.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
						end
					end
					
					while Stranded.automation and Stranded.automation.autofarm and Stranded.automation.autofarm.enabled and task.wait() do
						local local_player = self.vars.local_player
						if not local_player or not local_player.Character or local_player.Character:FindFirstChild("FULLY_LOADED_CHAR") == nil then
							task.wait(1)
						else
							local cashier = nil
							repeat
								cashier = get_cashier()
								
								if local_player.Backpack:FindFirstChild("Combat") ~= nil then
									local_player.Backpack.Combat.Parent = local_player.Character
								end
								
								task.wait()
							until (cashier ~= nil) or not (Stranded.automation and Stranded.automation.autofarm and Stranded.automation.autofarm.enabled)
							
							if not (Stranded.automation and Stranded.automation.autofarm and Stranded.automation.autofarm.enabled) then
								break
							end
							
							if cashier then
								repeat
									to((cashier.Head.CFrame + Vector3.new(0, -2.5, 0)) * CFrame.Angles(math.rad(90), 0, 0))
									task.wait()
									if local_player.Character:FindFirstChild("Combat") then
										local_player.Character.Combat:Activate()
									end
								until (cashier.Humanoid.Health <= 0) or not (Stranded.automation and Stranded.automation.autofarm and Stranded.automation.autofarm.enabled)
								
								if not (Stranded.automation and Stranded.automation.autofarm and Stranded.automation.autofarm.enabled) then
									break
								end
								
								to(cashier.Head.CFrame + cashier.Head.CFrame.LookVector * Vector3.new(0, 2, 0))
								
								for i, v in pairs(local_player.Character:GetChildren()) do
									if v:IsA("Tool") then
										v.Parent = local_player.Backpack
									end
								end
								
								local cash = get_cash()
								for i, v in pairs(cash) do
									click(v)
								end
							end
						end
					end
					
					self.autofarm_cache.farming = false
				end)
			end
		end,
		auto_collect_update = function()
			if not Stranded.automation or not Stranded.automation.auto_collect then
				return
			end
			
			if not Stranded.automation.auto_collect.enabled then
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				return
			end
			
			local character = self.vars.local_player.Character
			local hrp = character:FindFirstChild("HumanoidRootPart")
			
			if not hrp then
				return
			end
			
			local drop = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Drop")
			if not drop then
				return
			end
			
			if not self.auto_collect_cache then
				self.auto_collect_cache = {
					last_click_time = {},
					click_cooldown = 0.2
				}
			end
			
			local range = Stranded.automation.auto_collect.range or 17
			local input = game:GetService("VirtualInputManager")
			local current_time = tick()
			
			for i, v in pairs(drop:GetChildren()) do
				if v.Name == "MoneyDrop" and v:FindFirstChild("ClickDetector") then
					local distance = (v.Position - hrp.Position).Magnitude
					if distance <= range then
						local last_click = self.auto_collect_cache.last_click_time[v] or 0
						if current_time - last_click >= self.auto_collect_cache.click_cooldown then
							v.CFrame = (workspace.Camera.CFrame + workspace.Camera.CFrame.LookVector * 1) * CFrame.Angles(math.rad(90), 0, 0)
							input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, true, game, 1)
							task.spawn(function()
								task.wait(0.1)
								input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, false, game, 1)
							end)
							self.auto_collect_cache.last_click_time[v] = current_time
						end
					end
				end
			end
		end,
		autobuy_update = function()
			if not Stranded.automation or not Stranded.automation.autobuy then
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character or not self.vars.local_player.Character:FindFirstChild("HumanoidRootPart") then
				return
			end
			
			local ws = workspace
			if not ws:FindFirstChild("Ignored") or not ws.Ignored:FindFirstChild("Shop") then
				return
			end
			
			local shop_table = {
				["[Rifle]"] = {shop_name = "[Rifle] - $1694"},
				["[Rifle Ammo]"] = {shop_name = "5 [Rifle Ammo] - $273"},
				["[LMG]"] = {shop_name = "[LMG] - $4098"},
				["[LMG Ammo]"] = {shop_name = "200 [LMG Ammo] - $328"},
				["[AK47]"] = {shop_name = "[AK47] - $2459"},
				["[AK47 Ammo]"] = {shop_name = "90 [AK47 Ammo] - $87"},
				["[AUG]"] = {shop_name = "[AUG] - $2131"},
				["[AUG Ammo]"] = {shop_name = "90 [AUG Ammo] - $87"},
				["[AR]"] = {shop_name = "[AR] - $1093"},
				["[AR Ammo]"] = {shop_name = "60 [AR Ammo] - $82"},
				["[Double-Barrel SG]"] = {shop_name = "[Double-Barrel SG] - $1475"},
				["[Double-Barrel SG Ammo]"] = {shop_name = "18 [Double-Barrel SG Ammo] - $55"},
				["[Drum-Shotgun]"] = {shop_name = "[Drum-Shotgun] - $1202"},
				["[Drum-Shotgun Ammo]"] = {shop_name = "18 [Drum-Shotgun Ammo] - $71"},
				["[DrumGun]"] = {shop_name = "[DrumGun] - $3278"},
				["[DrumGun Ammo]"] = {shop_name = "100 [DrumGun Ammo] - $219"},
				["[Fire Armor]"] = {shop_name = "[Fire Armor] - $2623"},
				["[Glock]"] = {shop_name = "[Glock] - $546"},
				["[Glock Ammo]"] = {shop_name = "25 [Glock Ammo] - $66"},
				["[P90]"] = {shop_name = "[P90] - $1093"},
				["[P90 Ammo]"] = {shop_name = "120 [P90 Ammo] - $66"},
				["[RPG]"] = {shop_name = "[RPG] - $21855"},
				["[RPG Ammo]"] = {shop_name = "5 [RPG Ammo] - $1093"},
				["[Revolver]"] = {shop_name = "[Revolver] - $1421"},
				["[Revolver Ammo]"] = {shop_name = "12 [Revolver Ammo] - $82"},
				["[Silencer]"] = {shop_name = "[Silencer] - $601"},
				["[Silencer Ammo]"] = {shop_name = "25 [Silencer Ammo] - $55"},
				["[SilencerAR]"] = {shop_name = "[SilencerAR] - $1366"},
				["[SilencerAR Ammo]"] = {shop_name = "120 [SilencerAR Ammo] - $82"},
				["[Shotgun]"] = {shop_name = "[Shotgun] - $1366"},
				["[Shotgun Ammo]"] = {shop_name = "20 [Shotgun Ammo] - $66"},
				["[SMG]"] = {shop_name = "[SMG] - $820"},
				["[SMG Ammo]"] = {shop_name = "80 [SMG Ammo] - $66"},
				["[TacticalShotgun]"] = {shop_name = "[TacticalShotgun] - $1912"},
				["[TacticalShotgun Ammo]"] = {shop_name = "20 [TacticalShotgun Ammo] - $66"},
				["[Taser]"] = {shop_name = "[Taser] - $1093"},
				["[Grenade]"] = {shop_name = "[Grenade] - $765"}
			}
			
			local local_player = self.vars.local_player
			local saved_position = nil
			
			if Stranded.automation.autobuy.buying_single then
				if Stranded.automation.autobuy.selected_gun and shop_table[Stranded.automation.autobuy.selected_gun] then
					if not local_player.Character:FindFirstChild(Stranded.automation.autobuy.selected_gun) and not local_player.Backpack:FindFirstChild(Stranded.automation.autobuy.selected_gun) then
						local shop_item = ws.Ignored.Shop:FindFirstChild(shop_table[Stranded.automation.autobuy.selected_gun].shop_name)
						if shop_item and shop_item:FindFirstChild("Head") then
							saved_position = local_player.Character.HumanoidRootPart.CFrame
							local_player.Character.HumanoidRootPart.CFrame = shop_item.Head.CFrame
							local click_detector = shop_item:FindFirstChildOfClass("ClickDetector")
							if click_detector then
								if fireclickdetector then
									fireclickdetector(click_detector)
								else
									local input = game:GetService("VirtualInputManager")
									shop_item.CFrame = (workspace.Camera.CFrame + workspace.Camera.CFrame.LookVector * 1) * CFrame.Angles(math.rad(90), 0, 0)
									input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, true, game, 1)
									task.wait(0.1)
									input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, false, game, 1)
								end
							end
							game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
								if local_player.Character and local_player.Character:FindFirstChild("HumanoidRootPart") and saved_position then
									local_player.Character.HumanoidRootPart.CFrame = saved_position
								end
								game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
							end)
						end
					else
						Stranded.automation.autobuy.buying_single = false
					end
				else
					Stranded.automation.autobuy.buying_single = false
				end
			end
			
			if Stranded.automation.autobuy.buy_ammo and Stranded.automation.autobuy.selected_gun then
				local ammo_name = "[" .. Stranded.automation.autobuy.selected_gun:sub(2, -2) .. " Ammo]"
				if shop_table[ammo_name] then
					local ammo_shop = ws.Ignored.Shop:FindFirstChild(shop_table[ammo_name].shop_name)
					if ammo_shop and ammo_shop:FindFirstChild("Head") then
						if local_player.Character:FindFirstChild(Stranded.automation.autobuy.selected_gun) then
							local_player.Character:FindFirstChild(Stranded.automation.autobuy.selected_gun).Parent = local_player.Backpack
						end
						saved_position = local_player.Character.HumanoidRootPart.CFrame
						local_player.Character.HumanoidRootPart.CFrame = ammo_shop.Head.CFrame
						local click_detector = ammo_shop:FindFirstChildOfClass("ClickDetector")
						if click_detector then
							if fireclickdetector then
								fireclickdetector(click_detector)
							else
								local input = game:GetService("VirtualInputManager")
								ammo_shop.CFrame = (workspace.Camera.CFrame + workspace.Camera.CFrame.LookVector * 1) * CFrame.Angles(math.rad(90), 0, 0)
								input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, true, game, 1)
								task.wait(0.1)
								input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, false, game, 1)
							end
						end
						game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
							if local_player.Character and local_player.Character:FindFirstChild("HumanoidRootPart") and saved_position then
								local_player.Character.HumanoidRootPart.CFrame = saved_position
							end
							game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
						end)
					end
				end
			end
			
			if Stranded.automation.autobuy.auto_loadout and Stranded.automation.autobuy.selected_gun and shop_table[Stranded.automation.autobuy.selected_gun] then
				if not local_player.Character:FindFirstChild(Stranded.automation.autobuy.selected_gun) and not local_player.Backpack:FindFirstChild(Stranded.automation.autobuy.selected_gun) then
					local shop_item = ws.Ignored.Shop:FindFirstChild(shop_table[Stranded.automation.autobuy.selected_gun].shop_name)
					if shop_item and shop_item:FindFirstChild("Head") then
						saved_position = local_player.Character.HumanoidRootPart.CFrame
						local_player.Character.HumanoidRootPart.CFrame = shop_item.Head.CFrame
						local click_detector = shop_item:FindFirstChildOfClass("ClickDetector")
						if click_detector then
							if fireclickdetector then
								fireclickdetector(click_detector)
							else
								local input = game:GetService("VirtualInputManager")
								shop_item.CFrame = (workspace.Camera.CFrame + workspace.Camera.CFrame.LookVector * 1) * CFrame.Angles(math.rad(90), 0, 0)
								input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, true, game, 1)
								task.wait(0.1)
								input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, false, game, 1)
							end
						end
						game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
							if local_player.Character and local_player.Character:FindFirstChild("HumanoidRootPart") and saved_position then
								local_player.Character.HumanoidRootPart.CFrame = saved_position
							end
							game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
						end)
					end
				end
			end
			
			if Stranded.automation.autobuy.auto_armor then
				if local_player.Character and local_player.Character:FindFirstChild("BodyEffects") and local_player.Character.BodyEffects:FindFirstChild("Armor") then
					if local_player.Character.BodyEffects.Armor.Value < 100 then
						local armor_shop = ws.Ignored.Shop:FindFirstChild("[High-Medium Armor] - $2513")
						if armor_shop and armor_shop:FindFirstChild("Head") then
							saved_position = local_player.Character.HumanoidRootPart.CFrame
							local_player.Character.HumanoidRootPart.CFrame = armor_shop.Head.CFrame
							local click_detector = armor_shop:FindFirstChildOfClass("ClickDetector")
							if click_detector then
								if fireclickdetector then
									fireclickdetector(click_detector)
								else
									local input = game:GetService("VirtualInputManager")
									armor_shop.CFrame = (workspace.Camera.CFrame + workspace.Camera.CFrame.LookVector * 1) * CFrame.Angles(math.rad(90), 0, 0)
									input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, true, game, 1)
									task.wait(0.1)
									input:SendMouseButtonEvent(workspace.Camera.ViewportSize.X/2, workspace.Camera.ViewportSize.Y/2, 0, false, game, 1)
								end
							end
							game:GetService("RunService"):BindToRenderStep("RestoreCFrame", 199, function()
								if local_player.Character and local_player.Character:FindFirstChild("HumanoidRootPart") and saved_position then
									local_player.Character.HumanoidRootPart.CFrame = saved_position
								end
								game:GetService("RunService"):UnbindFromRenderStep("RestoreCFrame")
							end)
						end
					end
				end
			end
		end,
		auto_reload_update = function()
			if not Stranded.automation or not Stranded.automation.auto_reload then
				return
			end
			
			if not Stranded.automation.auto_reload.enabled then
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then
				return
			end
			
			local character = self.vars.local_player.Character
			local tool = character:FindFirstChildOfClass("Tool")
			if not tool then
				return
			end
			
			if not self.auto_reload_cache then
				self.auto_reload_cache = {
					last_reload_time = 0,
					last_ammo = nil
				}
			end
			
			local ammo_value = tool:FindFirstChild("Ammo")
			if ammo_value then
				local current_ammo = ammo_value.Value
				local current_time = tick()
				
				if current_ammo <= 0 then
					if current_time - self.auto_reload_cache.last_reload_time >= 0.5 then
						tool:Activate()
						self.auto_reload_cache.last_reload_time = current_time
					end
				end
			end
		end,
		chat_spammer_update = function()
			if not Stranded.utility or not Stranded.utility.chat_spammer then
				return
			end
			
			if not Stranded.utility.chat_spammer.enabled then
				return
			end
			
			if not self.chat_spammer_cache then
				self.chat_spammer_cache = {
					last_message_time = 0
				}
			end
			
			local current_time = tick()
			local delay = Stranded.utility.chat_spammer.delay or 1
			
			if current_time - self.chat_spammer_cache.last_message_time >= delay then
				local message = ""
				local spammer_type = Stranded.utility.chat_spammer.type or "Custom"
				
				if spammer_type == "Trash Talk" then
					local trash_talk_messages = {
						"L",
						"ez",
						"get good",
						"skill issue",
						"ratio",
						"cope",
						"seethe",
						"mad?",
						"cry about it",
						"trash",
						"noob",
						"owned",
						"rekt",
						"get rekt",
						"you're bad",
						"stay mad",
						"cope harder",
						"L + ratio",
						"skill diff",
						"washed",
						"you're washed",
						"mid",
						"you're mid",
						"trash player",
						"get better",
						"uninstall",
						"quit the game",
						"you're terrible",
						"bot",
						"you're a bot"
					}
					
					if not self.chat_spammer_cache.trash_talk_index then
						self.chat_spammer_cache.trash_talk_index = 1
					end
					
					message = trash_talk_messages[self.chat_spammer_cache.trash_talk_index]
					self.chat_spammer_cache.trash_talk_index = (self.chat_spammer_cache.trash_talk_index % #trash_talk_messages) + 1
				else
					message = Stranded.utility.chat_spammer.message or "spam"
				end
				
				pcall(function()
					local text_chat_service = game:GetService("TextChatService")
					local text_channels = text_chat_service:FindFirstChild("TextChannels")
					
					if text_channels then
						local general_channel = text_channels:FindFirstChild("RBXGeneral")
						if general_channel then
							general_channel:SendAsync(message)
						else
							local default_channel = text_channels:FindFirstChildOfClass("TextChannel")
							if default_channel then
								default_channel:SendAsync(message)
							end
						end
					else
						local local_player = self.vars.local_player
						if local_player then
							local_player:Chat(message)
						end
					end
				end)
				
				self.chat_spammer_cache.last_message_time = current_time
			end
		end,
		viewmodel_changer_update = function()
			if not Stranded.utility or not Stranded.utility.viewmodel_changer then
				return
			end
			
			local camera = workspace.CurrentCamera
			if not camera then
				return
			end
			
			if not Stranded.utility.viewmodel_changer.enabled then
				return
			end
			
			local x_offset = Stranded.utility.viewmodel_changer.x_offset or 0
			local y_offset = Stranded.utility.viewmodel_changer.y_offset or 0
			local z_offset = Stranded.utility.viewmodel_changer.z_offset or 0
			
			if x_offset == 0 and y_offset == 0 and z_offset == 0 then
				return
			end
			
			local current_cframe = camera.CFrame
			local right_vector = current_cframe.RightVector
			local up_vector = current_cframe.UpVector
			local look_vector = current_cframe.LookVector
			
			local offset_position = current_cframe.Position + (right_vector * x_offset) + (up_vector * y_offset) + (look_vector * z_offset)
			local target_position = offset_position + look_vector
			
			camera.CFrame = CFrame.new(offset_position, target_position)
		end,
		fov_changer_update = function()
			if not Stranded.utility or not Stranded.utility.fov_changer then
				return
			end
			
			local camera = workspace.CurrentCamera
			if not camera then
				return
			end
			
			if not self.fov_changer_cache then
				self.fov_changer_cache = {
					original_fov = camera.FieldOfView
				}
			end
			
			if Stranded.utility.fov_changer.enabled then
				local fov = Stranded.utility.fov_changer.fov or 70
				if camera.FieldOfView ~= fov then
					camera.FieldOfView = fov
				end
			else
				if self.fov_changer_cache.original_fov and camera.FieldOfView ~= self.fov_changer_cache.original_fov then
					camera.FieldOfView = self.fov_changer_cache.original_fov
				end
			end
		end,
		animation_player_update = function()
			if not Stranded.utility or not Stranded.utility.animation_player then
				return
			end
			
			if not self.vars.local_player then
				return
			end
			
			if not self.animation_player_cache then
				self.animation_player_cache = {
					animation_instance = Instance.new("Animation"),
					animation_track = nil,
					last_character = nil,
					is_playing = false,
					connection_setup = false
				}
			end
			
			if not self.animation_player_cache.connection_setup then
				self.animation_player_cache.connection_setup = true
				if self.vars.local_player then
					self.vars.local_player.CharacterAdded:Connect(function(character)
						if Stranded.utility and Stranded.utility.animation_player and Stranded.utility.animation_player.enabled then
							task.wait(0.5)
							if self.animation_player_cache then
								self.animation_player_cache.last_character = nil
								self.animation_player_cache.animation_track = nil
								self.animation_player_cache.is_playing = false
							end
						end
					end)
				end
			end
			
			if not self.vars.local_player.Character then
				return
			end
			
			local character = self.vars.local_player.Character
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			
			if not humanoid then
				return
			end
			
			if self.animation_player_cache.last_character ~= character then
				if self.animation_player_cache.animation_track then
					self.animation_player_cache.animation_track:Stop()
					self.animation_player_cache.animation_track = nil
				end
				self.animation_player_cache.last_character = character
				self.animation_player_cache.is_playing = false
			end
			
			if Stranded.utility.animation_player.enabled then
				local animation_id = Stranded.utility.animation_player.animation_id or "rbxassetid://14352343065"
				
				if not self.animation_player_cache.animation_track then
					self.animation_player_cache.animation_instance.AnimationId = animation_id
					self.animation_player_cache.animation_track = humanoid:LoadAnimation(self.animation_player_cache.animation_instance)
					self.animation_player_cache.animation_track.Looped = true
					self.animation_player_cache.animation_track.Priority = Enum.AnimationPriority.Action
					task.spawn(function()
						task.wait(0.6)
						if self.animation_player_cache and self.animation_player_cache.animation_track and Stranded.utility and Stranded.utility.animation_player and Stranded.utility.animation_player.enabled then
							self.animation_player_cache.animation_track:Play()
							self.animation_player_cache.is_playing = true
						end
					end)
				else
					if self.animation_player_cache.animation_instance.AnimationId ~= animation_id then
						if self.animation_player_cache.animation_track then
							self.animation_player_cache.animation_track:Stop()
						end
						self.animation_player_cache.animation_instance.AnimationId = animation_id
						self.animation_player_cache.animation_track = humanoid:LoadAnimation(self.animation_player_cache.animation_instance)
						self.animation_player_cache.animation_track.Looped = true
						self.animation_player_cache.animation_track.Priority = Enum.AnimationPriority.Action
						task.spawn(function()
							task.wait(0.6)
							if self.animation_player_cache and self.animation_player_cache.animation_track and Stranded.utility and Stranded.utility.animation_player and Stranded.utility.animation_player.enabled then
								self.animation_player_cache.animation_track:Play()
								self.animation_player_cache.is_playing = true
							end
						end)
					end
				end
				
				if self.animation_player_cache.animation_track and self.animation_player_cache.is_playing then
					local speed = Stranded.utility.animation_player.speed or 1
					self.animation_player_cache.animation_track:AdjustSpeed(speed)
				end
			else
				if self.animation_player_cache.animation_track and self.animation_player_cache.is_playing then
					self.animation_player_cache.animation_track:Stop()
					self.animation_player_cache.is_playing = false
				end
			end
		end,
		avatar_changer_update = function()
			if not Stranded.utility or not Stranded.utility.avatar_changer then
				return
			end
			
			if not Stranded.utility.avatar_changer.enabled then
				return
			end
			
			if not self.vars.local_player then
				return
			end
			
			local character = self.vars.local_player.Character
			if not character then
				return
			end
			
			local humanoid = character:FindFirstChild("Humanoid")
			if not humanoid then
				return
			end
			
			if not self.avatar_changer_cache then
				self.avatar_changer_cache = {
					connection_setup = false
				}
			end
			
			if not self.avatar_changer_cache.connection_setup then
				self.avatar_changer_cache.connection_setup = true
				if self.vars.local_player then
					self.vars.local_player.CharacterAdded:Connect(function()
						if Stranded.utility and Stranded.utility.avatar_changer and Stranded.utility.avatar_changer.enabled then
							task.wait(0.5)
							esp.funcs.avatar_changer_update()
						end
					end)
				end
			end
			
			local user_id = Stranded.utility.avatar_changer.user_id or 244844600
			
			for _, item in pairs(character:GetChildren()) do
				if item:IsA("Shirt") or item:IsA("Pants") or item:IsA("Accessory") then
					item:Destroy()
				end
			end
			
			pcall(function()
				humanoid:ApplyDescriptionClientServer(game.Players:GetHumanoidDescriptionFromUserId(user_id))
			end)
		end,
		skin_changer_update = function()
			if not Stranded.utility or not Stranded.utility.skin_changer then
				return
			end
			
			if not Stranded.utility.skin_changer.enabled then
				return
			end
			
			local skin = Stranded.utility.skin_changer.skin or "Valentines"
			
			local skin_textures = {
				["Valentines"] = {
					["[SilencerAR]"] = "rbxassetid://9402007158",
					["[SMG]"] = "rbxassetid://9387614760",
					["[TacticalShotgun]"] = "rbxassetid://12115525020",
					["[AK47]"] = "rbxassetid://9402132929",
					["[AUG]"] = "rbxassetid://9401832956",
					["[AR]"] = "rbxassetid://9402007158",
					["[Glock]"] = "rbxassetid://9401709916",
					["[Shotgun]"] = "rbxassetid://9387933478",
					["[Silencer]"] = "rbxassetid://9401709916",
					["[P90]"] = "rbxassetid://9399887933",
					["[Revolver]"] = "rbxassetid://12110413906",
					["[RPG]"] = "rbxassetid://9399842353",
					["[LMG]"] = "rbxassetid://9400170566",
					["[Flamethrower]"] = "rbxassetid://9400558000",
					["[DrumGun]"] = "rbxassetid://9381577172",
					["[Double-Barrel SG]"] = "rbxassetid://12114956009"
				},
				["Rainbow"] = {
					["[SilencerAR]"] = "rbxassetid://9402007158",
					["[SMG]"] = "rbxassetid://9387614760",
					["[TacticalShotgun]"] = "rbxassetid://12899678631",
					["[AK47]"] = "rbxassetid://9402132929",
					["[AUG]"] = "rbxassetid://9401832956",
					["[AR]"] = "rbxassetid://9402007158",
					["[Glock]"] = "rbxassetid://9401709916",
					["[Shotgun]"] = "rbxassetid://9387933478",
					["[Silencer]"] = "rbxassetid://9401709916",
					["[P90]"] = "rbxassetid://9399887933",
					["[Revolver]"] = "rbxassetid://12898879990",
					["[RPG]"] = "rbxassetid://9399842353",
					["[LMG]"] = "rbxassetid://9400170566",
					["[Flamethrower]"] = "rbxassetid://9400558000",
					["[DrumGun]"] = "rbxassetid://9381577172",
					["[Double-Barrel SG]"] = "rbxassetid://12899533307"
				},
				["Luck"] = {
					["[SilencerAR]"] = "rbxassetid://9402007158",
					["[SMG]"] = "rbxassetid://9387614760",
					["[TacticalShotgun]"] = "rbxassetid://12806214848",
					["[AK47]"] = "rbxassetid://9402132929",
					["[AUG]"] = "rbxassetid://9401832956",
					["[AR]"] = "rbxassetid://9402007158",
					["[Glock]"] = "rbxassetid://9401709916",
					["[Shotgun]"] = "rbxassetid://9387933478",
					["[Silencer]"] = "rbxassetid://9401709916",
					["[P90]"] = "rbxassetid://9399887933",
					["[Revolver]"] = "rbxassetid://12804964131",
					["[RPG]"] = "rbxassetid://9399842353",
					["[LMG]"] = "rbxassetid://9400170566",
					["[Flamethrower]"] = "rbxassetid://9400558000",
					["[DrumGun]"] = "rbxassetid://9381577172",
					["[Double-Barrel SG]"] = "rbxassetid://12805836044"
				},
				["Christmas Wrap"] = {
					["[SilencerAR]"] = "rbxassetid://9402007158",
					["[SMG]"] = "rbxassetid://9387614760",
					["[TacticalShotgun]"] = "rbxassetid://11698582341",
					["[AK47]"] = "rbxassetid://9402132929",
					["[AUG]"] = "rbxassetid://9401832956",
					["[AR]"] = "rbxassetid://9402007158",
					["[Glock]"] = "rbxassetid://9401709916",
					["[Shotgun]"] = "rbxassetid://9387933478",
					["[Silencer]"] = "rbxassetid://9401709916",
					["[P90]"] = "rbxassetid://9399887933",
					["[Revolver]"] = "rbxassetid://11691406715",
					["[RPG]"] = "rbxassetid://9399842353",
					["[LMG]"] = "rbxassetid://9400170566",
					["[Flamethrower]"] = "rbxassetid://9400558000",
					["[DrumGun]"] = "rbxassetid://9381577172",
					["[Double-Barrel SG]"] = "rbxassetid://11698395299"
				},
				["Snow Wrap"] = {
					["[SilencerAR]"] = "rbxassetid://9402007158",
					["[SMG]"] = "rbxassetid://9387614760",
					["[TacticalShotgun]"] = "rbxassetid://11698590246",
					["[AK47]"] = "rbxassetid://9402132929",
					["[AUG]"] = "rbxassetid://9401832956",
					["[AR]"] = "rbxassetid://9402007158",
					["[Glock]"] = "rbxassetid://9401709916",
					["[Shotgun]"] = "rbxassetid://9387933478",
					["[Silencer]"] = "rbxassetid://9401709916",
					["[P90]"] = "rbxassetid://9399887933",
					["[Revolver]"] = "rbxassetid://11698051393",
					["[RPG]"] = "rbxassetid://9399842353",
					["[LMG]"] = "rbxassetid://9400170566",
					["[Flamethrower]"] = "rbxassetid://9400558000",
					["[DrumGun]"] = "rbxassetid://9381577172",
					["[Double-Barrel SG]"] = "rbxassetid://11698411164"
				},
				["Blue Wrap"] = {
					["[SilencerAR]"] = "rbxassetid://9402007158",
					["[SMG]"] = "rbxassetid://9387614760",
					["[TacticalShotgun]"] = "rbxassetid://11698585498",
					["[AK47]"] = "rbxassetid://9402132929",
					["[AUG]"] = "rbxassetid://9401832956",
					["[AR]"] = "rbxassetid://9402007158",
					["[Glock]"] = "rbxassetid://9401709916",
					["[Shotgun]"] = "rbxassetid://9387933478",
					["[Silencer]"] = "rbxassetid://9401709916",
					["[P90]"] = "rbxassetid://9399887933",
					["[Revolver]"] = "rbxassetid://11691558717",
					["[RPG]"] = "rbxassetid://9399842353",
					["[LMG]"] = "rbxassetid://9400170566",
					["[Flamethrower]"] = "rbxassetid://9400558000",
					["[DrumGun]"] = "rbxassetid://9381577172",
					["[Double-Barrel SG]"] = "rbxassetid://11698398802"
				},
			}
			
			local textures = skin_textures[skin]
			if not textures then
				return
			end
			
			esp.vars.rs:UnbindFromRenderStep("Skin Changer")
			
			esp.vars.rs:BindToRenderStep("Skin Changer", 0, function()
				if not Stranded.utility or not Stranded.utility.skin_changer or not Stranded.utility.skin_changer.enabled then
					esp.vars.rs:UnbindFromRenderStep("Skin Changer")
					return
				end
				
				local character = self.vars.local_player and self.vars.local_player.Character
				if not character then
					return
				end
				
				for weapon_name, texture_id in pairs(textures) do
					local weapon = character:FindFirstChild(weapon_name)
					if weapon then
						local default_part = weapon:FindFirstChild("Default")
						if default_part and default_part:IsA("BasePart") then
							pcall(function()
								default_part.TextureID = texture_id
							end)
						end
					end
				end
			end)
		end,
		apply_desync = function()
			if not Stranded.desync.enabled or not Stranded.desync.active then return end
			
			local character = self.vars.local_player and self.vars.local_player.Character
			if not character then return end
			
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			
			if not self.desync_cache then
				self.desync_cache = {
					last_cframe = nil,
					last_velocity = Vector3.new(0, 0, 0)
				}
			end
			
			self.desync_cache.last_cframe = hrp.CFrame
			self.desync_cache.last_velocity = hrp.AssemblyLinearVelocity
			
			local x = math.random(Stranded.desync.min_x * 100, Stranded.desync.max_x * 100) / 100
			local y = math.random(Stranded.desync.min_y * 100, Stranded.desync.max_y * 100) / 100
			local z = math.random(Stranded.desync.min_z * 100, Stranded.desync.max_z * 100) / 100
			local random_offset = Vector3.new(x, y, z)
			
			local fake_pos = self.desync_cache.last_cframe.Position + random_offset
			
			local rotation = math.random(Stranded.desync.min_rotation, Stranded.desync.max_rotation)
			local random_rotation = math.rad(rotation)
			local rotation_cframe = CFrame.Angles(random_rotation, 0, 0)
			
			local fake_cframe = CFrame.new(fake_pos) * rotation_cframe * CFrame.Angles(0, self.desync_cache.last_cframe:ToEulerAnglesYXZ(), 0)
			
			hrp.CFrame = fake_cframe
			
			local random_vel_magnitude = Stranded.desync.max_velocity
			local random_vel_direction = Vector3.new(
				math.random(-100, 100) / 100,
				math.random(-100, 100) / 100,
				math.random(-100, 100) / 100
			).Unit
			hrp.AssemblyLinearVelocity = random_vel_direction * random_vel_magnitude
			
			local rs = self.vars.rs or game:GetService("RunService")
			rs:BindToRenderStep("DesyncRestore", Enum.RenderPriority.Camera.Value - 1, function()
				if hrp and self.desync_cache.last_cframe then
					hrp.CFrame = self.desync_cache.last_cframe
					hrp.AssemblyLinearVelocity = self.desync_cache.last_velocity
				end
				rs:UnbindFromRenderStep("DesyncRestore")
			end)
		end,
		apply_break_move_direction = function()
			if not Stranded.desync.break_move_direction then return end
			if not Stranded.desync.enabled or not Stranded.desync.active then return end
			
			local character = self.vars.local_player and self.vars.local_player.Character
			if not character then return end
			
			local humanoid = character:FindFirstChild("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if not humanoid or not hrp then return end
			
			local move_direction = humanoid.MoveDirection
			
			if move_direction.Magnitude > 0.1 then
				local forward_backward = math.abs(move_direction:Dot(hrp.CFrame.LookVector))
				local left_right = math.abs(move_direction:Dot(hrp.CFrame.RightVector))
				
				local new_cframe
				
				if forward_backward > left_right then
					local is_forward = move_direction:Dot(hrp.CFrame.LookVector) > 0
					if is_forward then
						new_cframe = hrp.CFrame * CFrame.Angles(0, math.rad(180), 0)
					else
						new_cframe = hrp.CFrame
					end
				else
					local is_right = move_direction:Dot(hrp.CFrame.RightVector) > 0
					if is_right then
						new_cframe = hrp.CFrame * CFrame.Angles(0, math.rad(-90), 0)
					else
						new_cframe = hrp.CFrame * CFrame.Angles(0, math.rad(90), 0)
					end
				end
				
				hrp.CFrame = new_cframe
			end
		end,
		apply_fakepos = function()
			if not Stranded.fakepos.enabled or not Stranded.fakepos.active then return end
			
			local character = self.vars.local_player and self.vars.local_player.Character
			if not character then return end
			
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			
			if not self.fakepos_cache then
				self.fakepos_cache = {
					last_cframe = nil,
					last_velocity = Vector3.new(0, 0, 0),
					extreme_offset = nil
				}
			end
			
			self.fakepos_cache.last_cframe = hrp.CFrame
			self.fakepos_cache.last_velocity = hrp.AssemblyLinearVelocity
			
			local offset
			if Stranded.fakepos.extreme_mode then
				if not self.fakepos_cache.extreme_offset then
					local extreme = 9007199254740992
					self.fakepos_cache.extreme_offset = Vector3.new(extreme, extreme, extreme)
				end
				offset = self.fakepos_cache.extreme_offset
			else
				self.fakepos_cache.extreme_offset = nil
				offset = Vector3.new(Stranded.fakepos.offset_x, Stranded.fakepos.offset_y, Stranded.fakepos.offset_z)
			end
			
			local fake_pos = self.fakepos_cache.last_cframe.Position + offset
			
			if Stranded.fakepos.anticlip and not Stranded.fakepos.extreme_mode then
				local rayParams = RaycastParams.new()
				rayParams.FilterDescendantsInstances = {character}
				rayParams.FilterType = Enum.RaycastFilterType.Blacklist
				
				local direction = offset
				local rayResult = workspace:Raycast(self.fakepos_cache.last_cframe.Position, direction, rayParams)
				
				if rayResult then
					local hitDistance = (rayResult.Position - self.fakepos_cache.last_cframe.Position).Magnitude
					local safeDistance = hitDistance - 2
					if safeDistance > 0 then
						fake_pos = self.fakepos_cache.last_cframe.Position + (direction.Unit * safeDistance)
					else
						fake_pos = self.fakepos_cache.last_cframe.Position
					end
				end
			end
			
			local rotation_radians = math.rad(Stranded.fakepos.rotation)
			local rotation_cframe = CFrame.Angles(rotation_radians, 0, 0)
			
			local fake_cframe = CFrame.new(fake_pos) * rotation_cframe * CFrame.Angles(0, self.fakepos_cache.last_cframe:ToEulerAnglesYXZ(), 0)
			
			hrp.CFrame = fake_cframe
			
			if Stranded.fakepos.extreme_mode then
				hrp.AssemblyLinearVelocity = Vector3.new(math.huge, math.huge, math.huge)
			else
				hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
			end
			
			local rs = self.vars.rs or game:GetService("RunService")
			rs:BindToRenderStep("FakePosRestore", Enum.RenderPriority.Camera.Value - 1, function()
				if hrp and self.fakepos_cache.last_cframe then
					hrp.CFrame = self.fakepos_cache.last_cframe
					hrp.AssemblyLinearVelocity = self.fakepos_cache.last_velocity
				end
				rs:UnbindFromRenderStep("FakePosRestore")
			end)
		end,
		apply_anti_fling = function()
			if not Stranded.anti_fling.enabled then return end
			
			local character = self.vars.local_player and self.vars.local_player.Character
			if not character then return end
			
			local hrp = character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			
			hrp.Velocity = Vector3.new(17, 17, 17)
		end,
		apply_spinbot = function()
			if not Stranded.spinbot.enabled then
				if self.vars.local_player and self.vars.local_player.Character then
					local humanoid = self.vars.local_player.Character:FindFirstChild("Humanoid")
					if humanoid then
						humanoid.AutoRotate = true
					end
				end
				return
			end
			
			local character = self.vars.local_player and self.vars.local_player.Character
			if not character then return end
			
			local humanoid = character:FindFirstChild("Humanoid")
			local hrp = character:FindFirstChild("HumanoidRootPart")
			
			if humanoid and hrp then
				humanoid.AutoRotate = false
				
				if not self.spinbot_cache then
					self.spinbot_cache = {
						angle = 0,
						last_cframe = nil,
						last_velocity = Vector3.new(0, 0, 0)
					}
				end
				
				if Stranded.spinbot.mode == "Rotational" then
					if Stranded.spinbot.server_only then
						self.spinbot_cache.last_cframe = hrp.CFrame
						self.spinbot_cache.last_velocity = hrp.AssemblyLinearVelocity
						
						local rotation_speed = math.rad(Stranded.spinbot.speed)
						self.spinbot_cache.angle = self.spinbot_cache.angle + rotation_speed
						
						local x_rot = Stranded.spinbot.x_enabled and self.spinbot_cache.angle or 0
						local y_rot = Stranded.spinbot.y_enabled and self.spinbot_cache.angle or 0
						local z_rot = Stranded.spinbot.z_enabled and self.spinbot_cache.angle or 0
						
						local fake_cframe = hrp.CFrame * CFrame.Angles(x_rot, y_rot, z_rot)
						hrp.CFrame = fake_cframe
						hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
						
						local rs = self.vars.rs or game:GetService("RunService")
						rs:BindToRenderStep("SpinbotRestore", Enum.RenderPriority.Camera.Value - 1, function()
							if hrp and self.spinbot_cache.last_cframe then
								hrp.CFrame = self.spinbot_cache.last_cframe
								hrp.AssemblyLinearVelocity = self.spinbot_cache.last_velocity
							end
							rs:UnbindFromRenderStep("SpinbotRestore")
						end)
					else
						local rotation_speed = math.rad(Stranded.spinbot.speed)
						self.spinbot_cache.angle = self.spinbot_cache.angle + rotation_speed
						
						local x_rot = Stranded.spinbot.x_enabled and self.spinbot_cache.angle or 0
						local y_rot = Stranded.spinbot.y_enabled and self.spinbot_cache.angle or 0
						local z_rot = Stranded.spinbot.z_enabled and self.spinbot_cache.angle or 0
						
						hrp.CFrame = hrp.CFrame * CFrame.Angles(x_rot, y_rot, z_rot)
					end
				else
					if Stranded.spinbot.server_only then
						self.spinbot_cache.last_cframe = hrp.CFrame
						self.spinbot_cache.last_velocity = hrp.AssemblyLinearVelocity
						
						local rotation_speed = math.rad(Stranded.spinbot.speed)
						self.spinbot_cache.angle = self.spinbot_cache.angle + rotation_speed
						
						local fake_cframe = hrp.CFrame * CFrame.Angles(0, self.spinbot_cache.angle, 0)
						hrp.CFrame = fake_cframe
						hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
						
						local rs = self.vars.rs or game:GetService("RunService")
						rs:BindToRenderStep("SpinbotRestore", Enum.RenderPriority.Camera.Value - 1, function()
							if hrp and self.spinbot_cache.last_cframe then
								hrp.CFrame = self.spinbot_cache.last_cframe
								hrp.AssemblyLinearVelocity = self.spinbot_cache.last_velocity
							end
							rs:UnbindFromRenderStep("SpinbotRestore")
						end)
					else
						local rotation_speed = math.rad(Stranded.spinbot.speed)
						hrp.CFrame = hrp.CFrame * CFrame.Angles(0, rotation_speed, 0)
					end
				end
			end
		end,
		update_server_hrp_visualizer = function()
			if not Stranded.server_hrp_visualizer.enabled then
				if self.visualizer_cache and self.visualizer_cache.model then
					self.visualizer_cache.model:Destroy()
					self.visualizer_cache = nil
				end
				return
			end
			
			if not self.vars.local_player or not self.vars.local_player.Character then return end
			local hrp = self.vars.local_player.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			
			if not self.visualizer_cache then
				self.visualizer_cache = {
					model = nil,
					parts = {}
				}
			end
			
			if not self.visualizer_cache.model then
				local visualizer_model = Instance.new("Model")
				visualizer_model.Name = "ServerHRPVisualizer"
				visualizer_model.Parent = workspace
				
				local parts_data = {
					Head = {size = Vector3.new(2, 1, 1), offset = Vector3.new(0, 1.5, 0)},
					Torso = {size = Vector3.new(2, 2, 1), offset = Vector3.new(0, 0, 0)},
					LeftArm = {size = Vector3.new(1, 2, 1), offset = Vector3.new(-1.5, 0, 0)},
					RightArm = {size = Vector3.new(1, 2, 1), offset = Vector3.new(1.5, 0, 0)},
					LeftLeg = {size = Vector3.new(1, 2, 1), offset = Vector3.new(-0.5, -2, 0)},
					RightLeg = {size = Vector3.new(1, 2, 1), offset = Vector3.new(0.5, -2, 0)},
				}
				
				for name, data in pairs(parts_data) do
					local part = Instance.new("Part")
					part.Name = name
					part.Size = data.size
					part.Anchored = true
					part.CanCollide = false
					part.Material = Enum.Material.Neon
					part.Color = Stranded.server_hrp_visualizer.color
					part.Transparency = Stranded.server_hrp_visualizer.transparency
					part.TopSurface = Enum.SurfaceType.Smooth
					part.BottomSurface = Enum.SurfaceType.Smooth
					part.Parent = visualizer_model
					self.visualizer_cache.parts[name] = {part = part, offset = data.offset}
				end
				
				self.visualizer_cache.model = visualizer_model
			end
			
			local server_pos = hrp.Position
			local server_cframe = hrp.CFrame
			
			if Stranded.fakepos.enabled and Stranded.fakepos.active then
				local offset = Vector3.new(Stranded.fakepos.offset_x, Stranded.fakepos.offset_y, Stranded.fakepos.offset_z)
				
				if Stranded.fakepos.extreme_mode then
					local extreme = 9007199254740992
					offset = Vector3.new(extreme, extreme, extreme)
				end
				
				server_pos = hrp.Position + offset
				
				local rotation_radians = math.rad(Stranded.fakepos.rotation)
				local rotation_cframe = CFrame.Angles(rotation_radians, 0, 0)
				server_cframe = CFrame.new(server_pos) * rotation_cframe * CFrame.Angles(0, hrp.CFrame:ToEulerAnglesYXZ(), 0)
			else
				server_cframe = CFrame.new(server_pos) * (hrp.CFrame - hrp.CFrame.Position)
			end
			
			if Stranded.spinbot.enabled then
				local rotation_speed = math.rad(Stranded.spinbot.speed)
				local spin_angle = tick() * rotation_speed
				
				if Stranded.spinbot.mode == "Rotational" then
					local x_rot = Stranded.spinbot.x_enabled and spin_angle or 0
					local y_rot = Stranded.spinbot.y_enabled and spin_angle or 0
					local z_rot = Stranded.spinbot.z_enabled and spin_angle or 0
					server_cframe = server_cframe * CFrame.Angles(x_rot, y_rot, z_rot)
				else
					server_cframe = server_cframe * CFrame.Angles(0, spin_angle, 0)
				end
			end
			
			if Stranded.desync.enabled and Stranded.desync.active then
				local random_offset = Vector3.new(
					math.random(Stranded.desync.min_x, Stranded.desync.max_x),
					math.random(Stranded.desync.min_y, Stranded.desync.max_y),
					math.random(Stranded.desync.min_z, Stranded.desync.max_z)
				)
				local rotation_part = server_cframe - server_cframe.Position
				server_pos = server_cframe.Position + random_offset
				server_cframe = CFrame.new(server_pos) * rotation_part
			end
			
			task.delay(Stranded.server_hrp_visualizer.delay_simulation, function()
				if not self.visualizer_cache or not self.visualizer_cache.model then return end
				
				for name, data in pairs(self.visualizer_cache.parts) do
					if data.part then
						data.part.CFrame = server_cframe * CFrame.new(data.offset)
						data.part.Transparency = Stranded.server_hrp_visualizer.transparency
						data.part.Color = Stranded.server_hrp_visualizer.color
					end
				end
			end)
		end,
		setup_target_aim_hook = function()
			local checkcaller = checkcaller or function()
				return getcallingscript() == nil
			end
			
			if not self.vars or not self.vars.game then
				return
			end
			
			local grm = getrawmetatable(self.vars.game)
			if not grm then
				return
			end
			
			local index = grm.__index
			setreadonly(grm, false)
			
			local local_player = self.vars.local_player
			if not local_player then return end
			
			local Mouse = local_player:GetMouse()
			
			grm.__index = function(self_obj, Index)
				if not checkcaller() and self_obj == Mouse and Stranded.target_aim.enabled then
					if Index == "Hit" or Index == "Target" then
						local TargetPart = self.funcs.get_target_aim_part()
						if TargetPart then
							local target_position = TargetPart.Position
							
							if Stranded.target_aim.settings.prediction and Stranded.target_aim.settings.prediction > 0 then
								local target_root = TargetPart.Parent and TargetPart.Parent:FindFirstChild("HumanoidRootPart")
								if target_root then
									local target_velocity = Vector3.new(0, 0, 0)
									local body_velocity = target_root:FindFirstChildOfClass("BodyVelocity") or target_root:FindFirstChildOfClass("LinearVelocity")
									if body_velocity then
										target_velocity = body_velocity.Vector or body_velocity.MaxForce
									else
										local humanoid = TargetPart.Parent:FindFirstChildOfClass("Humanoid")
										if humanoid and humanoid.MoveDirection then
											target_velocity = humanoid.MoveDirection * (humanoid.WalkSpeed or 16)
										end
									end
									
									local prediction = Stranded.target_aim.settings.prediction or 0.17
									target_position = target_position + (target_velocity * prediction)
								end
							end
							
							return CFrame.new(target_position)
						end
					end
				end
				return index(self_obj, Index)
			end
			
			setreadonly(grm, true)
		end,
		setup_silent_aim_hook = function()
			if not self.vars or not self.vars.local_player then
				return
			end
			
			local LocalPlayer = self.vars.local_player
			local Mouse = LocalPlayer:GetMouse()
			
			Script = Script or {}
			Script.Hooks = Script.Hooks or {}
			Script.Targeting = Script.Targeting or {}
			Script.Functions = Script.Functions or {}
			
			UI = UI or {}
			UI.Combat = UI.Combat or {}
			UI.Combat.SilentAim = UI.Combat.SilentAim or {}
			
			UI.Combat.SilentAim.Enabled = false
			
			Script.Functions.GetShootingPosition = function(character)
				if not character then return nil end
				
				local hit_part_name = Stranded.target_aim.settings.bone or "Head"
				local hit_part = character:FindFirstChild(hit_part_name)
				
				if not hit_part then return nil end
				
				local target_position = hit_part.Position
				
				if Stranded.target_aim.settings.prediction and Stranded.target_aim.settings.prediction > 0 then
					local target_root = character:FindFirstChild("HumanoidRootPart")
					if target_root then
						local target_velocity = Vector3.new(0, 0, 0)
						local body_velocity = target_root:FindFirstChildOfClass("BodyVelocity") or target_root:FindFirstChildOfClass("LinearVelocity")
						if body_velocity then
							target_velocity = body_velocity.Vector or body_velocity.MaxForce
						else
							local humanoid = character:FindFirstChildOfClass("Humanoid")
							if humanoid and humanoid.MoveDirection then
								target_velocity = humanoid.MoveDirection * (humanoid.WalkSpeed or 16)
							end
						end
						
						local prediction = Stranded.target_aim.settings.prediction or 0.17
						target_position = target_position + (target_velocity * prediction)
					end
				end
				
				return CFrame.new(target_position)
			end
			
			Script.Functions.update_target = function()
				if not Stranded.target_aim.enabled then
					Script.Targeting.Target = nil
					return
				end
				
				local hotkey_flag = Library.Flags["Target Aim Hotkey"]
				local should_aim = false
				
				if hotkey_flag then
					local mode = hotkey_flag.Mode or "Hold"
					if mode == "Always" then
						should_aim = true
					elseif mode == "Toggle" then
						should_aim = hotkey_flag.Toggled or false
					elseif mode == "Hold" then
						local key_code = hotkey_flag.Key
						if type(key_code) == "string" then
							local success, result = pcall(function()
								return Enum.KeyCode[key_code]
							end)
							if success and result then
								key_code = result
							else
								key_code = nil
							end
						end
						
						if not key_code then
							local keybind_str = Stranded.target_aim.keybind or "E"
							local success, result = pcall(function()
								return Enum.KeyCode[keybind_str]
							end)
							if success and result then
								key_code = result
							else
								key_code = Enum.KeyCode.E
							end
						end
						
						if key_code then
							should_aim = self.vars.uis:IsKeyDown(key_code)
						end
					end
				else
					local keybind_str = Stranded.target_aim.keybind or "E"
					local success, result = pcall(function()
						return Enum.KeyCode[keybind_str]
					end)
					if success and result then
						should_aim = self.vars.uis:IsKeyDown(result)
					end
				end
				
				if not should_aim then
					Script.Targeting.Target = nil
					return
				end
				
				local sticky_aim = Stranded.target_aim.settings.sticky_aim
				local target_part = nil
				
				if not self.target_aim_cache then
					self.target_aim_cache = {
						highlight = nil,
						last_target = nil,
						fov_circle = nil,
						sticky_target_part = nil,
						last_should_aim = false
					}
				end
				
				if sticky_aim then
					if self.target_aim_cache.sticky_target_part then
						local cached_part = self.target_aim_cache.sticky_target_part
						if cached_part and cached_part.Parent and cached_part.Parent:IsDescendantOf(workspace) then
							local humanoid = cached_part.Parent:FindFirstChildOfClass("Humanoid")
							if humanoid and humanoid.Health > 0 then
								target_part = cached_part
							else
								self.target_aim_cache.sticky_target_part = nil
							end
						else
							self.target_aim_cache.sticky_target_part = nil
						end
					end
					
					if not target_part and not self.target_aim_cache.sticky_target_part and self.funcs.get_target_aim_closest_player then
						target_part = self.funcs.get_target_aim_closest_player()
						if target_part then
							self.target_aim_cache.sticky_target_part = target_part
						end
					end
				else
					if self.funcs.get_target_aim_closest_player then
						target_part = self.funcs.get_target_aim_closest_player()
					end
				end
				
				if target_part and target_part.Parent then
					for _, player in ipairs(Players:GetPlayers()) do
						if player.Character == target_part.Parent then
							Script.Targeting.Target = player
							return
						end
					end
				end
				
				Script.Targeting.Target = nil
			end
			
			task.spawn(function()
				while true do
					Script.Functions.update_target()
					task.wait()
				end
			end)
			
			checkcaller = checkcaller or function()
				return getcallingscript() == nil
			end
			
			hookmetamethod = hookmetamethod or function(obj, method, func)
				local grm = getrawmetatable(obj)
				local old = grm[method]
				setreadonly(grm, false)
				grm[method] = func
				setreadonly(grm, true)
				return old
			end
			
			newcclosure = newcclosure or function(func)
				return func
			end
			
			local game_obj = self.vars and self.vars.game or game
			if not game_obj then
				return
			end
			
			Script.Hooks.Index = hookmetamethod(game_obj, '__index', function(self_obj, Index)
				if not checkcaller() and self_obj == Mouse and Index == "Hit" then
					if Stranded.target_aim.enabled then
						local target_character = nil
						
						if Stranded.target_aim.settings.sticky_aim and self.target_aim_cache and self.target_aim_cache.sticky_target_part then
							local sticky_part = self.target_aim_cache.sticky_target_part
							if sticky_part and sticky_part.Parent and sticky_part.Parent:IsDescendantOf(workspace) then
								local humanoid = sticky_part.Parent:FindFirstChildOfClass("Humanoid")
								if humanoid and humanoid.Health > 0 then
									target_character = sticky_part.Parent
								end
							end
						end
						
						if not target_character and Script.Targeting.Target and Script.Targeting.Target.Character then
							target_character = Script.Targeting.Target.Character
						end
						
						if target_character then
							return Script.Functions.GetShootingPosition(target_character)
						end
					end
				end
				
				return Script.Hooks.Index(self_obj, Index)
			end)
		end,
		setup_triggerbot = function()
			if not self.vars or not self.vars.local_player then
				return
			end
			
			if self.triggerbot_thread then
				task.cancel(self.triggerbot_thread)
				self.triggerbot_thread = nil
			end
			
			if not Stranded.triggerbot.enabled then
				return
			end
			
			local last_fire_time = 0
			local uis = self.vars.uis
			local players = self.vars.players
			local local_player = self.vars.local_player
			
			self.triggerbot_thread = task.spawn(function()
				while Stranded.triggerbot.enabled do
					task.wait()
					
					if local_player and local_player.Character then
						local character = local_player.Character
						local gun = character:FindFirstChildOfClass("Tool")
						if gun then
							local gun_name = gun.Name
							local whitelist = Stranded.triggerbot.whitelist or {}
							
							local is_whitelisted = false
							if type(whitelist) ~= "table" or #whitelist == 0 then
								is_whitelisted = true
							else
								for _, weapon_name in ipairs(whitelist) do
									if gun_name:find(weapon_name, 1, true) then
										is_whitelisted = true
										break
									end
								end
							end
							
							if is_whitelisted then
								local current_time = tick()
								if current_time - last_fire_time >= (Stranded.triggerbot.settings.delay or 0.1) then
									if uis:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
										local camera = self.vars.camera or workspace.CurrentCamera
										if camera then
											local mouse_pos = uis:GetMouseLocation()
											local ray = camera:ScreenPointToRay(mouse_pos.X, mouse_pos.Y)
											
											local raycast_params = RaycastParams.new()
											raycast_params.FilterType = Enum.RaycastFilterType.Blacklist
											raycast_params.FilterDescendantsInstances = {character, camera}
											raycast_params.IgnoreWater = true
											
											local ray_result = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycast_params)
											if ray_result then
												local hit_part = ray_result.Instance
												if hit_part and hit_part.Parent then
													local hit_character = hit_part.Parent
													local hit_humanoid = hit_character:FindFirstChildOfClass("Humanoid")
													if hit_humanoid then
														local is_enemy = false
														local enemy_player = nil
														for _, player in ipairs(players:GetPlayers()) do
															if player.Character == hit_character and player ~= local_player then
																is_enemy = true
																enemy_player = player
																break
															end
														end
														
														if is_enemy and enemy_player then
															if self.funcs.check_player(enemy_player, hit_part) then
																local target_part_name = Stranded.target_aim.settings.bone or "Head"
																local target_part = hit_character:FindFirstChild(target_part_name)
																if target_part then
																	local target_position = target_part.Position
																	
																	if Stranded.triggerbot.settings.prediction and Stranded.triggerbot.settings.prediction > 0 then
																		local target_root = hit_character:FindFirstChild("HumanoidRootPart")
																		if target_root then
																			local target_velocity = Vector3.new(0, 0, 0)
																			local body_velocity = target_root:FindFirstChildOfClass("BodyVelocity") or target_root:FindFirstChildOfClass("LinearVelocity")
																			if body_velocity then
																				target_velocity = body_velocity.Vector or body_velocity.MaxForce
																			else
																				if hit_humanoid.MoveDirection then
																					target_velocity = hit_humanoid.MoveDirection * (hit_humanoid.WalkSpeed or 16)
																				end
																			end
																			
																			local prediction = Stranded.triggerbot.settings.prediction or 0.17
																			if Stranded.triggerbot.settings.auto_prediction then
																				local distance = (camera.CFrame.Position - target_position).Magnitude
																				prediction = distance / 1000
																				prediction = math.clamp(prediction, 0.05, 0.5)
																			end
																			target_position = target_position + (target_velocity * prediction)
																		end
																	end
																	
																	local screen_pos, on_screen = camera:WorldToScreenPoint(target_position)
																	if on_screen then
																		local screen_distance = (Vector2.new(screen_pos.X, screen_pos.Y) - mouse_pos).Magnitude
																		if screen_distance <= 50 then
																			gun:Activate()
																			last_fire_time = tick()
																			task.wait(Stranded.triggerbot.settings.delay or 0.1)
																		end
																	end
																end
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end
				end
			end)
		end,
		setup_gun_mods = function()
			if not self.vars or not self.vars.local_player then
				return
			end
			
			local RunService = game:GetService("RunService")
			local LocalPlayer = self.vars.local_player
			
			if not self.original_rapidfire then
				self.original_rapidfire = {}
			end
			
			if self.rapidfire_connection then
				self.rapidfire_connection:Disconnect()
				self.rapidfire_connection = nil
			end
			
			if Stranded.Mods.GunMods.RapidFire and getconnections then
				self.rapidfire_connection = RunService.RenderStepped:Connect(function()
					if not LocalPlayer or not LocalPlayer.Character then return end
					
					local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
					if tool and tool:FindFirstChild("GunScript") then
						for _, connection in ipairs(getconnections(tool.Activated)) do
							local func = connection.Function
							if func then
								local funcInfo = debug.getinfo(func)
								for i = 1, funcInfo.nups do
									local c, n = debug.getupvalue(func, i)
									if type(c) == "number" then
										if not self.original_rapidfire[i] then
											self.original_rapidfire[i] = c
										end
										debug.setupvalue(func, i, Stranded.Mods.GunMods.RapidFire and 0.00000000000000000001 or self.original_rapidfire[i])
									end
								end
							end
						end
					end
				end)
			end
			
			if hookfunction and not self.nospread_hooked then
				self.nospread_old = hookfunction(math.random, function(...)
					local args = {...}
					if checkcaller() then
						return self.nospread_old(...)
					end
					if (#args == 0) or 
					   (args[1] == -0.05 and args[2] == 0.05) or 
					   (args[1] == -0.1) or
					   (args[1] == -0.05) then
						if Stranded.Mods.GunMods.NoSpread then
							return 0
						else
							return self.nospread_old(...)
						end
					end
					return self.nospread_old(...)
				end)
				self.nospread_hooked = true
			end
			
			if not self.norecoil_hooked then
				local camera = workspace.CurrentCamera
				if camera then
					local grm = getrawmetatable(camera)
					if grm then
						local old_index = grm.__index
						setreadonly(grm, false)
						
						local framework = nil
						local success, result = pcall(function()
							local replicated_storage = game:GetService("ReplicatedStorage")
							if replicated_storage:FindFirstChild("Framework") then
								return require(replicated_storage.Framework)
							elseif replicated_storage:FindFirstChild("Modules") and replicated_storage.Modules:FindFirstChild("Framework") then
								return require(replicated_storage.Modules.Framework)
							end
							return nil
						end)
						if success and result then
							framework = result
						end
						
						grm.__index = function(self_obj, key)
							if Stranded.Mods.GunMods.NoRecoil then
								local calling_script = getcallingscript()
								
								if framework and calling_script == framework and self_obj:IsA('Camera') and key == 'CFrame' then
									if old_index then
										return old_index(self_obj, key)
									else
										return camera[key]
									end
								end
							end
							
							if old_index then
								return old_index(self_obj, key)
							else
								return camera[key]
							end
						end
						
						setreadonly(grm, true)
						self.norecoil_hooked = true
					end
				end
			end
		end,
		calculate_prediction = function(target_position, target_velocity)
			if not Stranded.aimbot.settings.prediction_enabled then
				return 0
			end
			
			if not Stranded.aimbot.settings.auto_prediction_enabled or not Stranded.aimbot.settings.auto_prediction then
				return Stranded.aimbot.settings.prediction or 0.17
			end
			
			local distance = (self.vars.camera.CFrame.Position - target_position).Magnitude
			local prediction = distance / 1000
			return math.clamp(prediction, 0.05, 0.5)
		end,
		calculate_bezier_point = function(t, p0, p1, p2, p3)
			if t <= 0 then return p0 end
			if t >= 1 then return p3 end
			
			local u = 1 - t
			local tt = t * t
			local uu = u * u
			local uuu = uu * u
			local ttt = tt * t
			local uut3 = uu * t * 3
			local utt3 = u * tt * 3
			
			return p0 * uuu + p1 * uut3 + p2 * utt3 + p3 * ttt
		end,
		get_bezier_control_points = function(start_pos, end_pos, start_dir, end_dir)
			local diff = end_pos - start_pos
			local distance = diff.Magnitude
			
			if distance < 0.01 then
				return start_pos, start_pos, end_pos, end_pos
			end
			
			local easing_type = Stranded.aimbot.easing.type or "Linear"
			local use_custom = Stranded.aimbot.easing.custom_easing
			local preset_cp1_x, preset_cp1_y, preset_cp2_x, preset_cp2_y = self.funcs.get_easing_bezier_points(easing_type)
			
			if use_custom or preset_cp1_x then
				local cp1_x, cp1_y, cp2_x, cp2_y
				
				if use_custom then
					cp1_x = Stranded.aimbot.easing.control_point_1_x or 0.3
					cp1_y = Stranded.aimbot.easing.control_point_1_y or 0.1
					cp2_x = Stranded.aimbot.easing.control_point_2_x or 0.7
					cp2_y = Stranded.aimbot.easing.control_point_2_y or 0.9
				else
					cp1_x = preset_cp1_x
					cp1_y = preset_cp1_y
					cp2_x = preset_cp2_x
					cp2_y = preset_cp2_y
				end
				
				local direction = diff / distance
				local right = direction:Cross(Vector3.new(0, 1, 0))
				local right_mag = right.Magnitude
				if right_mag > 0.001 then
					right = right / right_mag
				else
					right = Vector3.new(1, 0, 0)
				end
				local up = right:Cross(direction)
				
				local dist_cp1_x = distance * cp1_x
				local dist_cp1_y = distance * cp1_y * 0.5
				local dist_cp2_x = distance * cp2_x
				local dist_cp2_y = distance * cp2_y * 0.5
				
				return start_pos, 
				       start_pos + direction * dist_cp1_x + up * dist_cp1_y,
				       start_pos + direction * dist_cp2_x + up * dist_cp2_y,
				       end_pos
			else
				local control_distance = math.min(distance * 0.3, 50)
				
				return start_pos,
				       start_pos + start_dir * control_distance,
				       end_pos - end_dir * control_distance,
				       end_pos
			end
		end,
		get_easing_bezier_points = function(easing_type)
			local easing = Stranded.aimbot.easing
			local preset = easing[easing_type:lower():gsub(" ", "_")]
			if preset and type(preset) == "table" then
				return preset[1], preset[2], preset[3], preset[4]
			end
			return nil
		end,
		apply_easing = function(current, target, delta_time)
			local diff = target - current
			if math.abs(diff) < 0.001 then return target end
			
			local easing_type = Stranded.aimbot.easing.type or "Linear"
			local speed = Stranded.aimbot.easing.speed or 1
			local factor = speed * delta_time
			
			if easing_type == "Linear" then
				return current + diff * factor
			elseif easing_type == "Smooth" then
				return current + diff * (factor * 0.1)
			elseif easing_type == "Fast" then
				return current + diff * (factor * 2)
			else
				return current + diff * factor
			end
		end,
		aimbot_update = function()
			if not self.aimbot_cache then
				self.aimbot_cache = {
					active = false,
					target = nil,
					connection = nil,
					toggled = false,
					last_key_state = false,
					last_should_aim = false
				}
			end
			
			if not Stranded.aimbot.enabled then
				if self.aimbot_cache.active then
					self.aimbot_cache.active = false
					self.aimbot_cache.target = nil
					self.aimbot_cache.toggled = false
					self.aimbot_cache.bezier_t = 0
					self.aimbot_cache.bezier_t_mouse = 0
					self.aimbot_cache.bezier_p1 = nil
					self.aimbot_cache.bezier_p2 = nil
					self.aimbot_cache.bezier_p1_mouse = nil
					self.aimbot_cache.bezier_p2_mouse = nil
				end
				return
			end
			
			local hotkey_flag = Library.Flags["Aimbot Hotkey"]
			local mode = (hotkey_flag and hotkey_flag.Mode) or Stranded.aimbot.mode or "Hold"
			local should_aim = false
			
			if mode == "Always" then
				should_aim = Stranded.aimbot.enabled
			elseif mode == "Toggle" then
				if hotkey_flag and hotkey_flag.Toggled ~= nil then
					should_aim = hotkey_flag.Toggled
				else
					should_aim = self.aimbot_cache.toggled or false
				end
			elseif mode == "Hold" then
				local key_code = nil
				
				if hotkey_flag and hotkey_flag.Key then
					key_code = hotkey_flag.Key
					if type(key_code) == "string" then
						local success, result = pcall(function()
							return Enum.KeyCode[key_code]
						end)
						if success and result then
							key_code = result
						else
							key_code = nil
						end
					end
				end
				
				if not key_code then
					local keybind_str = Stranded.aimbot.keybind or "Q"
					local success, result = pcall(function()
						return Enum.KeyCode[keybind_str]
					end)
					if success and result then
						key_code = result
					else
						key_code = Enum.KeyCode.Q
					end
				end
				
				local is_pressed = self.vars.uis:IsKeyDown(key_code)
				should_aim = is_pressed
			end
			
			if not should_aim then
				if self.aimbot_cache.active then
					self.aimbot_cache.active = false
					if not Stranded.aimbot.sticky_aim then
						self.aimbot_cache.target = nil
					end
				end
				self.aimbot_cache.bezier_t = 0
				self.aimbot_cache.bezier_t_mouse = 0
				self.aimbot_cache.bezier_p1 = nil
				self.aimbot_cache.bezier_p2 = nil
				self.aimbot_cache.bezier_p1_mouse = nil
				self.aimbot_cache.bezier_p2_mouse = nil
				return
			end
			
			local method = Stranded.aimbot.method or "Closest to Mouse"
			local closest_player = self.funcs.get_closest_player(method)
			
			if not closest_player then
				if self.aimbot_cache.active then
					self.aimbot_cache.active = false
					self.aimbot_cache.target = nil
				end
				return
			end
			
			local sticky_aim = Stranded.aimbot.sticky_aim
			local last_should_aim = self.aimbot_cache.last_should_aim or false
			
			if sticky_aim and not should_aim and last_should_aim then
				self.aimbot_cache.target = nil
			end
			
			if sticky_aim and should_aim and not last_should_aim then
				self.aimbot_cache.target = nil
			end
			
			if sticky_aim and self.aimbot_cache.target and self.aimbot_cache.target.Character then
				local target_char = self.aimbot_cache.target.Character
				local humanoid = target_char:FindFirstChildOfClass("Humanoid")
				if humanoid and humanoid.Health > 0 and target_char:IsDescendantOf(workspace) then
					closest_player = self.aimbot_cache.target
				else
					self.aimbot_cache.target = closest_player
					self.aimbot_cache.active = true
				end
			else
				if not self.aimbot_cache.active or self.aimbot_cache.target ~= closest_player then
					self.aimbot_cache.target = closest_player
					self.aimbot_cache.active = true
				end
			end
			
			self.aimbot_cache.last_should_aim = should_aim
			
			if not self.aimbot_cache.target or not self.aimbot_cache.target.Character then
				self.aimbot_cache.target = nil
				return
			end
			
			local target_bone = self.funcs.get_aimbot_target_bone(self.aimbot_cache.target)
			if not target_bone then
				self.aimbot_cache.target = nil
				return
			end
			
			local camera = self.vars.camera or workspace.CurrentCamera
			if not camera then return end
			
			local target_position = target_bone.Position
			local target_velocity = Vector3.new(0, 0, 0)
			
			local target_root = self.aimbot_cache.target.Character:FindFirstChild("HumanoidRootPart")
			if target_root then
				local body_velocity = target_root:FindFirstChildOfClass("BodyVelocity") or target_root:FindFirstChildOfClass("LinearVelocity")
				if body_velocity then
					target_velocity = body_velocity.Vector or body_velocity.MaxForce
				else
					local humanoid = self.aimbot_cache.target.Character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.MoveDirection then
						target_velocity = humanoid.MoveDirection * (humanoid.WalkSpeed or 16)
					end
				end
			end
			
			local prediction = self.funcs.calculate_prediction(target_position, target_velocity)
			local predicted_position = target_position + (target_velocity * prediction)
			
			local aim_type = Stranded.aimbot.type or "Camera"
			local easing_type = Stranded.aimbot.easing.type or "Linear"
			local smoothness_enabled = Stranded.aimbot.settings.smoothness_enabled
			local smoothness = smoothness_enabled and (Stranded.aimbot.settings.smoothness or 1) or 1
			local has_bezier_preset = self.funcs.get_easing_bezier_points(easing_type) ~= nil
			local bezier_enabled = (Stranded.aimbot.easing.bezier_curves_enabled and Stranded.aimbot.easing.bezier_curves) or has_bezier_preset
			
			if aim_type == "Camera" then
				local current_cframe = camera.CFrame
				local direction_to_target = (predicted_position - current_cframe.Position).Unit
				local target_cframe = CFrame.new(current_cframe.Position, current_cframe.Position + direction_to_target)
				
				if bezier_enabled then
					if not self.aimbot_cache.bezier_t then
						self.aimbot_cache.bezier_t = 0
						self.aimbot_cache.bezier_p0 = current_cframe.Position
						self.aimbot_cache.bezier_p1 = nil
						self.aimbot_cache.bezier_p2 = nil
						self.aimbot_cache.bezier_p3 = predicted_position
					end
					
					local easing_type = Stranded.aimbot.easing.type or "Linear"
					local use_custom = Stranded.aimbot.easing.custom_easing
					
					if not self.aimbot_cache.bezier_p1 or not self.aimbot_cache.bezier_p2 or self.aimbot_cache.last_custom_easing_camera ~= use_custom or self.aimbot_cache.last_easing_type_camera ~= easing_type or self.aimbot_cache.last_target_pos ~= predicted_position then
						local start_dir = current_cframe.LookVector
						local end_dir = direction_to_target
						self.aimbot_cache.bezier_p0, self.aimbot_cache.bezier_p1, self.aimbot_cache.bezier_p2, self.aimbot_cache.bezier_p3 = 
							self.funcs.get_bezier_control_points(current_cframe.Position, predicted_position, start_dir, end_dir)
						self.aimbot_cache.last_custom_easing_camera = use_custom
						self.aimbot_cache.last_easing_type_camera = easing_type
						self.aimbot_cache.last_target_pos = predicted_position
					end
					
					if self.aimbot_cache.target ~= self.aimbot_cache.last_bezier_target then
						self.aimbot_cache.bezier_t = 0
						self.aimbot_cache.bezier_p0 = current_cframe.Position
						local start_dir = current_cframe.LookVector
						local end_dir = direction_to_target
						self.aimbot_cache.bezier_p0, self.aimbot_cache.bezier_p1, self.aimbot_cache.bezier_p2, self.aimbot_cache.bezier_p3 = 
							self.funcs.get_bezier_control_points(current_cframe.Position, predicted_position, start_dir, end_dir)
						self.aimbot_cache.last_bezier_target = self.aimbot_cache.target
						self.aimbot_cache.last_easing_type_camera = easing_type
						self.aimbot_cache.last_target_pos = predicted_position
					end
					
					local bezier_speed = Stranded.aimbot.easing.speed or 1
					local new_t = self.aimbot_cache.bezier_t + (bezier_speed * 0.05)
					self.aimbot_cache.bezier_t = new_t < 1 and new_t or 1
					
					local bezier_point = self.funcs.calculate_bezier_point(
						self.aimbot_cache.bezier_t,
						self.aimbot_cache.bezier_p0,
						self.aimbot_cache.bezier_p1,
						self.aimbot_cache.bezier_p2,
						self.aimbot_cache.bezier_p3
					)
					
					local bezier_direction = (bezier_point - current_cframe.Position).Unit
					local new_cframe = CFrame.new(current_cframe.Position, current_cframe.Position + bezier_direction)
					camera.CFrame = new_cframe
				elseif smoothness_enabled then
					local easing_type = Stranded.aimbot.easing.type or "Linear"
					local easing_speed = Stranded.aimbot.easing.speed or 1
					local smooth_factor = math.clamp(1 / smoothness, 0.01, 1)
					
					local current_look = current_cframe.LookVector
					local target_look = target_cframe.LookVector
					
					local dot = current_look:Dot(target_look)
					if dot > 0.9999 then
						camera.CFrame = target_cframe
					else
						local base_lerp = smooth_factor * easing_speed * 0.1
						local lerp_factor = base_lerp
						
						if easing_type == "Smooth" then
							lerp_factor = base_lerp * 0.5
						elseif easing_type == "Fast" then
							lerp_factor = base_lerp * 2
						end
						
						local new_look = current_look:Lerp(target_look, lerp_factor)
						camera.CFrame = CFrame.new(current_cframe.Position, current_cframe.Position + new_look)
					end
				else
					camera.CFrame = target_cframe
				end
			elseif aim_type == "Mouse" then
				local screen_pos, on_screen = camera:WorldToViewportPoint(predicted_position)
				if on_screen then
					local mouse = self.vars.uis:GetMouseLocation()
					local target_screen = Vector2.new(screen_pos.X, screen_pos.Y)
					
					if bezier_enabled then
						if not self.aimbot_cache.bezier_t_mouse then
							self.aimbot_cache.bezier_t_mouse = 0
							self.aimbot_cache.bezier_p0_mouse = mouse
							self.aimbot_cache.bezier_p3_mouse = target_screen
						end
						
						local use_custom = Stranded.aimbot.easing.custom_easing
						local distance = (target_screen - mouse).Magnitude
						
						if not self.aimbot_cache.bezier_p1_mouse or not self.aimbot_cache.bezier_p2_mouse or self.aimbot_cache.last_custom_easing ~= use_custom or self.aimbot_cache.last_target_screen ~= target_screen then
							if use_custom then
								local cp1_x = Stranded.aimbot.easing.control_point_1_x or 0.3
								local cp1_y = Stranded.aimbot.easing.control_point_1_y or 0.1
								local cp2_x = Stranded.aimbot.easing.control_point_2_x or 0.7
								local cp2_y = Stranded.aimbot.easing.control_point_2_y or 0.9
								
								local direction = (target_screen - mouse)
								local perp = Vector2.new(-direction.Y, direction.X).Unit
								
								self.aimbot_cache.bezier_p0_mouse = mouse
								self.aimbot_cache.bezier_p1_mouse = mouse + (direction * cp1_x) + (perp * distance * cp1_y * 0.5)
								self.aimbot_cache.bezier_p2_mouse = mouse + (direction * cp2_x) + (perp * distance * cp2_y * 0.5)
								self.aimbot_cache.bezier_p3_mouse = target_screen
							else
								local start_dir = (target_screen - mouse).Unit
								local end_dir = start_dir
								local control_distance = math.min(distance * 0.3, 200)
								
								self.aimbot_cache.bezier_p0_mouse = mouse
								self.aimbot_cache.bezier_p1_mouse = mouse + (start_dir * control_distance)
								self.aimbot_cache.bezier_p2_mouse = target_screen - (end_dir * control_distance)
								self.aimbot_cache.bezier_p3_mouse = target_screen
							end
							self.aimbot_cache.last_custom_easing = use_custom
							self.aimbot_cache.last_target_screen = target_screen
						end
						
						if self.aimbot_cache.target ~= self.aimbot_cache.last_bezier_target_mouse then
							self.aimbot_cache.bezier_t_mouse = 0
							self.aimbot_cache.bezier_p0_mouse = mouse
							
							if use_custom then
								local cp1_x = Stranded.aimbot.easing.control_point_1_x or 0.3
								local cp1_y = Stranded.aimbot.easing.control_point_1_y or 0.1
								local cp2_x = Stranded.aimbot.easing.control_point_2_x or 0.7
								local cp2_y = Stranded.aimbot.easing.control_point_2_y or 0.9
								
								local direction = (target_screen - mouse)
								local perp = Vector2.new(-direction.Y, direction.X).Unit
								
								self.aimbot_cache.bezier_p0_mouse = mouse
								self.aimbot_cache.bezier_p1_mouse = mouse + (direction * cp1_x) + (perp * distance * cp1_y * 0.5)
								self.aimbot_cache.bezier_p2_mouse = mouse + (direction * cp2_x) + (perp * distance * cp2_y * 0.5)
								self.aimbot_cache.bezier_p3_mouse = target_screen
							else
								local start_dir = (target_screen - mouse).Unit
								local end_dir = start_dir
								local control_distance = math.min(distance * 0.3, 200)
								
								self.aimbot_cache.bezier_p0_mouse = mouse
								self.aimbot_cache.bezier_p1_mouse = mouse + (start_dir * control_distance)
								self.aimbot_cache.bezier_p2_mouse = target_screen - (end_dir * control_distance)
								self.aimbot_cache.bezier_p3_mouse = target_screen
							end
							self.aimbot_cache.last_bezier_target_mouse = self.aimbot_cache.target
							self.aimbot_cache.last_target_screen = target_screen
						end
						
						local bezier_speed = Stranded.aimbot.easing.speed or 1
						local new_t = self.aimbot_cache.bezier_t_mouse + (bezier_speed * 0.05)
						self.aimbot_cache.bezier_t_mouse = new_t < 1 and new_t or 1
						
						if self.aimbot_cache.bezier_t_mouse >= 1 then
							local delta = target_screen - mouse
							if math.abs(delta.X) > 0.1 or math.abs(delta.Y) > 0.1 then
								if mousemoverel then
									mousemoverel(delta.X, delta.Y)
								end
							end
						else
							local bezier_point = self.funcs.calculate_bezier_point(
								self.aimbot_cache.bezier_t_mouse,
								self.aimbot_cache.bezier_p0_mouse,
								self.aimbot_cache.bezier_p1_mouse,
								self.aimbot_cache.bezier_p2_mouse,
								self.aimbot_cache.bezier_p3_mouse
							)
							
							local delta_x = bezier_point.X - mouse.X
							local delta_y = bezier_point.Y - mouse.Y
							if math.abs(delta_x) > 0.1 or math.abs(delta_y) > 0.1 then
								if mousemoverel then
									mousemoverel(delta_x, delta_y)
								end
							end
						end
					elseif smoothness_enabled then
						local delta = target_screen - mouse
						local distance = delta.Magnitude
						
						if distance > 0.1 then
							local easing_type = Stranded.aimbot.easing.type or "Linear"
							local easing_speed = Stranded.aimbot.easing.speed or 1
							local smooth_factor = math.clamp(1 / smoothness, 0.01, 1)
							local base_lerp = smooth_factor * easing_speed * 0.1
							local lerp_factor = base_lerp
							
							if easing_type == "Smooth" then
								lerp_factor = base_lerp * 0.5
							elseif easing_type == "Fast" then
								lerp_factor = base_lerp * 2
							end
							
							local move_delta = delta * lerp_factor
							if mousemoverel then
								mousemoverel(move_delta.X, move_delta.Y)
							end
						end
					else
						local delta_x = target_screen.X - mouse.X
						local delta_y = target_screen.Y - mouse.Y
						if math.abs(delta_x) > 0.1 or math.abs(delta_y) > 0.1 then
							if mousemoverel then
								mousemoverel(delta_x, delta_y)
							end
						end
					end
				end
			end
		end,
		setup_hitsound_detection = function(player)
			if not player or player == self.vars.local_player then return end
			
			if self.hitsound_cache.connections[player] then
				self.hitsound_cache.connections[player]:Disconnect()
			end
			
			local function setup_character(char) --ai made this 
				if not char then return end
				
				local humanoid = char:FindFirstChildOfClass("Humanoid")
				if not humanoid then return end
				
				local last_health = humanoid.Health
				self.hitsound_cache.player_health[player] = last_health
				
				local body_effects = char:FindFirstChild("BodyEffects")
				local armor_value = body_effects and body_effects:FindFirstChild("Armor")
				local initial_armor = armor_value and armor_value.Value or 0
				if not self.hitsound_cache.player_armor then
					self.hitsound_cache.player_armor = {}
				end
				self.hitsound_cache.player_armor[player] = initial_armor
				
				local last_hit_time = 0
				local debounce_time = 0.05
				
				local health_connection = humanoid.HealthChanged:Connect(function(new_health)
					local local_char = self.vars.local_player and self.vars.local_player.Character
					if not local_char then return end
					
					if not char or not char.Parent then return end
					
					local body_effects = char:FindFirstChild("BodyEffects")
					local armor_value = body_effects and body_effects:FindFirstChild("Armor")
					local current_armor = armor_value and armor_value.Value or 0
					
					local stored_health = self.hitsound_cache.player_health[player]
					if not self.hitsound_cache.player_armor then
						self.hitsound_cache.player_armor = {}
					end
					local stored_armor = self.hitsound_cache.player_armor[player] or 0
					
					if not stored_health then
						self.hitsound_cache.player_health[player] = new_health
						self.hitsound_cache.player_armor[player] = current_armor
						return
					end
					
					local last_health = stored_health
					local last_armor = stored_armor
					
					local health_damage = last_health - new_health
					local armor_damage = last_armor - current_armor
					local total_damage = health_damage + armor_damage
					
					if total_damage > 0 and (new_health < last_health or current_armor < last_armor) then
						local current_time = tick()
						
						if current_time - last_hit_time < debounce_time then
							self.hitsound_cache.player_health[player] = new_health
							self.hitsound_cache.player_armor[player] = current_armor
							return
						end
						
						local local_root = local_char:FindFirstChild("HumanoidRootPart")
						local target_root = char:FindFirstChild("HumanoidRootPart")
						
						if local_root and target_root then
							local distance = (local_root.Position - target_root.Position).Magnitude
							
							if distance < 200 then
								last_hit_time = current_time
								
								if Stranded.hitsounds.enabled then
									task.spawn(function()
										esp.funcs.play_hitsound()
									end)
								end
								
								if Stranded.hiteffects.enabled then
									task.spawn(function()
										esp.funcs.create_hit_effect(player)
									end)
								end
							end
						end
					end
					
					self.hitsound_cache.player_health[player] = new_health
					self.hitsound_cache.player_armor[player] = current_armor
				end)
				
				self.hitsound_cache.connections[player] = health_connection
			end
			
			if player.Character then
				setup_character(player.Character)
			end
			
			player.CharacterAdded:Connect(function(char)
				setup_character(char)
			end)
		end,
		update_hitbox_expander = function()
			if not Stranded.hitbox_expander.enabled then
				for player, highlight in pairs(esp.hitbox_expander_cache or {}) do
					if highlight and highlight.Parent then
						highlight:Destroy()
					end
					if player and player.Character then
						local hrp = player.Character:FindFirstChild("HumanoidRootPart")
						if hrp then
							hrp.Size = Vector3.new(2, 2, 1)
							hrp.Transparency = 1
						end
					end
				end
				esp.hitbox_expander_cache = {}
				return
			end
			
			if not esp.hitbox_expander_cache then
				esp.hitbox_expander_cache = {}
			end
			
			for _, player in ipairs(self.vars.players:GetPlayers()) do
				if player ~= self.vars.local_player then
					if player.Character then
						local hrp = player.Character:FindFirstChild("HumanoidRootPart")
						if hrp then
							local is_whitelisted = false
							for _, whitelisted_player in ipairs(Stranded.hitbox_expander.whitelist or {}) do
								if whitelisted_player == player then
									is_whitelisted = true
									break
								end
							end
							
							if not is_whitelisted then
								local width = Stranded.hitbox_expander.width or 37
								local length = Stranded.hitbox_expander.length or 37
								hrp.Size = Vector3.new(width, width, length)
								hrp.CanCollide = false
								
								if Stranded.hitbox_expander.visualize then
									if not esp.hitbox_expander_cache[player] then
										local highlight = Instance.new("Highlight")
										highlight.Parent = hrp
										highlight.FillColor = Stranded.hitbox_expander.color or Color3.fromRGB(155, 125, 175)
										highlight.OutlineColor = Stranded.hitbox_expander.outline_color or Color3.fromRGB(155, 125, 175)
										highlight.FillTransparency = Stranded.hitbox_expander.fill_transparency or 0.5
										highlight.OutlineTransparency = Stranded.hitbox_expander.outline_transparency or 0.3
										hrp.Transparency = 0.9
										esp.hitbox_expander_cache[player] = highlight
									else
										local highlight = esp.hitbox_expander_cache[player]
										if highlight and highlight.Parent then
											highlight.FillColor = Stranded.hitbox_expander.color or Color3.fromRGB(155, 125, 175)
											highlight.OutlineColor = Stranded.hitbox_expander.outline_color or Color3.fromRGB(155, 125, 175)
											highlight.FillTransparency = Stranded.hitbox_expander.fill_transparency or 0.5
											highlight.OutlineTransparency = Stranded.hitbox_expander.outline_transparency or 0.3
											hrp.Transparency = 0.9
										end
									end
								else
									if esp.hitbox_expander_cache[player] then
										local highlight = esp.hitbox_expander_cache[player]
										if highlight and highlight.Parent then
											highlight:Destroy()
										end
										esp.hitbox_expander_cache[player] = nil
										hrp.Transparency = 1
									end
								end
							else
								if esp.hitbox_expander_cache[player] then
									local highlight = esp.hitbox_expander_cache[player]
									if highlight and highlight.Parent then
										highlight:Destroy()
									end
									esp.hitbox_expander_cache[player] = nil
								end
								hrp.Size = Vector3.new(2, 2, 1)
								hrp.Transparency = 1
							end
						else
							if esp.hitbox_expander_cache[player] then
								local highlight = esp.hitbox_expander_cache[player]
								if highlight and highlight.Parent then
									highlight:Destroy()
								end
								esp.hitbox_expander_cache[player] = nil
							end
						end
					else
						if esp.hitbox_expander_cache[player] then
							local highlight = esp.hitbox_expander_cache[player]
							if highlight and highlight.Parent then
								highlight:Destroy()
							end
							esp.hitbox_expander_cache[player] = nil
						end
					end
				end
			end
		end,
		update_aura = function()
			if not Stranded.self_aura.enabled then
				if self.aura_cache then
					for _, cache in pairs(self.aura_cache) do
						if cache.emitters then
							for _, emitter in ipairs(cache.emitters) do
								emitter.Enabled = false
							end
						end
					end
				end
				return
			end
			
			local local_player = self.vars.local_player
			if not local_player then return end
			
			local char = local_player.Character
			if not char then
				if self.aura_cache then
					for _, cache in pairs(self.aura_cache) do
						if cache.attachment then
							cache.attachment:Destroy()
						end
						if cache.attachments then
							for _, att in ipairs(cache.attachments) do
								att:Destroy()
							end
						end
					end
					self.aura_cache = {}
				end
				return
			end
			
			local current_types = Stranded.self_aura.type
			if type(current_types) ~= "table" then
				current_types = {current_types}
			end
			
			if not self.aura_cache then
				self.aura_cache = {}
			end
			
			local types_to_remove = {}
			for cached_type, _ in pairs(self.aura_cache) do
				local found = false
				for _, current_type in ipairs(current_types) do
					if cached_type == current_type then
						found = true
						break
					end
				end
				if not found then
					table.insert(types_to_remove, cached_type)
				end
			end
			
			for _, type_to_remove in ipairs(types_to_remove) do
				local cache = self.aura_cache[type_to_remove]
				if cache then
					if cache.attachment then
						cache.attachment:Destroy()
					end
					if cache.attachments then
						for _, att in ipairs(cache.attachments) do
							att:Destroy()
						end
					end
					self.aura_cache[type_to_remove] = nil
				end
			end
			
			for _, current_type in ipairs(current_types) do
				local use_upper_torso = (current_type == "Angel Wings")
				
				local target_part = nil
				if use_upper_torso then
					target_part = char:FindFirstChild("UpperTorso")
				else
					target_part = char:FindFirstChild("LowerTorso")
				end
				
				if not target_part then
					if self.aura_cache[current_type] then
						local cache = self.aura_cache[current_type]
						if cache.attachment then
							cache.attachment:Destroy()
						end
						if cache.attachments then
							for _, att in ipairs(cache.attachments) do
								att:Destroy()
							end
						end
						self.aura_cache[current_type] = nil
					end
					return
				end
				
				if not self.aura_cache[current_type] then
					local attachment = Instance.new("Attachment")
					if use_upper_torso then
						attachment.Position = Vector3.new(0, 0.5, 0)
					end
					attachment.Parent = target_part
					
					local emitters, extra_attachments = self.funcs.create_aura_effect(current_type, attachment, target_part)
					
					self.aura_cache[current_type] = {
						attachment = attachment,
						emitters = emitters,
						attachments = extra_attachments or {}
					}
				else
					local cache = self.aura_cache[current_type]
					if cache.attachment.Parent ~= target_part then
						cache.attachment.Parent = target_part
						if cache.attachments then
							for _, att in ipairs(cache.attachments) do
								att.Parent = target_part
							end
						end
					end
					
					if cache.emitters then
						for _, emitter in ipairs(cache.emitters) do
							emitter.Enabled = true
						end
					end
				end
			end
		end,
		update = function(player)
			if not player then return end
			local cache = self.cache[player]
			if not cache then
				self.funcs.create_cache(player)
				cache = self.cache[player]
				if not cache then return end
			end

			local char = player.Character
			if not char then
				self.funcs.hide_all(cache)
				self.funcs.update_chams(player, cache, nil)
				return
			end
			
			if not char:IsDescendantOf(workspace) then
				self.funcs.hide_all(cache)
				self.funcs.update_chams(player, cache, nil)
				return
			end

			local root = cache.root
			if not root or root.Parent ~= char then
				root = char:FindFirstChild("HumanoidRootPart")
				cache.root = root
				self.funcs.cache_character_parts(char, cache)
			end
			
			local humanoid = cache.humanoid
			if not humanoid or humanoid.Parent ~= char then
				humanoid = char:FindFirstChildWhichIsA("Humanoid")
				cache.humanoid = humanoid
				if not cache.parts then
					self.funcs.cache_character_parts(char, cache)
				end
			end
			
			if not root or not humanoid then
				self.funcs.hide_all(cache)
				self.funcs.update_chams(player, cache, char)
				return
			end
    
			local cam_pos = self.vars.camera.CFrame.Position
			local distance = (cam_pos - root.Position).Magnitude
			
			if distance > 2000 then
				self.funcs.hide_all(cache)
				if cache.skeleton then
					for _, skeleton_data in pairs(cache.skeleton) do
						if skeleton_data.line then skeleton_data.line.Visible = false end
						if skeleton_data.outline then skeleton_data.outline.Visible = false end
					end
				end
				return
			end
			
			local box_size, box_pos, bottom_rendered, top_rendered = self.funcs.calc_box(root.Position)
			
			if box_size and box_pos and bottom_rendered and top_rendered then
				cache.last_pos = root.Position
				cache.last_size = box_size
				self.funcs.update_box(player, box_pos, box_size, cache)
				self.funcs.update_health(player, box_pos, box_size, cache, humanoid)
				self.funcs.update_armor(player, box_pos, box_size, cache, char)
				self.funcs.update_labels(player, box_pos, box_size, cache, char, self.vars.camera, root)
				self.funcs.update_skeleton(player, cache, char)
			else
				self.funcs.hide_all(cache)
			end
			
			if not Stranded.box.enabled then
				local box_full = cache.box and cache.box.full
				if box_full then
					if box_full.square then box_full.square.Visible = false end
					if box_full.outline then box_full.outline.Visible = false end
					if box_full.frame then box_full.frame.Visible = false end
				end
			end
			
			if not Stranded.armor_bar.enabled then
				local armor = cache.bars and cache.bars.armor
				if armor then
					if armor.outline then armor.outline.Visible = false end
					if armor.frame then armor.frame.Visible = false end
					if armor.text then armor.text.Visible = false end
				end
			end
			
			self.funcs.update_chams(player, cache, char)
		end,
	}
	
	self.conns = {}
	self.cache = {}
	self.aura_cache = {}
	self.skeleton_conns = {
			{from = "Head", to = "Neck"},
			{from = "Neck", to = "UpperTorso"},
			{from = "UpperTorso", to = "LowerTorso"},
			{from = "LowerTorso", to = "LeftUpperLeg"},
			{from = "LowerTorso", to = "RightUpperLeg"},
			{from = "LeftUpperLeg", to = "LeftLowerLeg"},
			{from = "RightUpperLeg", to = "RightLowerLeg"},
			{from = "LeftLowerLeg", to = "LeftFoot"},
			{from = "RightLowerLeg", to = "RightFoot"},
			{from = "UpperTorso", to = "LeftUpperArm"},
			{from = "UpperTorso", to = "RightUpperArm"},
			{from = "LeftUpperArm", to = "LeftLowerArm"},
			{from = "RightUpperArm", to = "RightLowerArm"},
			{from = "LeftLowerArm", to = "LeftHand"},
			{from = "RightLowerArm", to = "RightHand"}
	}
	
	self.cache_manager = {
		players = {},
		set_data = function(self, player, data)
			self.players[player] = data
		end,
		remove = function(self, player)
			self.players[player] = nil
		end,
	}
	
	self.fonts = {
		folder = "DICK",
		new = function(font_self, name, weight, style, data)
			local json = font_self.folder .. "/" .. name .. ".json"
			local ttf = font_self.folder .. "/" .. name .. ".ttf"
			
			if isfile(json) then
				return Font.new(getcustomasset(json))
			end
			
			if not isfile(ttf) then 
				writefile(ttf, self.vars.game:HttpGet(data.Url))
			end
			
			local font_data = {
				Name = name,
				Faces = {{Name = "Regular", Weight = weight, Style = style, AssetId = getcustomasset(ttf)}}
			}
			
			writefile(json, self.vars.http:JSONEncode(font_data))
			return Font.new(getcustomasset(json))
		end,
		get = function(font_self, name)
			local json = font_self.folder .. "/" .. name .. ".json"
			return isfile(json) and Font.new(getcustomasset(json)) or nil
		end,
	}
	
	self.gui_inset = nil
end

esp.init = function()
	esp.vars.players = esp.vars.game:GetService("Players")
	esp.vars.rs = esp.vars.game:GetService("RunService")
	esp.vars.gs = esp.vars.game:GetService("GuiService")
	esp.vars.uis = esp.vars.game:GetService("UserInputService")
	esp.vars.http = esp.vars.game:GetService("HttpService")
	esp.vars.core_gui = esp.vars.game:GetService("CoreGui")
	esp.vars.local_player = esp.vars.players.LocalPlayer
	esp.vars.camera = workspace.CurrentCamera
	
	if not isfolder(esp.fonts.folder) then
		makefolder(esp.fonts.folder)
	end
	
	esp.fonts:new("WindowsXpTahoma", 200, "Regular", {Url = "https://github.com/sametexe001/luas/raw/refs/heads/main/fonts/smallest_pixel-7.ttf"})
	local default_font = esp.fonts:get("WindowsXpTahoma") or Enum.Font.Gotham
	Stranded.box.font = default_font
	Stranded.fonts.labels = Stranded.fonts.labels or default_font
	
	esp.gui_inset = esp.vars.gs:GetGuiInset()
	
	if esp.vars.local_player then
		if esp.vars.local_player.Character then
			task.spawn(function()
				task.wait(0.1)
				esp.funcs.update_self_material()
				esp.funcs.update_self_tool_material()
			end)
		end
	esp.vars.local_player.CharacterAdded:Connect(function()
		task.wait(0.1)
		esp.funcs.update_self_material()
		esp.funcs.update_self_tool_material()
		esp.funcs.setup_bullet_tracer_detection()
	end)
	
	esp.funcs.setup_bullet_tracer_detection()
	end
	
	for _, player in ipairs(esp.vars.players:GetPlayers()) do
		if player and player ~= esp.vars.local_player then
			esp.funcs.create_cache(player)
			if player.Character then
				esp.funcs.update(player)
				esp.funcs.setup_hitsound_detection(player)
			else
				player.CharacterAdded:Connect(function()
					esp.funcs.update(player)
					esp.funcs.setup_hitsound_detection(player)
				end)
			end
        end
    end
    
	esp.vars.players.PlayerAdded:Connect(function(player)
		if player ~= esp.vars.local_player then
			esp.funcs.create_cache(player)
			if player.Character then
				esp.funcs.update(player)
				esp.funcs.setup_hitsound_detection(player)
			else
				player.CharacterAdded:Connect(function()
					esp.funcs.update(player)
					esp.funcs.setup_hitsound_detection(player)
				end)
			end
        end
    end)
    
	esp.hitbox_expander_cache = {}
	
	esp.vars.players.PlayerRemoving:Connect(function(player)
		if player ~= esp.vars.local_player then
			esp.funcs.clear(player)
			if esp.hitbox_expander_cache[player] then
				local highlight = esp.hitbox_expander_cache[player]
				if highlight and highlight.Parent then
					highlight:Destroy()
				end
				esp.hitbox_expander_cache[player] = nil
			end
		end
		if esp.hitsound_cache.connections[player] then
			esp.hitsound_cache.connections[player]:Disconnect()
			esp.hitsound_cache.connections[player] = nil
		end
		if esp.hitsound_cache.player_health[player] then
			esp.hitsound_cache.player_health[player] = nil
		end
		if esp.hitsound_cache.player_armor and esp.hitsound_cache.player_armor[player] then
			esp.hitsound_cache.player_armor[player] = nil
		end
		if esp.hitsound_cache.hit_effects[player] then
			local effect = esp.hitsound_cache.hit_effects[player]
			if effect and effect.Parent then
				effect:Destroy()
			end
			esp.hitsound_cache.hit_effects[player] = nil
		end
	end)
    
	esp.conns.main = esp.conns.main or {}
	local LastVisualsUpdate = 0
	local VisualsFPS = 140
	local VisualsFrameTime = 1 / VisualsFPS
	esp.conns.main.render_stepped = esp.vars.rs.RenderStepped:Connect(function()
		esp.funcs.viewmodel_changer_update()
		esp.funcs.fov_changer_update()
		
		local CurrentTime = tick()
		if CurrentTime - LastVisualsUpdate >= VisualsFrameTime then
			esp.vars.camera = workspace.CurrentCamera
			esp.funcs.update_fov()
			esp.funcs.update_animegirls()
			esp.funcs.update_lighting()
			esp.funcs.update_aura()
			esp.funcs.update_hitbox_expander()
			esp.funcs.update_self_material()
			esp.funcs.update_self_tool_material()
			esp.funcs.aimbot_update()
			esp.funcs.target_aim_update()
			
			for _, player in ipairs(esp.vars.players:GetPlayers()) do
				if player and player ~= esp.vars.local_player then
					if not esp.cache[player] then
						esp.funcs.create_cache(player)
					end
					if esp.cache[player] then
						esp.funcs.update(player)
					end
				end
			end
			
			for _, player in ipairs(esp.vars.players:GetPlayers()) do
				if player and player ~= esp.vars.local_player then
					local cache = esp.cache[player]
					if cache then
						if not Stranded.box.enabled then
							if cache.box and cache.box.full then
								local box_full = cache.box.full
								if box_full.square then box_full.square.Visible = false end
								if box_full.outline then box_full.outline.Visible = false end
								if box_full.frame then box_full.frame.Visible = false end
							end
						end
						
						if not Stranded.skeleton.enabled then
							if cache.skeleton then
								for _, skeleton_data in pairs(cache.skeleton) do
									if skeleton_data.line then skeleton_data.line.Visible = false end
									if skeleton_data.outline then skeleton_data.outline.Visible = false end
								end
							end
						end
						
						if not Stranded.health_bar.enabled then
							if cache.bars and cache.bars.health then
								local health = cache.bars.health
								if health.outline then health.outline.Visible = false end
								if health.frame then health.frame.Visible = false end
								if health.text then health.text.Visible = false end
							end
						end
					end
				end
			end
			
			if not Stranded.fov.enabled then
				if esp.fov_cache then
					if esp.fov_cache.circle then esp.fov_cache.circle.Visible = false end
					if esp.fov_cache.outline then esp.fov_cache.outline.Visible = false end
					if esp.fov_cache.frame then esp.fov_cache.frame.Visible = false end
					if esp.fov_cache.label then esp.fov_cache.label.Visible = false end
				end
			end
			LastVisualsUpdate = CurrentTime
		end
	end)
end

esp.init()

esp.conns.main.heartbeat = esp.vars.rs.Heartbeat:Connect(function()
	esp.funcs.target_strafe_update()
	esp.funcs.cframe_movement_update()
	esp.funcs.fly_movement_update()
	esp.funcs.hipheight_update()
	esp.funcs.jumppower_update()
	esp.funcs.gravity_update()
	esp.funcs.anti_stomp_update()
	esp.funcs.autofarm_update()
	esp.funcs.auto_collect_update()
	esp.funcs.autobuy_update()
	esp.funcs.auto_reload_update()
	esp.funcs.chat_spammer_update()
	esp.funcs.animation_player_update()
	esp.funcs.avatar_changer_update()
	esp.funcs.apply_desync()
	esp.funcs.apply_break_move_direction()
	esp.funcs.apply_fakepos()
	esp.funcs.apply_anti_fling()
	esp.funcs.apply_spinbot()
	esp.funcs.update_server_hrp_visualizer()
end)

task.spawn(function()
	if esp.vars.local_player then
		esp.vars.local_player.CharacterAdded:Connect(function()
			esp.anti_afk_connected = false
			esp.anti_stomp_connected = false
			
			if Stranded.automation and Stranded.automation.anti_afk and Stranded.automation.anti_afk.enabled then
				esp.funcs.anti_afk_update()
			end
			
			task.wait(1)
			if Stranded.automation and Stranded.automation.anti_stomp and Stranded.automation.anti_stomp.enabled then
				esp.funcs.anti_stomp_update()
			end
		end)
		
		esp.funcs.anti_afk_update()
		task.wait(3)
		esp.funcs.anti_stomp_update()
	end
end)

pcall(function()
	local main_event = game:GetService("ReplicatedStorage"):FindFirstChild("MainEvent")
	if main_event then
		local b = {"CHECKER_1", "TeleportDetect", "OneMoreTime"}
		local c
		c = hookmetamethod(game, "__namecall", function(...)
			local d = {...}
			local self_obj = d[1]
			local e = getnamecallmethod()
			local f = getcallingscript()
			if e == "FireServer" and self_obj == main_event and table.find(b, d[2]) then
				return
			end
			return c(...)
		end)
	end
end)

esp.funcs.setup_target_aim_hook()
esp.funcs.setup_silent_aim_hook()
esp.funcs.setup_triggerbot()
esp.funcs.setup_gun_mods()

local Window = Library:Window({Name = "stranded . lol", Size = UDim2.new(0, 675, 0, 650), FadeSpeed = 0.25})

local marketplace_service = game:GetService("MarketplaceService")

local success_place, place_info = pcall(function() 
	return marketplace_service:GetProductInfo(game.PlaceId) 
end)
if success_place and place_info then
	place_name = place_info.Name
end
local Watermark = Library:Watermark("Stranded ~ ".. os.date("%b %d %Y") .. " ~ ".. place_name)
local KeybindList = Library:KeybindList()

Watermark:SetVisibility(false)
KeybindList:SetVisibility(false)

local LPH_NO_VIRTUALIZE = LPH_NO_VIRTUALIZE or function(f) return f() end

local success_ui, err = pcall(function()
	LPH_NO_VIRTUALIZE(function()
		local VisualsTab = Window:Page({Name = "Visuals", Columns = 2, Subtabs = false})
	local CombatTab = Window:Page({Name = "Combat", Columns = 2, Subtabs = false})
	local RageTab = Window:Page({Name = "Rage", Columns = 2, Subtabs = true})
	local RageMainSubTab = RageTab:SubPage({Icon = "79080568477801", Columns = 2})
	local RageMovementSubTab = RageTab:SubPage({Icon = "84929780240463", Columns = 2})
	local MiscTab = Window:Page({Name = "Misc", Columns = 2, Subtabs = true})
	local Main_Misc = MiscTab:SubPage({Icon = "79080568477801", Columns = 2})
	local Teloports_misc = MiscTab:SubPage({Icon = "84929780240463", Columns = 2})
	local PlayersTab = Window:Page({Name = "Players", Columns = 2, Subtabs = false})
	local SettingsTab = Window:Page({Name = "Settings", Columns = 2, Subtabs = false})
	
	-- Playerlist Section (from headshots.cc)
	do
		local playerlist_section = PlayersTab:Section({Name = "Playerlist", Side = 1})
		
		local playerlist_data = {}
		local selected_button = nil
		local InstancesRef = Instances
		
		local patterns = {
			["Priority"] = Color3.fromRGB(255, 255, 0),
			["Enemy"] = Color3.fromRGB(255, 0, 0),
			["Neutral"] = Library.Theme.Text,
			["Friendly"] = Color3.fromRGB(0, 255, 255)
		}
		
		task.spawn(function()
			task.wait(0.1)
			
			local list = InstancesRef:Create("Frame", {
				Parent = playerlist_section.Elements["Content"].Instance,
				Name = "\0",
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				Size = UDim2.new(1, -2, 0, 300),
				BorderSizePixel = 0,
				BackgroundColor3 = Library.Theme.Outline
			})
			list:AddToTheme({BackgroundColor3 = "Outline"})
			
			local inline = InstancesRef:Create("Frame", {
				Parent = list.Instance,
				Name = "\0",
				Position = UDim2.new(0, 1, 0, 1),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				Size = UDim2.new(1, -2, 1, -2),
				BorderSizePixel = 0,
				BackgroundColor3 = Library.Theme.Inline
			})
			inline:AddToTheme({BackgroundColor3 = "Inline"})
			
			local ScrollingFrame = InstancesRef:Create("ScrollingFrame", {
				Parent = inline.Instance,
				Name = "\0",
				ScrollBarImageColor3 = Library.Theme.Accent,
				Active = true,
				AutomaticCanvasSize = Enum.AutomaticSize.Y,
				ScrollBarThickness = 2,
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				CanvasSize = UDim2.new(0, 0, 0, 0)
			})
			ScrollingFrame:AddToTheme({ScrollBarImageColor3 = "Accent"})
			
			InstancesRef:Create("UIPadding", {
				Parent = ScrollingFrame.Instance,
				PaddingTop = UDim.new(0, 4),
				PaddingBottom = UDim.new(0, 4),
				PaddingRight = UDim.new(0, 4),
				PaddingLeft = UDim.new(0, 4)
			})
			
			InstancesRef:Create("UIListLayout", {
				Parent = ScrollingFrame.Instance,
				Padding = UDim.new(0, 4),
				SortOrder = Enum.SortOrder.LayoutOrder
			})
		
			local function create_player(player)
				playerlist_data[tostring(player)] = {}
				local path = playerlist_data[tostring(player)]
				
				local TextButton = InstancesRef:Create("TextButton", {
					Parent = ScrollingFrame.Instance,
					Name = "\0",
					FontFace = Library.Font,
					TextColor3 = Library.Theme.Text,
					BorderColor3 = Color3.fromRGB(0, 0, 0),
					Text = "",
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 0, 0),
					BorderSizePixel = 0,
					AutomaticSize = Enum.AutomaticSize.Y,
					TextSize = 12,
					BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				})
				TextButton:AddToTheme({TextColor3 = "Text"})
				
				local player_name = InstancesRef:Create("TextLabel", {
					Parent = TextButton.Instance,
					FontFace = Library.Font,
					TextColor3 = Library.Theme.Text,
					BorderColor3 = Color3.fromRGB(0, 0, 0),
					Text = tostring(player),
					BorderSizePixel = 0,
					BackgroundTransparency = 1,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextTruncate = Enum.TextTruncate.AtEnd,
					AutomaticSize = Enum.AutomaticSize.Y,
					TextSize = 12,
					LayoutOrder = -100,
					BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				})
				player_name:AddToTheme({TextColor3 = "Text"})
				
				local priority_text = InstancesRef:Create("TextLabel", {
					Parent = TextButton.Instance,
					Name = "\0",
					FontFace = Library.Font,
					TextColor3 = tostring(player) ~= LocalPlayer.Name and Library.Theme.Text or Color3.fromRGB(0, 0, 255),
					BorderColor3 = Color3.fromRGB(0, 0, 0),
					Text = tostring(player) ~= LocalPlayer.Name and "Neutral" or "LocalPlayer",
					BackgroundTransparency = 1,
					TextXAlignment = Enum.TextXAlignment.Right,
					BorderSizePixel = 0,
					AutomaticSize = Enum.AutomaticSize.Y,
					TextSize = 12,
					BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				})
				priority_text:AddToTheme({TextColor3 = "Text"})
				
				InstancesRef:Create("UIListLayout", {
					Parent = TextButton.Instance,
					FillDirection = Enum.FillDirection.Horizontal,
					HorizontalFlex = Enum.UIFlexAlignment.Fill,
					SortOrder = Enum.SortOrder.LayoutOrder,
					VerticalFlex = Enum.UIFlexAlignment.Fill
				})
				
				InstancesRef:Create("UIPadding", {
					Parent = TextButton.Instance,
					PaddingRight = UDim.new(0, 2),
					PaddingLeft = UDim.new(0, 2)
				})
				
				local line = InstancesRef:Create("Frame", {
					Parent = ScrollingFrame.Instance,
					Name = "\0",
					BorderColor3 = Color3.fromRGB(0, 0, 0),
					Size = UDim2.new(1, 0, 0, 1),
					BorderSizePixel = 0,
					BackgroundColor3 = Library.Theme.Outline
				})
				line:AddToTheme({BackgroundColor3 = "Outline"})
				
				path.instance = TextButton
				path.line = line
				path.priority = "Neutral"
				path.priority_text = priority_text
				
				TextButton.Instance.MouseButton1Click:Connect(function()
					if tostring(player) == LocalPlayer.Name then
						return
					end
					
					if selected_button then
						selected_button.Instance.TextColor3 = Library.Theme.Text
						selected_button = nil
					end
					
					selected_button = player_name
					player_name.Instance.TextColor3 = Library.Theme.Accent
				end)
				
				return path
			end
			
			local function remove_player(player)
				local path = playerlist_data[tostring(player)]
				if path and path.instance and path.instance.Instance then
					path.instance.Instance:Destroy()
				end
				if path and path.line and path.line.Instance then
					path.line.Instance:Destroy()
				end
				playerlist_data[tostring(player)] = nil
			end
			
			Library:Connect(Players.PlayerAdded, function(player)
				create_player(player)
			end, "Playerlist PlayerAdded")
			
			Library:Connect(Players.PlayerRemoving, function(player)
				remove_player(player)
			end, "Playerlist PlayerRemoving")
			
			for _, player in ipairs(Players:GetPlayers()) do
				create_player(player)
			end
		end)
	end
	
	do
	local function safe_number(value, default)
		if value and type(value) == "number" and not (value ~= value) and value == value then
			return value
		end
		return default or 0
	end
	
	if not Stranded.lighting then
		Stranded.lighting = {}
	end
	if not Stranded.lighting.fog then
		Stranded.lighting.fog = {}
	end
	if not Stranded.lighting.ambience then
		Stranded.lighting.ambience = {}
	end
	if Stranded.lighting.ambience.enabled == nil then
		Stranded.lighting.ambience.enabled = false
	end
	if Stranded.lighting.ambience.outdoor_ambient_enabled == nil then
		Stranded.lighting.ambience.outdoor_ambient_enabled = false
	end
	local fog_start = Stranded.lighting.fog.start
	if type(fog_start) ~= "number" or fog_start ~= fog_start then
		Stranded.lighting.fog.start = 0
	else
		Stranded.lighting.fog.start = math.clamp(math.floor(fog_start), 0, 1000)
	end
	
	local fog_ending = Stranded.lighting.fog.ending
	if type(fog_ending) ~= "number" or fog_ending ~= fog_ending then
		Stranded.lighting.fog.ending = 500
	else
		Stranded.lighting.fog.ending = math.clamp(math.floor(fog_ending), 0, 1000)
	end
	
	local visuals_section = VisualsTab:Section({Name = "Visuals", Side = 1})
	local lighting_section = VisualsTab:Section({Name = "World", Side = 2})
	local self_section = VisualsTab:Section({Name = "Self", Side = 2})
	local misc_section = VisualsTab:Section({Name = "Misc", Side = 1})
	
	visuals_section:Toggle({Name = "Master Switch", Flag = "Visuals Master Switch", Default = Stranded.visuals_enabled, Callback = function(Value)
		Stranded.visuals_enabled = Value
	end})
	
	local font_names = {
		"Legacy", "Gotham", "GothamBold", "GothamSemibold", "GothamMedium",
		"SourceSans", "SourceSansBold", "SourceSansItalic", "SourceSansSemibold",
		"Arial", "ArialBold", "Code", "FredokaOne", "Highway",
		"IndieFlower", "JosefinSans", "Jura", "Kalam", "Merriweather", "Oswald",
		"PatrickHand", "PermanentMarker", "Roboto", "RobotoCondensed", "RobotoMono",
		"Sarpanch", "SciFi", "SpecialElite", "TitilliumWeb", "Ubuntu"
	}
	
	local font_map = {
		Legacy = Enum.Font.Legacy,
		Gotham = Enum.Font.Gotham,
		GothamBold = Enum.Font.GothamBold,
		GothamSemibold = Enum.Font.GothamSemibold,
		GothamMedium = Enum.Font.GothamMedium,
		SourceSans = Enum.Font.SourceSans,
		SourceSansBold = Enum.Font.SourceSansBold,
		SourceSansItalic = Enum.Font.SourceSansItalic,
		SourceSansSemibold = Enum.Font.SourceSansSemibold,
		Arial = Enum.Font.Arial,
		ArialBold = Enum.Font.ArialBold,
		Code = Enum.Font.Code,
		FredokaOne = Enum.Font.FredokaOne,
		Highway = Enum.Font.Highway,
		IndieFlower = Enum.Font.IndieFlower,
		JosefinSans = Enum.Font.JosefinSans,
		Jura = Enum.Font.Jura,
		Kalam = Enum.Font.Kalam,
		Merriweather = Enum.Font.Merriweather,
		Oswald = Enum.Font.Oswald,
		PatrickHand = Enum.Font.PatrickHand,
		PermanentMarker = Enum.Font.PermanentMarker,
		Roboto = Enum.Font.Roboto,
		RobotoCondensed = Enum.Font.RobotoCondensed,
		RobotoMono = Enum.Font.RobotoMono,
		Sarpanch = Enum.Font.Sarpanch,
		SciFi = Enum.Font.SciFi,
		SpecialElite = Enum.Font.SpecialElite,
		TitilliumWeb = Enum.Font.TitilliumWeb,
		Ubuntu = Enum.Font.Ubuntu,
	}
	
	local current_esp_font_name = "Gotham"
	if Stranded.fonts.labels then
		for name, font_enum in pairs(font_map) do
			if font_enum == Stranded.fonts.labels then
				current_esp_font_name = name
				break
			end
		end
	end
	
	visuals_section:Dropdown({Name = "Font", Flag = "ESP Font", Default = current_esp_font_name, Items = font_names, Callback = function(Value)
		if font_map[Value] then
			Stranded.fonts.labels = font_map[Value]
			if esp and esp.funcs and esp.funcs.get_font and esp.cache then
				for player, cache in pairs(esp.cache) do
					if cache.text then
						if cache.text.name then
							local font_result = esp.funcs.get_font(Stranded.fonts.labels)
							pcall(function() cache.text.name.FontFace = font_result end)
						end
						if cache.text.display_name then
							local font_result = esp.funcs.get_font(Stranded.fonts.labels)
							pcall(function() cache.text.display_name.FontFace = font_result end)
						end
						if cache.text.tool then
							local font_result = esp.funcs.get_font(Stranded.fonts.labels)
							pcall(function() cache.text.tool.FontFace = font_result end)
						end
						if cache.text.studs then
							local font_result = esp.funcs.get_font(Stranded.fonts.labels)
							pcall(function() cache.text.studs.FontFace = font_result end)
						end
					end
					if cache.bars then
						if cache.bars.health and cache.bars.health.text then
							local font_result = esp.funcs.get_font(Stranded.fonts.labels)
							pcall(function() cache.bars.health.text.FontFace = font_result end)
						end
						if cache.bars.armor and cache.bars.armor.text then
							local font_result = esp.funcs.get_font(Stranded.fonts.labels)
							pcall(function() cache.bars.armor.text.FontFace = font_result end)
						end
					end
				end
			end
		end
	end})
	
	local BoxToggle = visuals_section:Toggle({Name = "Box", Flag = "Box Enabled", Default = Stranded.box.enabled, Callback = function(Value)
		Stranded.box.enabled = Value
	end})
	
	BoxToggle:Colorpicker({Name = "Color", Flag = "Box Color", Default = Stranded.box.color, Callback = function(Value)
		Stranded.box.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.box and cache.box.full then
					local square = cache.box.full.square
					local frame = cache.box.full.frame
					if square then square.Color = Value end
					if frame and not Stranded.box.gradient.enabled then
						frame.BackgroundColor3 = Value
					end
				end
			end
		end
	end})
	
	BoxToggle:Colorpicker({Name = "Outline Color", Flag = "Box Outline Color", Default = Stranded.box.outline_color, Callback = function(Value)
		Stranded.box.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.box and cache.box.full and cache.box.full.outline then
					cache.box.full.outline.Color = Value
				end
			end
		end
	end})
	
	local BoxFilledToggle = visuals_section:Toggle({Name = "Box Filled", Flag = "Box Filled", Default = Stranded.box.filled, Callback = function(Value)
		Stranded.box.filled = Value
	end})
	
	BoxFilledToggle:Colorpicker({Name = "Gradient Top", Flag = "Box Gradient Top", Default = Stranded.box.gradient.top_color, Callback = function(Value)
		Stranded.box.gradient.top_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.box and cache.box.full then
					local gradient = cache.box.full.gradient
					local frame = cache.box.full.frame
					if Stranded.box.gradient.enabled and gradient then
						gradient.Color = ColorSequence.new({
							ColorSequenceKeypoint.new(0, Stranded.box.gradient.top_color),
							ColorSequenceKeypoint.new(1, Stranded.box.gradient.bottom_color)
						})
					elseif frame then
						frame.BackgroundColor3 = Value
					end
				end
			end
		end
	end})
	
	BoxFilledToggle:Colorpicker({Name = "Gradient Bottom", Flag = "Box Gradient Bottom", Default = Stranded.box.gradient.bottom_color, Callback = function(Value)
		Stranded.box.gradient.bottom_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.box and cache.box.full then
					local gradient = cache.box.full.gradient
					if Stranded.box.gradient.enabled and gradient then
						gradient.Color = ColorSequence.new({
							ColorSequenceKeypoint.new(0, Stranded.box.gradient.top_color),
							ColorSequenceKeypoint.new(1, Stranded.box.gradient.bottom_color)
						})
					end
				end
			end
		end
	end})
	

	
	visuals_section:Slider({Name = "Box Gradient Rotation Speed", Min = -20, Max = 20, Default = safe_number(Stranded.box.gradient.rotation_speed, 0), Decimals = 0.1, Compact = true, Flag = "Box Gradient Rotation Speed", Callback = function(Value)
		Stranded.box.gradient.rotation_speed = math.clamp(Value, -20, 20)
	end})
	
	local SkeletonToggle = visuals_section:Toggle({Name = "Skeleton", Flag = "Skeleton Enabled", Default = Stranded.skeleton.enabled, Callback = function(Value)
		Stranded.skeleton.enabled = Value
	end})
	
	SkeletonToggle:Colorpicker({Name = "Color", Flag = "Skeleton Color", Default = Stranded.skeleton.color, Callback = function(Value)
		Stranded.skeleton.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.skeleton then
					for _, skeleton_data in pairs(cache.skeleton) do
						if skeleton_data.line then
							skeleton_data.line.Color = Value
						end
					end
				end
			end
		end
	end})
	
	local SkeletonOutlineToggle = visuals_section:Toggle({Name = "Skeleton Outline", Flag = "Skeleton Outline Enabled", Default = Stranded.skeleton.outline.enabled, Callback = function(Value)
		Stranded.skeleton.outline.enabled = Value
	end})
	
	SkeletonOutlineToggle:Colorpicker({Name = "Outline Color", Flag = "Skeleton Outline Color", Default = Stranded.skeleton.outline.color, Callback = function(Value)
		Stranded.skeleton.outline.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.skeleton then
					for _, skeleton_data in pairs(cache.skeleton) do
						if skeleton_data.outline then
							skeleton_data.outline.Color = Value
						end
					end
				end
			end
		end
	end})
	
	local ChamsToggle = visuals_section:Toggle({Name = "Chams", Flag = "Chams Enabled", Default = Stranded.chams.enabled, Callback = function(Value)
		Stranded.chams.enabled = Value
	end})
	
	ChamsToggle:Colorpicker({Name = "Fill Color", Flag = "Chams Fill Color", Default = Stranded.chams.fill_color, Callback = function(Value)
		Stranded.chams.fill_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.chams and cache.chams.highlight then
					cache.chams.highlight.FillColor = Value
				end
			end
		end
	end})
	
	ChamsToggle:Colorpicker({Name = "Outline Color", Flag = "Chams Outline Color", Default = Stranded.chams.outline_color, Callback = function(Value)
		Stranded.chams.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.chams and cache.chams.highlight then
					cache.chams.highlight.OutlineColor = Value
				end
			end
		end
	end})
	
	local fov_toggle = visuals_section:Toggle({Name = "FOV", Flag = "FOV Enabled", Default = Stranded.fov.enabled, Callback = function(Value)
		Stranded.fov.enabled = Value
	end})
	
	fov_toggle:Colorpicker({Name = "Color", Flag = "FOV Color", Default = Stranded.fov.color, Callback = function(Value)
		Stranded.fov.color = Value
		if esp and esp.fov_cache and esp.fov_cache.circle then
			esp.fov_cache.circle.Color = Value
		end
	end})
	
	fov_toggle:Colorpicker({Name = "Outline Color", Flag = "FOV Outline Color", Default = Stranded.fov.outline_color, Callback = function(Value)
		Stranded.fov.outline_color = Value
		if esp and esp.fov_cache and esp.fov_cache.outline then
			esp.fov_cache.outline.Color = Value
		end
	end})
	
	local fov_filled_toggle = visuals_section:Toggle({Name = "FOV Filled", Flag = "FOV Filled", Default = Stranded.fov.filled, Callback = function(Value)
		Stranded.fov.filled = Value
		if Value and esp and esp.fov_cache and esp.fov_cache.frame then
			if not esp.fov_cache.gradient then
				local fov_gradient = Instance.new("UIGradient")
				esp.fov_cache.gradient = fov_gradient
			end
			if Stranded.fov.gradient.enabled then
				esp.fov_cache.gradient.Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Stranded.fov.gradient.top_color),
					ColorSequenceKeypoint.new(1, Stranded.fov.gradient.bottom_color)
				})
				esp.fov_cache.gradient.Rotation = Stranded.fov.gradient.rotation or 90
				if not esp.fov_cache.gradient.Parent then
					esp.fov_cache.gradient.Parent = esp.fov_cache.frame
				end
			end
		end
	end})
	
	fov_filled_toggle:Colorpicker({Name = "Gradient Top", Flag = "FOV Gradient Top", Default = Stranded.fov.gradient.top_color, Callback = function(Value)
		Stranded.fov.gradient.top_color = Value
		Stranded.fov.gradient.enabled = true
		if esp and esp.fov_cache and esp.fov_cache.frame and Stranded.fov.filled then
			if not esp.fov_cache.gradient then
				local fov_gradient = Instance.new("UIGradient")
				esp.fov_cache.gradient = fov_gradient
			end
			esp.fov_cache.gradient.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Stranded.fov.gradient.top_color),
				ColorSequenceKeypoint.new(1, Stranded.fov.gradient.bottom_color)
			})
			esp.fov_cache.gradient.Rotation = (Stranded.fov.gradient.rotation ~= nil) and Stranded.fov.gradient.rotation or 90
			if not esp.fov_cache.gradient.Parent then
				esp.fov_cache.gradient.Parent = esp.fov_cache.frame
			end
		end
	end})
	
	fov_filled_toggle:Colorpicker({Name = "Gradient Bottom", Flag = "FOV Gradient Bottom", Default = Stranded.fov.gradient.bottom_color, Callback = function(Value)
		Stranded.fov.gradient.bottom_color = Value
		Stranded.fov.gradient.enabled = true
		if esp and esp.fov_cache and esp.fov_cache.frame and Stranded.fov.filled then
			if not esp.fov_cache.gradient then
				local fov_gradient = Instance.new("UIGradient")
				esp.fov_cache.gradient = fov_gradient
			end
			esp.fov_cache.gradient.Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, Stranded.fov.gradient.top_color),
				ColorSequenceKeypoint.new(1, Stranded.fov.gradient.bottom_color)
			})
			esp.fov_cache.gradient.Rotation = (Stranded.fov.gradient.rotation ~= nil) and Stranded.fov.gradient.rotation or 90
			if not esp.fov_cache.gradient.Parent then
				esp.fov_cache.gradient.Parent = esp.fov_cache.frame
			end
		end
	end})
	
	visuals_section:Toggle({Name = "FOV Animegirls", Flag = "FOV Animegirls Enabled", Default = Stranded.fov.options.animegirls.enabled, Callback = function(Value)
		Stranded.fov.options.animegirls.enabled = Value
	end})
	
	local FOVLabelToggle = visuals_section:Toggle({Name = "FOV Label", Flag = "FOV Label Enabled", Default = Stranded.fov.options.label.enabled, Callback = function(Value)
		Stranded.fov.options.label.enabled = Value
	end})
	
	FOVLabelToggle:Colorpicker({Name = "Color", Flag = "FOV Label Color", Default = Stranded.fov.options.label.color, Callback = function(Value)
		Stranded.fov.options.label.color = Value
		if esp and esp.fov_cache and esp.fov_cache.label then
			esp.fov_cache.label.TextColor3 = Value
		end
	end})
	
	FOVLabelToggle:Colorpicker({Name = "Outline Color", Flag = "FOV Label Outline", Default = Stranded.fov.options.label.outline_color, Callback = function(Value)
		Stranded.fov.options.label.outline_color = Value
		if esp and esp.fov_cache and esp.fov_cache.label then
			esp.fov_cache.label.TextStrokeColor3 = Value
		end
	end})
	
	local NameToggle = visuals_section:Toggle({Name = "Name", Flag = "Name Enabled", Default = Stranded.labels.name.enabled, Callback = function(Value)
		Stranded.labels.name.enabled = Value
	end})
	
	NameToggle:Colorpicker({Name = "Color", Flag = "Name Color", Default = Stranded.labels.name.color, Callback = function(Value)
		Stranded.labels.name.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.name then
					cache.text.name.TextColor3 = Value
				end
			end
		end
	end})
	
	NameToggle:Colorpicker({Name = "Outline Color", Flag = "Name Outline Color", Default = Stranded.labels.name.outline_color, Callback = function(Value)
		Stranded.labels.name.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.name then
					cache.text.name.TextStrokeColor3 = Value
				end
			end
		end
	end})
	
	
	local DisplayNameToggle = visuals_section:Toggle({Name = "Display Name", Flag = "Display Name Enabled", Default = Stranded.labels.display_name.enabled, Callback = function(Value)
		Stranded.labels.display_name.enabled = Value
	end})
	
	DisplayNameToggle:Colorpicker({Name = "Color", Flag = "Display Name Color", Default = Stranded.labels.display_name.color, Callback = function(Value)
		Stranded.labels.display_name.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.display_name then
					cache.text.display_name.TextColor3 = Value
				end
			end
		end
	end})
	
	DisplayNameToggle:Colorpicker({Name = "Outline Color", Flag = "Display Name Outline Color", Default = Stranded.labels.display_name.outline_color, Callback = function(Value)
		Stranded.labels.display_name.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.display_name then
					cache.text.display_name.TextStrokeColor3 = Value
				end
			end
		end
	end})
	
	
	local DistanceToggle = visuals_section:Toggle({Name = "Distance", Flag = "Distance Enabled", Default = Stranded.labels.distance.enabled, Callback = function(Value)
		Stranded.labels.distance.enabled = Value
	end})
	
	DistanceToggle:Colorpicker({Name = "Color", Flag = "Distance Color", Default = Stranded.labels.distance.color, Callback = function(Value)
		Stranded.labels.distance.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.studs then
					cache.text.studs.TextColor3 = Value
				end
			end
		end
	end})
	
	DistanceToggle:Colorpicker({Name = "Outline Color", Flag = "Distance Outline Color", Default = Stranded.labels.distance.outline_color, Callback = function(Value)
		Stranded.labels.distance.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.studs then
					cache.text.studs.TextStrokeColor3 = Value
				end
			end
		end
	end})
	
	
	local ToolToggle = visuals_section:Toggle({Name = "Tool", Flag = "Tool Enabled", Default = Stranded.labels.tool.enabled, Callback = function(Value)
		Stranded.labels.tool.enabled = Value
	end})
	
	ToolToggle:Colorpicker({Name = "Color", Flag = "Tool Color", Default = Stranded.labels.tool.color, Callback = function(Value)
		Stranded.labels.tool.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.tool then
					cache.text.tool.TextColor3 = Value
				end
			end
		end
	end})
	
	ToolToggle:Colorpicker({Name = "Outline Color", Flag = "Tool Outline Color", Default = Stranded.labels.tool.outline_color, Callback = function(Value)
		Stranded.labels.tool.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.text and cache.text.tool then
					cache.text.tool.TextStrokeColor3 = Value
				end
			end
		end
	end})
	
	local HealthBarToggle = visuals_section:Toggle({Name = "Health Bar", Flag = "Health Bar Enabled", Default = Stranded.health_bar.enabled, Callback = function(Value)
		Stranded.health_bar.enabled = Value
	end})
	
	HealthBarToggle:Colorpicker({Name = "Gradient Top", Flag = "Health Bar Gradient Top", Default = Stranded.health_bar.gradient.top_color, Callback = function(Value)
		Stranded.health_bar.gradient.top_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.health then
					local health_fill = cache.bars.health.frame
					if health_fill then
						local gradient = health_fill:FindFirstChildOfClass("UIGradient")
						if Stranded.health_bar.gradient.enabled and gradient then
							gradient.Color = ColorSequence.new({
								ColorSequenceKeypoint.new(0, Stranded.health_bar.gradient.top_color),
								ColorSequenceKeypoint.new(1, Stranded.health_bar.gradient.bottom_color)
							})
						else
							health_fill.BackgroundColor3 = Value
						end
					end
				end
			end
		end
	end})
	
	HealthBarToggle:Colorpicker({Name = "Gradient Bottom", Flag = "Health Bar Gradient Bottom", Default = Stranded.health_bar.gradient.bottom_color, Callback = function(Value)
		Stranded.health_bar.gradient.bottom_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.health then
					local health_fill = cache.bars.health.frame
					if health_fill then
						local gradient = health_fill:FindFirstChildOfClass("UIGradient")
						if Stranded.health_bar.gradient.enabled and gradient then
							gradient.Color = ColorSequence.new({
								ColorSequenceKeypoint.new(0, Stranded.health_bar.gradient.top_color),
								ColorSequenceKeypoint.new(1, Stranded.health_bar.gradient.bottom_color)
							})
						end
					end
				end
			end
		end
	end})
	
	
	local HealthBarTextToggle = visuals_section:Toggle({Name = "Health Bar Text", Flag = "Health Bar Text Enabled", Default = Stranded.health_bar.text.enabled, Callback = function(Value)
		Stranded.health_bar.text.enabled = Value
	end})
	
	HealthBarTextToggle:Colorpicker({Name = "Color", Flag = "Health Bar Text Color", Default = Stranded.health_bar.text.color, Callback = function(Value)
		Stranded.health_bar.text.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.health and cache.bars.health.text then
					cache.bars.health.text.TextColor3 = Value
				end
			end
		end
	end})
	
	HealthBarTextToggle:Colorpicker({Name = "Outline Color", Flag = "Health Bar Text Outline", Default = Stranded.health_bar.text.outline_color, Callback = function(Value)
		Stranded.health_bar.text.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.health and cache.bars.health.text then
					cache.bars.health.text.TextStrokeColor3 = Value
				end
			end
		end
	end})
	
	local ArmorBarToggle = visuals_section:Toggle({Name = "Armor Bar", Flag = "Armor Bar Enabled", Default = Stranded.armor_bar.enabled, Callback = function(Value)
		Stranded.armor_bar.enabled = Value
	end})
	
	ArmorBarToggle:Colorpicker({Name = "Gradient Top", Flag = "Armor Bar Gradient Top", Default = Stranded.armor_bar.gradient.top_color, Callback = function(Value)
		Stranded.armor_bar.gradient.top_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.armor then
					local armor_fill = cache.bars.armor.frame
					if armor_fill then
						local gradient = armor_fill:FindFirstChildOfClass("UIGradient")
						if Stranded.armor_bar.gradient.enabled and gradient then
							gradient.Color = ColorSequence.new({
								ColorSequenceKeypoint.new(0, Stranded.armor_bar.gradient.top_color),
								ColorSequenceKeypoint.new(1, Stranded.armor_bar.gradient.bottom_color)
							})
						else
							armor_fill.BackgroundColor3 = Value
						end
					end
				end
			end
		end
	end})
	
	ArmorBarToggle:Colorpicker({Name = "Gradient Bottom", Flag = "Armor Bar Gradient Bottom", Default = Stranded.armor_bar.gradient.bottom_color, Callback = function(Value)
		Stranded.armor_bar.gradient.bottom_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.armor then
					local armor_fill = cache.bars.armor.frame
					if armor_fill then
						local gradient = armor_fill:FindFirstChildOfClass("UIGradient")
						if Stranded.armor_bar.gradient.enabled and gradient then
							gradient.Color = ColorSequence.new({
								ColorSequenceKeypoint.new(0, Stranded.armor_bar.gradient.top_color),
								ColorSequenceKeypoint.new(1, Stranded.armor_bar.gradient.bottom_color)
							})
						end
					end
				end
			end
		end
	end})
	
	
	local ArmorBarTextToggle = visuals_section:Toggle({Name = "Armor Bar Text", Flag = "Armor Bar Text Enabled", Default = Stranded.armor_bar.text.enabled, Callback = function(Value)
		Stranded.armor_bar.text.enabled = Value
	end})
	
	ArmorBarTextToggle:Colorpicker({Name = "Color", Flag = "Armor Bar Text Color", Default = Stranded.armor_bar.text.color, Callback = function(Value)
		Stranded.armor_bar.text.color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.armor and cache.bars.armor.text then
					cache.bars.armor.text.TextColor3 = Value
				end
			end
		end
	end})
	
	ArmorBarTextToggle:Colorpicker({Name = "Outline Color", Flag = "Armor Bar Text Outline", Default = Stranded.armor_bar.text.outline_color, Callback = function(Value)
		Stranded.armor_bar.text.outline_color = Value
		if esp and esp.cache then
			for player, cache in pairs(esp.cache) do
				if cache.bars and cache.bars.armor and cache.bars.armor.text then
					cache.bars.armor.text.TextStrokeColor3 = Value
				end
			end
		end
	end})
	
	self_section:Toggle({Name = "Self Aura", Flag = "Self Aura Enabled", Default = Stranded.self_aura.enabled, Callback = function(Value)
		Stranded.self_aura.enabled = Value
	end})
	
	self_section:Dropdown({Name = "Aura Type", Flag = "Self Aura Type", Multi = true, Default = Stranded.self_aura.type, Items = {"Angel Wings", "Particle Aura", "Ice Aura", "Earthquake", "Halo", "Poison Aura", "Saturn Ring", "Lightning Aura", "Blood Aura"}, Callback = function(Value)
		if Value then
			if type(Value) == "table" then
				Stranded.self_aura.type = Value
			else
				Stranded.self_aura.type = {Value}
			end
		end
	end})
	
	local self_material_toggle = self_section:Toggle({Name = "Self Material", Flag = "Self Material Enabled", Default = Stranded.self_material.enabled, Callback = function(Value)
		Stranded.self_material.enabled = Value
	end})
	
	self_material_toggle:Colorpicker({Name = "Material Color", Flag = "Self Material Color", Default = Stranded.self_material.color, Callback = function(Value)
		Stranded.self_material.color = Value
	end})
	
	self_section:Dropdown({Name = "Material Type", Flag = "Self Material Type", Default = Stranded.self_material.type, Items = {"Neon", "ForceField", "Glass", "Plastic", "Metal", "Wood", "Concrete", "Fabric", "Ice", "SmoothPlastic"}, Callback = function(Value)
		if Value then
			Stranded.self_material.type = Value
		end
	end})
	
	local self_tool_material_toggle = self_section:Toggle({Name = "Self Tool Material", Flag = "Self Tool Material Enabled", Default = Stranded.self_toolmaterial.enabled, Callback = function(Value)
		Stranded.self_toolmaterial.enabled = Value
	end})
	
	self_tool_material_toggle:Colorpicker({Name = "Tool Material Color", Flag = "Self Tool Material Color", Default = Stranded.self_toolmaterial.color, Callback = function(Value)
		Stranded.self_toolmaterial.color = Value
	end})
	
	self_section:Dropdown({Name = "Tool Material Type", Flag = "Self Tool Material Type", Default = Stranded.self_toolmaterial.type, Items = {"Neon", "ForceField", "Glass", "Plastic", "Metal", "Wood", "Concrete", "Fabric", "Ice", "SmoothPlastic"}, Callback = function(Value)
		if Value then
			Stranded.self_toolmaterial.type = Value
		end
	end})
	
	self_section:Toggle({Name = "Hitsounds", Flag = "Hitsounds Enabled", Default = Stranded.hitsounds.enabled, Callback = function(Value)
		Stranded.hitsounds.enabled = Value
	end})
	
	self_section:Dropdown({Name = "Hitsound Type", Flag = "Hitsound Type", Default = Stranded.hitsounds.type, Items = {"Bubble", "Lazer", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "UwU", "Bruh", "Skeet", "Neverlose", "Fatality", "Bonk", "Minecraft", "Gamesense", "RIFK7", "Bamboo", "Crowbar", "Weeb", "Beep", "Bambi", "Stone", "Old Fatality", "Click", "Ding", "Snow", "Laser", "Mario", "Steve", "Call of Duty", "Bat", "TF2 Critical", "Saber", "Baimware", "Osu", "TF2", "Slime", "Among Us", "One"}, Callback = function(Value)
		if Value then
			Stranded.hitsounds.type = Value
		end
	end})
	
	self_section:Slider({Name = "Hitsound Volume", Min = 0, Max = 100, Default = Stranded.hitsounds.volume, Decimals = 0, Suffix = "%", Compact = true, Flag = "Hitsound Volume", Callback = function(Value)
		Stranded.hitsounds.volume = math.clamp(math.floor(Value), 0, 100)
	end})
	
	self_section:Toggle({Name = "Hit Effect", Flag = "Hit Effect Enabled", Default = Stranded.hiteffects.enabled, Callback = function(Value)
		Stranded.hiteffects.enabled = Value
	end})
	
	self_section:Dropdown({Name = "Hit Effect Type", Flag = "Hit Effect Type", Default = Stranded.hiteffects.type, Items = {"Pulse", "Clone", "Explosion", "Cum", "Shockwave", "Smoke", "Burst", "Electric", "Fire", "Ice", "Shatter", "Beam"}, Callback = function(Value)
		if Value then
			Stranded.hiteffects.type = Value
		end
	end})
	
	self_section:Divider()
	
	local bullet_tracer_toggle = self_section:Toggle({Name = "Bullet Tracers", Flag = "Bullet Tracers Enabled", Default = Stranded.bullet_tracers.enabled, Callback = function(Value)
		Stranded.bullet_tracers.enabled = Value
	end})
	
	bullet_tracer_toggle:Colorpicker({Name = "Tracer Color", Flag = "Bullet Tracer Color", Default = Stranded.bullet_tracers.color, Callback = function(Value)
		Stranded.bullet_tracers.color = Value
	end})
	
	self_section:Dropdown({Name = "Tracer Type", Flag = "Bullet Tracer Type", Default = Stranded.bullet_tracers.type, Items = {"Lazar", "Line", "Glow", "Energy", "Plasma", "Neon"}, Callback = function(Value)
		if Value then
			Stranded.bullet_tracers.type = Value
		end
	end})
	
	self_section:Slider({Name = "Tracer Time", Min = 0.1, Max = 5, Default = Stranded.bullet_tracers.time, Decimals = 1, Suffix = "s", Compact = true, Flag = "Bullet Tracer Time", Callback = function(Value)
		Stranded.bullet_tracers.time = Value
	end})
	
	self_section:Slider({Name = "Tracer Thickness", Min = 0.1, Max = 5, Default = Stranded.bullet_tracers.thickness, Decimals = 1, Compact = true, Flag = "Bullet Tracer Thickness", Callback = function(Value)
		Stranded.bullet_tracers.thickness = Value
	end})
	
	self_section:Slider({Name = "Tracer Length", Min = 50, Max = 500, Default = Stranded.bullet_tracers.length, Decimals = 0, Suffix = " studs", Compact = true, Flag = "Bullet Tracer Length", Callback = function(Value)
		Stranded.bullet_tracers.length = math.floor(Value)
	end})
	
	local AimbotSection, SettingsSection, easing_section = CombatTab:MultiSection({Sections = {"Aimbot", "Settings", "Easing"}, Side = 1})
	
	local aimbot_toggle = AimbotSection:Toggle({Name = "Enabled", Flag = "Aimbot Enabled", Default = Stranded.aimbot.enabled, Callback = function(Value)
		Stranded.aimbot.enabled = Value
	end})
	
	local aimbot_keybind = aimbot_toggle:Keybind({Name = "Aimbot Keybind", Flag = "Aimbot Hotkey", Default = Enum.KeyCode.Q, Mode = Stranded.aimbot.mode or "Hold", Callback = function(Value)
	end})
	
	if aimbot_keybind then
		aimbot_keybind.OnModeChange = function(mode)
			Stranded.aimbot.mode = mode
		end
	end
	
	AimbotSection:Toggle({Name = "Sticky Aim", Flag = "Aimbot Sticky Aim", Default = Stranded.aimbot.sticky_aim, Callback = function(Value)
		Stranded.aimbot.sticky_aim = Value
	end})
	
	AimbotSection:Dropdown({Name = "Type", Flag = "Aimbot Type", Default = Stranded.aimbot.type, Items = {"Camera", "Mouse"}, Callback = function(Value)
		if Value then
			Stranded.aimbot.type = Value
		end
	end})
	
	AimbotSection:Dropdown({Name = "Method", Flag = "Aimbot Method", Default = Stranded.aimbot.method, Items = {"Closest to Mouse", "Closest to Player"}, Callback = function(Value)
		if Value then
			Stranded.aimbot.method = Value
		end
	end})
	
	SettingsSection:Dropdown({Name = "Bone", Flag = "Aimbot Bone", Default = Stranded.aimbot.settings.bone, Items = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}, Callback = function(Value)
		if Value then
			Stranded.aimbot.settings.bone = Value
		end
	end})
	
	SettingsSection:Toggle({Name = "Prediction", Flag = "Aimbot Prediction Enabled", Default = Stranded.aimbot.settings.prediction_enabled, Callback = function(Value)
		Stranded.aimbot.settings.prediction_enabled = Value
	end})
	
	SettingsSection:Textbox({Name = "Prediction Value", Default = tostring(Stranded.aimbot.settings.prediction), Placeholder = "0.17", Flag = "Aimbot Prediction", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value then
			Stranded.aimbot.settings.prediction = math.clamp(num_value, 0, 1)
		end
	end})
	
	SettingsSection:Toggle({Name = "Auto Prediction", Flag = "Aimbot Auto Prediction Enabled", Default = Stranded.aimbot.settings.auto_prediction_enabled, Callback = function(Value)
		Stranded.aimbot.settings.auto_prediction_enabled = Value
	end})
	
	SettingsSection:Toggle({Name = "Auto Prediction Toggle", Flag = "Aimbot Auto Prediction", Default = Stranded.aimbot.settings.auto_prediction, Callback = function(Value)
		Stranded.aimbot.settings.auto_prediction = Value
	end})
	
	SettingsSection:Toggle({Name = "Smoothness", Flag = "Aimbot Smoothness Enabled", Default = Stranded.aimbot.settings.smoothness_enabled, Callback = function(Value)
		Stranded.aimbot.settings.smoothness_enabled = Value
	end})
	
	SettingsSection:Textbox({Name = "Smoothness Value", Default = tostring(Stranded.aimbot.settings.smoothness), Placeholder = "1", Flag = "Aimbot Smoothness", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value then
			Stranded.aimbot.settings.smoothness = math.clamp(num_value, 0.1, 10)
		end
	end})
	
	easing_section:Dropdown({Name = "Type", Flag = "Aimbot Easing Type", Default = Stranded.aimbot.easing.type, Items = {
		"Linear", "Smooth", "Fast",
		"Ease In Quad", "Ease Out Quad", "Ease In Out Quad",
		"Ease In Cubic", "Ease Out Cubic", "Ease In Out Cubic",
		"Ease In Quart", "Ease Out Quart", "Ease In Out Quart",
		"Ease In Quint", "Ease Out Quint", "Ease In Out Quint",
		"Ease In Sine", "Ease Out Sine", "Ease In Out Sine",
		"Ease In Expo", "Ease Out Expo", "Ease In Out Expo",
		"Ease In Circ", "Ease Out Circ", "Ease In Out Circ",
		"Ease In Back", "Ease Out Back", "Ease In Out Back"
	}, Callback = function(Value)
		if Value then
			Stranded.aimbot.easing.type = Value
		end
	end})
	
	easing_section:Textbox({Name = "Speed", Default = tostring(Stranded.aimbot.easing.speed), Placeholder = "1", Flag = "Aimbot Easing Speed", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value then
			Stranded.aimbot.easing.speed = math.clamp(num_value, 0.1, 10)
		end
	end})
	
	easing_section:Toggle({Name = "Bezier Curves", Flag = "Aimbot Bezier Curves Enabled", Default = Stranded.aimbot.easing.bezier_curves_enabled, Callback = function(Value)
		Stranded.aimbot.easing.bezier_curves_enabled = Value
	end})
	
	easing_section:Toggle({Name = "Bezier Curves Toggle", Flag = "Aimbot Bezier Curves", Default = Stranded.aimbot.easing.bezier_curves, Callback = function(Value)
		Stranded.aimbot.easing.bezier_curves = Value
	end})
	
	easing_section:Divider()
	
	local curve_editor = easing_section:CurveEditor({
		Name = "Easing Curve",
		Flag = "Aimbot Curve Editor",
		Size = 200,
		ControlPoint1X = Stranded.aimbot.easing.control_point_1_x,
		ControlPoint1Y = Stranded.aimbot.easing.control_point_1_y,
		ControlPoint2X = Stranded.aimbot.easing.control_point_2_x,
		ControlPoint2Y = Stranded.aimbot.easing.control_point_2_y,
		Callback = function(CP1X, CP1Y, CP2X, CP2Y)
			Stranded.aimbot.easing.control_point_1_x = CP1X
			Stranded.aimbot.easing.control_point_1_y = CP1Y
			Stranded.aimbot.easing.control_point_2_x = CP2X
			Stranded.aimbot.easing.control_point_2_y = CP2Y
			if Library.Flags["Aimbot CP1 X"] and type(Library.Flags["Aimbot CP1 X"]) == "table" and Library.Flags["Aimbot CP1 X"].Set then
				Library.Flags["Aimbot CP1 X"]:Set(CP1X)
			end
			if Library.Flags["Aimbot CP1 Y"] and type(Library.Flags["Aimbot CP1 Y"]) == "table" and Library.Flags["Aimbot CP1 Y"].Set then
				Library.Flags["Aimbot CP1 Y"]:Set(CP1Y)
			end
			if Library.Flags["Aimbot CP2 X"] and type(Library.Flags["Aimbot CP2 X"]) == "table" and Library.Flags["Aimbot CP2 X"].Set then
				Library.Flags["Aimbot CP2 X"]:Set(CP2X)
			end
			if Library.Flags["Aimbot CP2 Y"] and type(Library.Flags["Aimbot CP2 Y"]) == "table" and Library.Flags["Aimbot CP2 Y"].Set then
				Library.Flags["Aimbot CP2 Y"]:Set(CP2Y)
			end
		end
	})
	
	easing_section:Toggle({Name = "Use Custom Easing", Flag = "Aimbot Custom Easing", Default = Stranded.aimbot.easing.custom_easing, Callback = function(Value)
		Stranded.aimbot.easing.custom_easing = Value
		if curve_editor then
			curve_editor:SetVisibility(Value)
		end
	end})
	
	if curve_editor then
		curve_editor:SetVisibility(true)
	end
	
	function on_curve_change()
		if curve_editor then
			curve_editor:Set(
				Stranded.aimbot.easing.control_point_1_x,
				Stranded.aimbot.easing.control_point_1_y,
				Stranded.aimbot.easing.control_point_2_x,
				Stranded.aimbot.easing.control_point_2_y
			)
		end
	end
	
	easing_section:Slider({Name = "Control Point 1 X", Min = 0, Max = 1, Default = Stranded.aimbot.easing.control_point_1_x, Decimals = 2, Compact = true, Flag = "Aimbot CP1 X", Callback = function(Value)
		Stranded.aimbot.easing.control_point_1_x = Value
		on_curve_change()
	end})
	
	easing_section:Slider({Name = "Control Point 1 Y", Min = 0, Max = 1, Default = Stranded.aimbot.easing.control_point_1_y, Decimals = 2, Compact = true, Flag = "Aimbot CP1 Y", Callback = function(Value)
		Stranded.aimbot.easing.control_point_1_y = Value
		on_curve_change()
	end})
	
	easing_section:Slider({Name = "Control Point 2 X", Min = 0, Max = 1, Default = Stranded.aimbot.easing.control_point_2_x, Decimals = 2, Compact = true, Flag = "Aimbot CP2 X", Callback = function(Value)
		Stranded.aimbot.easing.control_point_2_x = Value
		on_curve_change()
	end})
	
	easing_section:Slider({Name = "Control Point 2 Y", Min = 0, Max = 1, Default = Stranded.aimbot.easing.control_point_2_y, Decimals = 2, Compact = true, Flag = "Aimbot CP2 Y", Callback = function(Value)
		Stranded.aimbot.easing.control_point_2_y = Value
		on_curve_change()
	end})
	
	local TargetAimGeneralSection, target_aim_section = CombatTab:MultiSection({Sections = {"Target Aim", "Settings"}, Side = 2})
	
	local target_aim_toggle = TargetAimGeneralSection:Toggle({Name = "Enabled", Flag = "Target Aim Enabled", Default = Stranded.target_aim.enabled, Callback = function(Value)
		Stranded.target_aim.enabled = Value
	end})
	
	local target_aim_keybind = target_aim_toggle:Keybind({Name = "Target Aim Keybind", Flag = "Target Aim Hotkey", Default = Enum.KeyCode.E, Mode = "Hold", Callback = function(Value)
	end})
	
	if target_aim_keybind then
		target_aim_keybind.OnModeChange = function(mode)
		end
	end

	target_aim_section:Toggle({Name = "Sticky Aim", Flag = "Target Aim Sticky Aim", Default = Stranded.target_aim.settings.sticky_aim, Callback = function(Value)
		Stranded.target_aim.settings.sticky_aim = Value
		if not Value then
			if esp and esp.target_aim_cache then
				esp.target_aim_cache.sticky_target_part = nil
			end
		end
	end})
	
	TargetAimGeneralSection:Dropdown({Name = "Method", Flag = "Target Aim Method", Default = Stranded.target_aim.Method, Items = {"FOV", "Closest to Mouse", "Closest to Player"}, Callback = function(Value)
		if Value then
			Stranded.target_aim.Method = Value
		end
	end})
	
	target_aim_section:Dropdown({Name = "Bone", Flag = "Target Aim Bone", Default = Stranded.target_aim.settings.bone, Items = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"}, Callback = function(Value)
		if Value then
			Stranded.target_aim.settings.bone = Value
		end
	end})
	
	target_aim_section:Textbox({Name = "Prediction", Default = tostring(Stranded.target_aim.settings.prediction), Placeholder = "0.17", Flag = "Target Aim Prediction", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value then
			Stranded.target_aim.settings.prediction = math.clamp(num_value, 0, 1)
		end
	end})
	
	target_aim_section:Toggle({Name = "Auto Prediction", Flag = "Target Aim Auto Prediction", Default = Stranded.target_aim.settings.auto_prediction, Callback = function(Value)
		Stranded.target_aim.settings.auto_prediction = Value
	end})
	
	target_aim_section:Toggle({Name = "Lookat", Flag = "Target Aim Lookat", Default = Stranded.target_aim.settings.lookat, Callback = function(Value)
		Stranded.target_aim.settings.lookat = Value
	end})
	
	target_aim_section:Toggle({Name = "Spectate", Flag = "Target Aim Spectate", Default = Stranded.target_aim.settings.spectate, Callback = function(Value)
		Stranded.target_aim.settings.spectate = Value
		if Value then
			local target_player = esp.funcs.get_target_aim_closest_player()
			if target_player and target_player.Character then
				local camera = workspace.CurrentCamera
				if camera then
					camera.CameraSubject = target_player.Character:FindFirstChildOfClass("Humanoid")
				end
			end
		else
			local camera = workspace.CurrentCamera
			if camera and esp.vars.local_player and esp.vars.local_player.Character then
				local humanoid = esp.vars.local_player.Character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					camera.CameraSubject = humanoid
				end
			end
		end
	end})
	
	local HighlightTargetToggle = target_aim_section:Toggle({Name = "Highlight Target", Flag = "Target Aim Highlight Target", Default = Stranded.target_aim.settings.highlight_target, Callback = function(Value)
		Stranded.target_aim.settings.highlight_target = Value
	end})
	
	HighlightTargetToggle:Colorpicker({Name = "Fill Color", Flag = "Target Aim Highlight Fill Color", Default = Stranded.target_aim.settings.highlight_fill_color, Callback = function(Value)
		Stranded.target_aim.settings.highlight_fill_color = Value
		if esp and esp.target_aim_cache and esp.target_aim_cache.highlight then
			esp.target_aim_cache.highlight.FillColor = Value
		end
	end})
	
	HighlightTargetToggle:Colorpicker({Name = "Outline Color", Flag = "Target Aim Highlight Outline Color", Default = Stranded.target_aim.settings.highlight_outline_color, Callback = function(Value)
		Stranded.target_aim.settings.highlight_outline_color = Value
		if esp and esp.target_aim_cache and esp.target_aim_cache.highlight then
			esp.target_aim_cache.highlight.OutlineColor = Value
		end
	end})

	local HitboxExpanderSection, HitboxExpanderVisualiseSection = RageMainSubTab:MultiSection({Sections = {"Hitbox Expander", "Visualise"}, Side = 1})
	
	local hitbox_expander_toggle = HitboxExpanderSection:Toggle({Name = "Enabled", Flag = "Hitbox Expander Enabled", Default = Stranded.hitbox_expander.enabled, Callback = function(Value)
		Stranded.hitbox_expander.enabled = Value
	end})
	
	HitboxExpanderSection:Slider({Name = "Width", Min = 1, Max = 50, Default = Stranded.hitbox_expander.width, Decimals = 0, Compact = true, Flag = "Hitbox Expander Width", Callback = function(Value)
		Stranded.hitbox_expander.width = Value
	end})
	
	HitboxExpanderSection:Slider({Name = "Length", Min = 1, Max = 50, Default = Stranded.hitbox_expander.length, Decimals = 0, Compact = true, Flag = "Hitbox Expander Length", Callback = function(Value)
		Stranded.hitbox_expander.length = Value
	end})
	
	local hitbox_expander_visualize = HitboxExpanderVisualiseSection:Toggle({Name = "Visualize", Flag = "Hitbox Expander Visualize", Default = Stranded.hitbox_expander.visualize, Callback = function(Value)
		Stranded.hitbox_expander.visualize = Value
	end})
	
	HitboxExpanderVisualiseSection:Label({Name = "Fill Color", Alignment = "Left"}):Colorpicker({Name = "Fill Color", Flag = "Hitbox Expander Fill Color", Default = Stranded.hitbox_expander.color, Callback = function(Value)
		Stranded.hitbox_expander.color = Value
	end})
	
	HitboxExpanderVisualiseSection:Label({Name = "Outline Color", Alignment = "Left"}):Colorpicker({Name = "Outline Color", Flag = "Hitbox Expander Outline Color", Default = Stranded.hitbox_expander.outline_color, Callback = function(Value)
		Stranded.hitbox_expander.outline_color = Value
	end})
	
	HitboxExpanderVisualiseSection:Slider({Name = "Fill Transparency", Min = 0, Max = 1, Default = Stranded.hitbox_expander.fill_transparency, Decimals = 2, Compact = true, Flag = "Hitbox Expander Fill Transparency", Callback = function(Value)
		Stranded.hitbox_expander.fill_transparency = Value
	end})
	
	HitboxExpanderVisualiseSection:Slider({Name = "Outline Transparency", Min = 0, Max = 1, Default = Stranded.hitbox_expander.outline_transparency, Decimals = 2, Compact = true, Flag = "Hitbox Expander Outline Transparency", Callback = function(Value)
		Stranded.hitbox_expander.outline_transparency = Value
	end})
	
	local TargetStrafeSection = RageMainSubTab:Section({Name = "Target Strafe", Side = 2})
	
	local target_strafe_toggle = TargetStrafeSection:Toggle({Name = "Enabled", Flag = "Target Strafe Enabled", Default = Stranded.target_strafe.enabled, Callback = function(Value)
		Stranded.target_strafe.enabled = Value
	end})
	
	local target_strafe_keybind = target_strafe_toggle:Keybind({Name = "Target Strafe Keybind", Flag = "Target Strafe Hotkey", Default = Enum.KeyCode.E, Mode = "Hold", Callback = function(Value)
	end})
	
	if target_strafe_keybind then
		target_strafe_keybind.OnModeChange = function(mode)
		end
	end
	
	TargetStrafeSection:Dropdown({Name = "Type", Flag = "Target Strafe Type", Default = Stranded.target_strafe.type, Items = {"Custom", "Random"}, Callback = function(Value)
		if Value then
			Stranded.target_strafe.type = Value
		end
	end})
	
	TargetStrafeSection:Dropdown({Name = "Pattern", Flag = "Target Strafe Pattern", Default = Stranded.target_strafe.pattern, Items = {"Normal", "Trigonometric", "Elliptical", "Figure-8"}, Callback = function(Value)
		if Value then
			Stranded.target_strafe.pattern = Value
		end
	end})
	
	TargetStrafeSection:Slider({Name = "Speed", Min = 1, Max = 50, Default = Stranded.target_strafe.speed, Decimals = 0, Compact = true, Flag = "Target Strafe Speed", Callback = function(Value)
		Stranded.target_strafe.speed = Value
	end})
	
	TargetStrafeSection:Slider({Name = "Distance", Min = 1, Max = 50, Default = Stranded.target_strafe.distance, Decimals = 0, Compact = true, Flag = "Target Strafe Distance", Callback = function(Value)
		Stranded.target_strafe.distance = Value
	end})
	
	TargetStrafeSection:Slider({Name = "Height", Min = -10, Max = 10, Default = Stranded.target_strafe.height, Decimals = 0, Compact = true, Flag = "Target Strafe Height", Callback = function(Value)
		Stranded.target_strafe.height = Value
	end})
	
	local DesyncSection = RageMovementSubTab:Section({Name = "Velocity Desync", Side = 2})
	
	local desync_toggle = DesyncSection:Toggle({Name = "Enable Desync", Flag = "Desync Enabled", Default = Stranded.desync.enabled, Callback = function(Value)
		Stranded.desync.enabled = Value
		if not Value then
			Stranded.desync.active = false
		end
	end})
	
	local desync_keybind = desync_toggle:Keybind({Name = "Desync Key", Flag = "Desync Hotkey", Default = Stranded.desync.keybind, Mode = "Hold", Callback = function(Value)
		if Stranded.desync.enabled then
			Stranded.desync.active = Value
		end
	end})
	
	DesyncSection:Toggle({Name = "Break Move Direction", Flag = "Desync Break Move Direction", Default = Stranded.desync.break_move_direction, Callback = function(Value)
		Stranded.desync.break_move_direction = Value
	end})
	
	DesyncSection:Slider({Name = "Min X", Min = -100, Max = 100, Default = Stranded.desync.min_x, Decimals = 0, Compact = true, Flag = "Desync Min X", Callback = function(Value)
		Stranded.desync.min_x = Value
	end})
	
	DesyncSection:Slider({Name = "Max X", Min = -100, Max = 100, Default = Stranded.desync.max_x, Decimals = 0, Compact = true, Flag = "Desync Max X", Callback = function(Value)
		Stranded.desync.max_x = Value
	end})
	
	DesyncSection:Slider({Name = "Min Y", Min = -100, Max = 100, Default = Stranded.desync.min_y, Decimals = 0, Compact = true, Flag = "Desync Min Y", Callback = function(Value)
		Stranded.desync.min_y = Value
	end})
	
	DesyncSection:Slider({Name = "Max Y", Min = -100, Max = 100, Default = Stranded.desync.max_y, Decimals = 0, Compact = true, Flag = "Desync Max Y", Callback = function(Value)
		Stranded.desync.max_y = Value
	end})
	
	DesyncSection:Slider({Name = "Min Z", Min = -100, Max = 100, Default = Stranded.desync.min_z, Decimals = 0, Compact = true, Flag = "Desync Min Z", Callback = function(Value)
		Stranded.desync.min_z = Value
	end})
	
	DesyncSection:Slider({Name = "Max Z", Min = -100, Max = 100, Default = Stranded.desync.max_z, Decimals = 0, Compact = true, Flag = "Desync Max Z", Callback = function(Value)
		Stranded.desync.max_z = Value
	end})
	
	DesyncSection:Slider({Name = "Min Rotation", Min = 0, Max = 360, Default = Stranded.desync.min_rotation, Decimals = 0, Compact = true, Flag = "Desync Min Rotation", Callback = function(Value)
		Stranded.desync.min_rotation = Value
	end})
	
	DesyncSection:Slider({Name = "Max Rotation", Min = 0, Max = 360, Default = Stranded.desync.max_rotation, Decimals = 0, Compact = true, Flag = "Desync Max Rotation", Callback = function(Value)
		Stranded.desync.max_rotation = Value
	end})
	
	DesyncSection:Slider({Name = "Velocity", Min = 0, Max = 999999, Default = (Stranded.desync.max_velocity == math.huge and 999999 or Stranded.desync.max_velocity), Decimals = 0, Compact = true, Flag = "Desync Velocity", Callback = function(Value)
		Stranded.desync.max_velocity = Value == 999999 and math.huge or Value
	end})
	
	
	
	local SpinbotSection = RageMovementSubTab:Section({Name = "Spinbot", Side = 1})
	
	SpinbotSection:Toggle({Name = "Enabled", Flag = "Spinbot Enabled", Default = Stranded.spinbot.enabled, Callback = function(Value)
		Stranded.spinbot.enabled = Value
	end})
	
	SpinbotSection:Slider({Name = "Speed", Min = 1, Max = 360, Default = Stranded.spinbot.speed, Decimals = 0, Compact = true, Flag = "Spinbot Speed", Callback = function(Value)
		Stranded.spinbot.speed = Value
	end})
	
	SpinbotSection:Dropdown({Name = "Mode", Flag = "Spinbot Mode", Default = Stranded.spinbot.mode, Items = {"Normal", "Rotational"}, Callback = function(Value)
		if Value then
			Stranded.spinbot.mode = Value
		end
	end})
	
	SpinbotSection:Toggle({Name = "X Axis", Flag = "Spinbot X Enabled", Default = Stranded.spinbot.x_enabled, Callback = function(Value)
		Stranded.spinbot.x_enabled = Value
	end})
	
	SpinbotSection:Toggle({Name = "Y Axis", Flag = "Spinbot Y Enabled", Default = Stranded.spinbot.y_enabled, Callback = function(Value)
		Stranded.spinbot.y_enabled = Value
	end})
	
	SpinbotSection:Toggle({Name = "Z Axis", Flag = "Spinbot Z Enabled", Default = Stranded.spinbot.z_enabled, Callback = function(Value)
		Stranded.spinbot.z_enabled = Value
	end})
	
	SpinbotSection:Toggle({Name = "Server Only", Flag = "Spinbot Server Only", Default = Stranded.spinbot.server_only, Callback = function(Value)
		Stranded.spinbot.server_only = Value
	end})
	
	local VisualizerSection = RageMovementSubTab:Section({Name = "Server HRP Visualizer", Side = 1})
	
	local VisualizerToggle = VisualizerSection:Toggle({Name = "Enabled", Flag = "Visualizer Enabled", Default = Stranded.server_hrp_visualizer.enabled, Callback = function(Value)
		Stranded.server_hrp_visualizer.enabled = Value
	end})
	
	VisualizerToggle:Colorpicker({Name = "Color", Flag = "Visualizer Color", Default = Stranded.server_hrp_visualizer.color, Callback = function(Value)
		Stranded.server_hrp_visualizer.color = Value
	end})
	
	VisualizerSection:Slider({Name = "Transparency", Min = 0, Max = 1, Default = Stranded.server_hrp_visualizer.transparency, Decimals = 2, Compact = true, Flag = "Visualizer Transparency", Callback = function(Value)
		Stranded.server_hrp_visualizer.transparency = Value
	end})
	
	VisualizerSection:Slider({Name = "Delay Simulation", Min = 0, Max = 1, Default = Stranded.server_hrp_visualizer.delay_simulation, Decimals = 2, Compact = true, Flag = "Visualizer Delay", Callback = function(Value)
		Stranded.server_hrp_visualizer.delay_simulation = Value
	end})

	local TriggerbotSection, TriggerbotSettingsSection, TriggerbotWhitelistSection = CombatTab:MultiSection({Sections = {"Triggerbot", "Settings", "Whitelist"}, Side = 1})
	
	local triggerbot_toggle = TriggerbotSection:Toggle({Name = "Enabled", Flag = "Triggerbot Enabled", Default = Stranded.triggerbot.enabled, Callback = function(Value)
		Stranded.triggerbot.enabled = Value
		if esp and esp.funcs.setup_triggerbot then
			esp.funcs.setup_triggerbot()
		end
	end})
	
	triggerbot_toggle:Keybind({Name = "Triggerbot Keybind", Flag = "Triggerbot Hotkey", Default = Enum.KeyCode.B, Mode = "Hold", Callback = function(Value)
	end})
	
	TriggerbotSettingsSection:Textbox({Name = "Delay", Default = tostring(Stranded.triggerbot.settings.delay), Placeholder = "0.1", Flag = "Triggerbot Delay", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value then
			Stranded.triggerbot.settings.delay = math.clamp(num_value, 0, 1)
		end
	end})
	
	TriggerbotSettingsSection:Textbox({Name = "Prediction", Default = tostring(Stranded.triggerbot.settings.prediction), Placeholder = "0.17", Flag = "Triggerbot Prediction", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value then
			Stranded.triggerbot.settings.prediction = math.clamp(num_value, 0, 1)
		end
	end})
	
	TriggerbotSettingsSection:Toggle({Name = "Auto Prediction", Flag = "Triggerbot Auto Prediction", Default = Stranded.triggerbot.settings.auto_prediction, Callback = function(Value)
		Stranded.triggerbot.settings.auto_prediction = Value
	end})
	
	local triggerbot_weapons = {
		"AK-47",
		"AR",
		"AUG",
		"Double Barrel SG",
		"Drum Gun",
		"Fists",
		"Flashbang",
		"Glock",
		"Grenade",
		"Grenade launcher",
		"Katana",
		"Knife",
		"P90",
		"Pepper Spray",
		"Pump Shotgun",
		"Revolver",
		"Rifle",
		"RPG",
		"Shovel",
		"Silencer",
		"Silencer AR",
		"Sledgehammer",
		"SMG",
		"Stop Sign",
		"Tactical Shotgun",
		"Taser"
	}
	
	if not Stranded.triggerbot.whitelist or type(Stranded.triggerbot.whitelist) ~= "table" then
		Stranded.triggerbot.whitelist = {}
	end
	
	TriggerbotWhitelistSection:Listbox({Name = "Whitelist", Flag = "Triggerbot Whitelist", Multi = true, Default = Stranded.triggerbot.whitelist, Items = triggerbot_weapons, Callback = function(Value)
		Stranded.triggerbot.whitelist = Value
	end})

	local ChecksSection, GunModificationSection = CombatTab:MultiSection({Sections = {"Checks", "Gun Modification"}, Side = 2})
	
	ChecksSection:Toggle({Name = "Dead Check", Flag = "Dead Check", Default = Stranded.Mods.checks.Dead, Callback = function(Value)
		Stranded.Mods.checks.Dead = Value
	end})
	
	ChecksSection:Toggle({Name = "Teamcheck", Flag = "Teamcheck", Default = Stranded.Mods.checks.Teamcheck, Callback = function(Value)
		Stranded.Mods.checks.Teamcheck = Value
	end})
	
	ChecksSection:Toggle({Name = "Wallcheck", Flag = "Wallcheck", Default = Stranded.Mods.checks.Wallcheck, Callback = function(Value)
		Stranded.Mods.checks.Wallcheck = Value
	end})
	
	ChecksSection:Toggle({Name = "Forcefield Check", Flag = "Forcefield Check", Default = Stranded.Mods.checks.Forcefield, Callback = function(Value)
		Stranded.Mods.checks.Forcefield = Value
	end})
	
	GunModificationSection:Toggle({Name = "No Recoil", Flag = "No Recoil", Default = Stranded.Mods.GunMods.NoRecoil, Callback = function(Value)
		Stranded.Mods.GunMods.NoRecoil = Value
		if esp and esp.funcs.setup_gun_mods then
			esp.funcs.setup_gun_mods()
		end
	end})
	
	GunModificationSection:Toggle({Name = "No Spread", Flag = "No Spread", Default = Stranded.Mods.GunMods.NoSpread, Callback = function(Value)
		Stranded.Mods.GunMods.NoSpread = Value
		if esp and esp.funcs.setup_gun_mods then
			esp.funcs.setup_gun_mods()
		end
	end})
	
	GunModificationSection:Toggle({Name = "Rapid Fire", Flag = "Rapid Fire", Default = Stranded.Mods.GunMods.RapidFire, Callback = function(Value)
		Stranded.Mods.GunMods.RapidFire = Value
		if esp and esp.funcs.setup_gun_mods then
			esp.funcs.setup_gun_mods()
		end
	end})
	

	lighting_section:Toggle({Name = "Enabled", Flag = "Lighting Enabled", Default = Stranded.lighting.enabled, Callback = function(Value)
		Stranded.lighting.enabled = Value
	end})
	
	lighting_section:Slider({Name = "Brightness", Min = 0, Max = 10, Default = safe_number(Stranded.lighting.brightness, 2), Decimals = 0.1, Compact = true, Flag = "Brightness", Callback = function(Value)
		Stranded.lighting.brightness = math.clamp(Value, 0, 10)
	end})
	
	local AmbientToggle = lighting_section:Toggle({Name = "Ambient", Flag = "Ambient Enabled", Default = Stranded.lighting.ambience.enabled or false, Callback = function(Value)
		Stranded.lighting.ambience.enabled = Value
	end})
	
	AmbientToggle:Colorpicker({Name = "Ambient", Flag = "Ambient Color", Default = Stranded.lighting.ambience.ambient, Callback = function(Value)
		Stranded.lighting.ambience.ambient = Value
		if Stranded.lighting.enabled and Stranded.lighting.ambience.enabled then
			local lighting = game:GetService("Lighting")
			lighting.Ambient = Value
		end
	end})
	
	local OutdoorAmbientToggle = lighting_section:Toggle({Name = "Outdoor Ambient", Flag = "Outdoor Ambient Enabled", Default = Stranded.lighting.ambience.outdoor_ambient_enabled or false, Callback = function(Value)
		Stranded.lighting.ambience.outdoor_ambient_enabled = Value
	end})
	
	OutdoorAmbientToggle:Colorpicker({Name = "Outdoor Ambient", Flag = "Outdoor Ambient Color", Default = Stranded.lighting.ambience.outdoor_ambient, Callback = function(Value)
		Stranded.lighting.ambience.outdoor_ambient = Value
		if Stranded.lighting.enabled and Stranded.lighting.ambience.outdoor_ambient_enabled then
			local lighting = game:GetService("Lighting")
			lighting.OutdoorAmbient = Value
		end
	end})
	
	lighting_section:Slider({Name = "Clock Time", Min = 0, Max = 24, Default = safe_number(Stranded.lighting.clocktime.clock_time, 12), Suffix = "h", Decimals = 0.1, Compact = true, Flag = "Clock Time", Callback = function(Value)
		Stranded.lighting.clocktime.clock_time = math.clamp(Value, 0, 24)
	end})
	
	local FogColorToggle = lighting_section:Toggle({Name = "Fog Color", Flag = "Fog Color Enabled", Default = Stranded.lighting.fog.enabled or false, Callback = function(Value)
		Stranded.lighting.fog.enabled = Value
	end})
	
	FogColorToggle:Colorpicker({Name = "Fog Color", Flag = "Fog Color", Default = Stranded.lighting.fog.color, Callback = function(Value)
		Stranded.lighting.fog.color = Value
		if Stranded.lighting.enabled and Stranded.lighting.fog.enabled then
			local lighting = game:GetService("Lighting")
			lighting.FogColor = Value
		end
	end})
	
	lighting_section:Slider({Name = "Fog Start", Min = 0, Max = 1000, Default = safe_number(Stranded.lighting.fog.start, 0), Suffix = "studs", Decimals = 0, Compact = true, Flag = "Fog Start", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.lighting.fog.start = math.clamp(math.floor(num_value), 0, 1000)
		else
			Stranded.lighting.fog.start = 0
		end
	end})
	
	lighting_section:Slider({Name = "Fog End", Min = 0, Max = 1000, Default = safe_number(Stranded.lighting.fog.ending, 500), Suffix = "studs", Decimals = 0, Compact = true, Flag = "Fog End", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.lighting.fog.ending = math.clamp(math.floor(num_value), 0, 1000)
		else
			Stranded.lighting.fog.ending = 500
		end
	end})
	
	lighting_section:Toggle({Name = "Global Shadows", Flag = "Global Shadows", Default = Stranded.lighting.shadows.global_shadows, Callback = function(Value)
		Stranded.lighting.shadows.global_shadows = Value
	end})
	
	lighting_section:Toggle({Name = "Shadow Softness", Flag = "Shadow Softness Enabled", Default = Stranded.lighting.shadows.softness_enabled or false, Callback = function(Value)
		Stranded.lighting.shadows.softness_enabled = Value
	end})
	
	lighting_section:Slider({Name = "Shadow Softness", Min = 0, Max = 1, Default = safe_number(Stranded.lighting.shadows.softness, 0.2), Decimals = 0.1, Compact = true, Flag = "Shadow Softness", Callback = function(Value)
		Stranded.lighting.shadows.softness = math.clamp(Value, 0, 1)
	end})
	
	lighting_section:Slider({Name = "Geographic Latitude", Min = -90, Max = 90, Default = safe_number(Stranded.lighting.clocktime.geographic_latitude, 41.88), Suffix = "", Decimals = 0.01, Compact = true, Flag = "Geographic Latitude", Callback = function(Value)
		Stranded.lighting.clocktime.geographic_latitude = math.clamp(Value, -90, 90)
	end})
	
	local ColorShiftToggle = lighting_section:Toggle({Name = "Color Shift", Flag = "Color Shift Enabled", Default = Stranded.lighting.color_shift.enabled or false, Callback = function(Value)
		Stranded.lighting.color_shift.enabled = Value
	end})
	
	ColorShiftToggle:Colorpicker({Name = "Color Shift Top", Flag = "Color Shift Top", Default = Stranded.lighting.color_shift.top, Callback = function(Value)
		Stranded.lighting.color_shift.top = Value
		if Stranded.lighting.enabled and Stranded.lighting.color_shift.enabled then
			local lighting = game:GetService("Lighting")
			lighting.ColorShift_Top = Value
		end
	end})
	
	ColorShiftToggle:Colorpicker({Name = "Color Shift Bottom", Flag = "Color Shift Bottom", Default = Stranded.lighting.color_shift.bottom, Callback = function(Value)
		Stranded.lighting.color_shift.bottom = Value
		if Stranded.lighting.enabled and Stranded.lighting.color_shift.enabled then
			local lighting = game:GetService("Lighting")
			lighting.ColorShift_Bottom = Value
		end
	end})
	
	lighting_section:Toggle({Name = "Environment", Flag = "Environment Enabled", Default = Stranded.lighting.environment.enabled or false, Callback = function(Value)
		Stranded.lighting.environment.enabled = Value
	end})
	
	lighting_section:Slider({Name = "Environment Diffuse Scale", Min = 0, Max = 2, Default = safe_number(Stranded.lighting.environment.diffuse_scale, 1), Decimals = 0.1, Compact = true, Flag = "Environment Diffuse Scale", Callback = function(Value)
		Stranded.lighting.environment.diffuse_scale = math.clamp(Value, 0, 2)
	end})
	
	lighting_section:Slider({Name = "Environment Specular Scale", Min = 0, Max = 2, Default = safe_number(Stranded.lighting.environment.specular_scale, 1), Decimals = 0.1, Compact = true, Flag = "Environment Specular Scale", Callback = function(Value)
		Stranded.lighting.environment.specular_scale = math.clamp(Value, 0, 2)
	end})
	
	lighting_section:Slider({Name = "Exposure Compensation", Min = -5, Max = 5, Default = safe_number(Stranded.lighting.quality.exposure_compensation, 0), Decimals = 0.1, Compact = true, Flag = "Exposure Compensation", Callback = function(Value)
		Stranded.lighting.quality.exposure_compensation = math.clamp(Value, -5, 5)
	end})
	
	lighting_section:Toggle({Name = "Prioritize Lighting Quality", Flag = "Prioritize Lighting Quality", Default = Stranded.lighting.quality.prioritize_lighting_quality, Callback = function(Value)
		Stranded.lighting.quality.prioritize_lighting_quality = Value
	end})
	
	misc_section:Slider({Name = "Box Transparency", Min = 0, Max = 1, Default = safe_number(Stranded.box.transparency, 0.6), Decimals = 0.01, Compact = true, Flag = "Box Transparency", Callback = function(Value)
		Stranded.box.transparency = math.clamp(Value, 0, 1)
	end})
	
	misc_section:Slider({Name = "Box Thickness", Min = 0.5, Max = 5, Default = safe_number(Stranded.box.thickness, 1.5), Decimals = 0.1, Compact = true, Flag = "Box Thickness", Callback = function(Value)
		Stranded.box.thickness = math.clamp(Value, 0.5, 5)
	end})
	
	misc_section:Slider({Name = "Skeleton Thickness", Min = 0.5, Max = 5, Default = safe_number(Stranded.skeleton.thickness, 1.2), Decimals = 0.1, Compact = true, Flag = "Skeleton Thickness", Callback = function(Value)
		Stranded.skeleton.thickness = math.clamp(Value, 0.5, 5)
	end})
	
	misc_section:Slider({Name = "Skeleton Transparency", Min = 0, Max = 1, Default = safe_number(Stranded.skeleton.transparency, 0.15), Decimals = 0.01, Compact = true, Flag = "Skeleton Transparency", Callback = function(Value)
		Stranded.skeleton.transparency = math.clamp(Value, 0, 1)
	end})
	
	misc_section:Slider({Name = "Skeleton Outline Thickness", Min = 0.5, Max = 5, Default = safe_number(Stranded.skeleton.outline.thickness, 2.5), Decimals = 0.1, Compact = true, Flag = "Skeleton Outline Thickness", Callback = function(Value)
		Stranded.skeleton.outline.thickness = math.clamp(Value, 0.5, 5)
	end})
	
	misc_section:Slider({Name = "Chams Fill Transparency", Min = 0, Max = 1, Default = safe_number(Stranded.chams.fill_transparency, 0.5), Decimals = 0.01, Compact = true, Flag = "Chams Fill Transparency", Callback = function(Value)
		Stranded.chams.fill_transparency = math.clamp(Value, 0, 1)
	end})
	
	misc_section:Slider({Name = "Chams Outline Transparency", Min = 0, Max = 1, Default = safe_number(Stranded.chams.outline_transparency, 0), Decimals = 0.01, Compact = true, Flag = "Chams Outline Transparency", Callback = function(Value)
		Stranded.chams.outline_transparency = math.clamp(Value, 0, 1)
	end})
	
	
	misc_section:Dropdown({Name = "Box Type", Flag = "Box Type", Default = Stranded.box.type, Items = {"Full"}, Callback = function(Value)
		Stranded.box.type = Value
	end})
	
	misc_section:Slider({Name = "FOV Thickness", Min = 0.5, Max = 5, Default = safe_number(Stranded.fov.thickness, 1), Decimals = 0.1, Compact = true, Flag = "FOV Thickness", Callback = function(Value)
		Stranded.fov.thickness = math.clamp(Value, 0.5, 5)
	end})
	
	misc_section:Slider({Name = "FOV Transparency", Min = 0, Max = 1, Default = safe_number(Stranded.fov.transparency, 0.4), Decimals = 0.01, Compact = true, Flag = "FOV Transparency", Callback = function(Value)
		Stranded.fov.transparency = math.clamp(Value, 0, 1)
	end})
	
	misc_section:Slider({Name = "FOV Lines", Min = 8, Max = 128, Default = safe_number(Stranded.fov and Stranded.fov.lines, 64), Decimals = 0, Compact = true, Flag = "FOV Lines", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.fov.lines = math.floor(math.clamp(num_value, 8, 128))
		else
			Stranded.fov.lines = 64
		end
	end})
	
	misc_section:Slider({Name = "FOV Size", Min = 0, Max = 500, Default = safe_number(Stranded.fov and Stranded.fov.radius, 150), Suffix = "studs", Decimals = 0, Compact = true, Flag = "FOV Size", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.fov.radius = math.floor(math.clamp(num_value, 0, 500))
		else
			Stranded.fov.radius = 150
		end
	end})
	
	misc_section:Slider({Name = "FOV Gradient Rotation", Min = 0, Max = 360, Default = safe_number(Stranded.fov and Stranded.fov.gradient and Stranded.fov.gradient.rotation, 90), Suffix = "", Decimals = 0, Compact = true, Flag = "FOV Gradient Rotation", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.fov.gradient.rotation = math.clamp(math.floor(num_value), 0, 360)
		else
			Stranded.fov.gradient.rotation = 90
		end
	end})
	
	misc_section:Slider({Name = "FOV Gradient Rotation Speed", Min = -20, Max = 20, Default = safe_number(Stranded.fov.gradient.rotation_speed, 0), Decimals = 0.1, Compact = true, Flag = "FOV Gradient Rotation Speed", Callback = function(Value)
		Stranded.fov.gradient.rotation_speed = math.clamp(Value, -20, 20)
	end})
	
	misc_section:Dropdown({Name = "FOV Animegirls Type", Flag = "FOV Animegirls Type", Default = Stranded.fov.options.animegirls.type, Items = {"1"}, Callback = function(Value)
		Stranded.fov.options.animegirls.type = Value
	end})
	
	misc_section:Dropdown({Name = "FOV Label Follow Type", Flag = "FOV Label Follow Type", Default = Stranded.fov.options.label.followtype, Items = {"Smooth", "Instant"}, Callback = function(Value)
		Stranded.fov.options.label.followtype = Value
	end})
	
	misc_section:Slider({Name = "Health Bar Width", Min = 0.5, Max = 5, Default = safe_number(Stranded.health_bar.width, 1), Decimals = 0.1, Compact = true, Flag = "Health Bar Width", Callback = function(Value)
		Stranded.health_bar.width = math.clamp(Value, 0.5, 5)
	end})
	
	misc_section:Slider({Name = "Armor Bar Width", Min = 0.5, Max = 5, Default = safe_number(Stranded.armor_bar.width, 1), Decimals = 0.1, Compact = true, Flag = "Armor Bar Width", Callback = function(Value)
		Stranded.armor_bar.width = math.clamp(Value, 0.5, 5)
	end})
	
	misc_section:Slider({Name = "Fog Start", Min = 0, Max = 1000, Default = safe_number(Stranded.lighting.fog.start, 0), Suffix = "studs", Decimals = 0, Compact = true, Flag = "Fog Start Misc", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.lighting.fog.start = math.clamp(math.floor(num_value), 0, 1000)
			if Stranded.lighting.enabled and Stranded.lighting.fog.enabled then
				local lighting = game:GetService("Lighting")
				lighting.FogStart = Stranded.lighting.fog.start
			end
		else
			Stranded.lighting.fog.start = 0
		end
	end})
	
	misc_section:Slider({Name = "Fog End", Min = 0, Max = 1000, Default = safe_number(Stranded.lighting.fog.ending, 500), Suffix = "studs", Decimals = 0, Compact = true, Flag = "Fog End Misc", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.lighting.fog.ending = math.clamp(math.floor(num_value), 0, 1000)
			if Stranded.lighting.enabled and Stranded.lighting.fog.enabled then
				local lighting = game:GetService("Lighting")
				lighting.FogEnd = Stranded.lighting.fog.ending
			end
		else
			Stranded.lighting.fog.ending = 500
		end
	end})
	
end

do
	local movements_section = Main_Misc:Section({Name = "Movements", Side = 1})
	
	if not Stranded.cframe then
		Stranded.cframe = {
			enabled = false,
			keybinds = "Q",
			type = "Movedirection",
			speed = 100
		}
	end
	
	local cframe_toggle = movements_section:Toggle({Name = "CFrame", Flag = "CFrame Enabled", Default = Stranded.cframe.enabled, Callback = function(Value)
		Stranded.cframe.enabled = Value
	end})
	
	local cframe_keybind = cframe_toggle:Keybind({Name = "CFrame Keybind", Flag = "CFrame Hotkey", Default = Enum.KeyCode.Q, Mode = "Hold", Callback = function(Value)
		if Value then
			local key_name = tostring(Value):gsub("Enum.KeyCode.", "")
			Stranded.cframe.keybinds = key_name
		end
	end})
	
	movements_section:Dropdown({Name = "Type", Flag = "CFrame Type", Default = Stranded.cframe.type, Items = {"Movedirection", "WalkSpeed", "Noclip"}, Callback = function(Value)
		if Value then
			Stranded.cframe.type = Value
		end
	end})
	
	movements_section:Slider({Name = "Speed", Min = 0, Max = 500, Default = Stranded.cframe.speed or 100, Suffix = "studs/s", Decimals = 0, Compact = true, Flag = "CFrame Speed", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.cframe.speed = math.clamp(math.floor(num_value), 0, 500)
		end
	end})
	
	movements_section:Divider()
	
	if not Stranded.fly then
		Stranded.fly = {
			enabled = false,
			keybinds = "F",
			type = "Movedirection",
			speed = 50
		}
	end
	
	local fly_toggle = movements_section:Toggle({Name = "Fly", Flag = "Fly Enabled", Default = Stranded.fly.enabled, Callback = function(Value)
		Stranded.fly.enabled = Value
	end})
	
	local fly_keybind = fly_toggle:Keybind({Name = "Fly Keybind", Flag = "Fly Hotkey", Default = Enum.KeyCode.F, Mode = "Hold", Callback = function(Value)
		if Value then
			local key_name = tostring(Value):gsub("Enum.KeyCode.", "")
			Stranded.fly.keybinds = key_name
		end
	end})
	
	movements_section:Dropdown({Name = "Type", Flag = "Fly Type", Default = Stranded.fly.type, Items = {"Movedirection", "Noclip", "Velocity"}, Callback = function(Value)
		if Value then
			Stranded.fly.type = Value
		end
	end})
	
	movements_section:Slider({Name = "Speed", Min = 0, Max = 500, Default = Stranded.fly.speed or 50, Suffix = "studs/s", Decimals = 0, Compact = true, Flag = "Fly Speed", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.fly.speed = math.clamp(math.floor(num_value), 0, 500)
		end
	end})
	
	movements_section:Divider()
	
	if not Stranded.hipheight then
		Stranded.hipheight = {
			enabled = false,
			keybinds = "H",
			height = 0
		}
	end
	
	local hipheight_toggle = movements_section:Toggle({Name = "HipHeight", Flag = "HipHeight Enabled", Default = Stranded.hipheight.enabled, Callback = function(Value)
		Stranded.hipheight.enabled = Value
	end})
	
	local hipheight_keybind = hipheight_toggle:Keybind({Name = "HipHeight Keybind", Flag = "HipHeight Hotkey", Default = Enum.KeyCode.H, Mode = "Hold", Callback = function(Value)
		if Value then
			local key_name = tostring(Value):gsub("Enum.KeyCode.", "")
			Stranded.hipheight.keybinds = key_name
		end
	end})
	
	movements_section:Slider({Name = "Height", Min = -10, Max = 50, Default = Stranded.hipheight.height or 0, Suffix = "studs", Decimals = 1, Compact = true, Flag = "HipHeight Value", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.hipheight.height = math.clamp(num_value, -10, 50)
		end
	end})
	
	movements_section:Divider()
	
	if not Stranded.jumppower then
		Stranded.jumppower = {
			enabled = false,
			power = 50
		}
	end
	
	local jumppower_toggle = movements_section:Toggle({Name = "JumpPower", Flag = "JumpPower Enabled", Default = Stranded.jumppower.enabled, Callback = function(Value)
		Stranded.jumppower.enabled = Value
	end})
	
	movements_section:Slider({Name = "Power", Min = 0, Max = 200, Default = Stranded.jumppower.power or 50, Suffix = "studs/s", Decimals = 0, Compact = true, Flag = "JumpPower Value", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.jumppower.power = math.clamp(math.floor(num_value), 0, 200)
		end
	end})
	
	movements_section:Divider()
	
	if not Stranded.gravity then
		Stranded.gravity = {
			enabled = false,
			keybinds = "G",
			gravity = 196.2
		}
	end
	
	local gravity_toggle = movements_section:Toggle({Name = "Gravity", Flag = "Gravity Enabled", Default = Stranded.gravity.enabled, Callback = function(Value)
		Stranded.gravity.enabled = Value
	end})
	
	local gravity_keybind = gravity_toggle:Keybind({Name = "Gravity Keybind", Flag = "Gravity Hotkey", Default = Enum.KeyCode.G, Mode = "Hold", Callback = function(Value)
		if Value then
			local key_name = tostring(Value):gsub("Enum.KeyCode.", "")
			Stranded.gravity.keybinds = key_name
		end
	end})
	
	movements_section:Slider({Name = "Gravity", Min = -500, Max = 500, Default = Stranded.gravity.gravity or 196.2, Suffix = "studs/s", Decimals = 1, Compact = true, Flag = "Gravity Value", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.gravity.gravity = math.clamp(num_value, -500, 500)
		end
	end})
	
end

do
	local automation_section = Main_Misc:Section({Name = "Automation", Side = 2})
	
	if not Stranded.automation then
		Stranded.automation = {
			anti_afk = { enabled = false },
			anti_stomp = { enabled = false },
			autofarm = { enabled = false, saver = false },
			auto_collect = { enabled = false, range = 17 }
		}
	end
	
	automation_section:Toggle({Name = "Anti-AFK", Flag = "Anti-AFK Enabled", Default = Stranded.automation.anti_afk.enabled, Callback = function(Value)
		Stranded.automation.anti_afk.enabled = Value
	end})
	
	automation_section:Toggle({Name = "Anti-Stomp", Flag = "Anti-Stomp Enabled", Default = Stranded.automation.anti_stomp.enabled, Callback = function(Value)
		Stranded.automation.anti_stomp.enabled = Value
	end})
	
	automation_section:Divider()
	
	local autofarm_toggle = automation_section:Toggle({Name = "Auto Farm", Flag = "Auto Farm Enabled", Default = Stranded.automation.autofarm.enabled, Callback = function(Value)
		Stranded.automation.autofarm.enabled = Value
	end})
	

	
	automation_section:Toggle({Name = "Saver Mode", Flag = "Auto Farm Saver", Default = Stranded.automation.autofarm.saver, Callback = function(Value)
		Stranded.automation.autofarm.saver = Value
	end})
	
	automation_section:Divider()
	
	automation_section:Toggle({Name = "Auto Collect", Flag = "Auto Collect Enabled", Default = Stranded.automation.auto_collect.enabled, Callback = function(Value)
		Stranded.automation.auto_collect.enabled = Value
	end})
	
	automation_section:Slider({Name = "Range", Min = 5, Max = 50, Default = Stranded.automation.auto_collect.range or 17, Suffix = "studs", Decimals = 0, Compact = true, Flag = "Auto Collect Range", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.automation.auto_collect.range = math.clamp(math.floor(num_value), 5, 50)
		end
	end})
	
	automation_section:Divider()
	
	if not Stranded.automation.autobuy then
		Stranded.automation.autobuy = {
			selected_gun = "[Rifle]",
			buy_ammo = false,
			auto_loadout = false,
			auto_armor = false,
			buying_single = false
		}
	end
	
	
	automation_section:Dropdown({Name = "Auto Buy Gun", Flag = "Autobuy Gun", Default = Stranded.automation.autobuy.selected_gun or "[Rifle]", Items = {
		"[Rifle]",
		"[LMG]",
		"[AK47]",
		"[AUG]",
		"[AR]",
		"[Double-Barrel SG]",
		"[Drum-Shotgun]",
		"[DrumGun]",
		"[Glock]",
		"[P90]",
		"[Revolver]",
		"[RPG]",
		"[Shotgun]",
		"[Silencer]",
		"[SilencerAR]",
		"[TacticalShotgun]"
	}, Callback = function(Value)
		Stranded.automation.autobuy.selected_gun = Value
	end})
	
	
	automation_section:Button({Name = "Buy Selected Gun", Callback = function()
		Stranded.automation.autobuy.buying_single = true
	end})
	
	
	automation_section:Toggle({Name = "Buy Ammo", Flag = "Autobuy Ammo", Default = Stranded.automation.autobuy.buy_ammo, Callback = function(Value)
		Stranded.automation.autobuy.buy_ammo = Value
	end})
	
	automation_section:Toggle({Name = "Auto Loadout", Flag = "Autobuy Loadout", Default = Stranded.automation.autobuy.auto_loadout, Callback = function(Value)
		Stranded.automation.autobuy.auto_loadout = Value
	end})
	
	automation_section:Toggle({Name = "Auto Armor", Flag = "Autobuy Armor", Default = Stranded.automation.autobuy.auto_armor, Callback = function(Value)
		Stranded.automation.autobuy.auto_armor = Value
	end})
	
	automation_section:Divider()
	
	if not Stranded.automation.auto_reload then
		Stranded.automation.auto_reload = {
			enabled = false
		}
	end
	
	automation_section:Toggle({Name = "Auto Reload", Flag = "Auto Reload Enabled", Default = Stranded.automation.auto_reload.enabled, Callback = function(Value)
		Stranded.automation.auto_reload.enabled = Value
	end})
	
end

do
	local utility_section = Main_Misc:Section({Name = "Utility", Side = 1})
	
	if not Stranded.utility then
		Stranded.utility = {
			chat_spammer = { enabled = false, type = "Custom", message = "spam", delay = 1 },
			viewmodel_changer = { enabled = false, x_offset = 0, y_offset = 0, z_offset = 0 },
			fov_changer = { enabled = false, fov = 70 }
		}
	end
	
	if not Stranded.utility.chat_spammer then
		Stranded.utility.chat_spammer = {
			enabled = false,
			type = "Custom",
			message = "spam",
			delay = 1
		}
	end
	
	utility_section:Toggle({Name = "Chat Spammer", Flag = "Chat Spammer Enabled", Default = Stranded.utility.chat_spammer.enabled, Callback = function(Value)
		Stranded.utility.chat_spammer.enabled = Value
	end})
	
	utility_section:Dropdown({Name = "Type", Flag = "Chat Spammer Type", Default = Stranded.utility.chat_spammer.type or "Custom", Items = {"Custom", "Trash Talk"}, Callback = function(Value)
		Stranded.utility.chat_spammer.type = Value
	end})
	
	utility_section:Textbox({Name = "Message", Flag = "Chat Spammer Message", Default = Stranded.utility.chat_spammer.message or "spam", Callback = function(Value)
		Stranded.utility.chat_spammer.message = Value
	end})
	
	utility_section:Slider({Name = "Delay", Min = 0.1, Max = 10, Default = Stranded.utility.chat_spammer.delay or 1, Suffix = "s", Decimals = 1, Compact = true, Flag = "Chat Spammer Delay", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.utility.chat_spammer.delay = math.clamp(num_value, 0.1, 10)
		end
	end})
	
	utility_section:Divider()
	
	if not Stranded.utility.viewmodel_changer then
		Stranded.utility.viewmodel_changer = {
			enabled = false,
			x_offset = 0,
			y_offset = 0,
			z_offset = 0
		}
	end
	
	utility_section:Toggle({Name = "Viewmodel Changer", Flag = "Viewmodel Changer Enabled", Default = Stranded.utility.viewmodel_changer.enabled, Callback = function(Value)
		Stranded.utility.viewmodel_changer.enabled = Value
	end})
	
	utility_section:Slider({Name = "X Offset", Min = -10, Max = 10, Default = Stranded.utility.viewmodel_changer.x_offset or 0, Suffix = "studs", Decimals = 1, Compact = true, Flag = "Viewmodel X Offset", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.utility.viewmodel_changer.x_offset = math.clamp(num_value, -10, 10)
		end
	end})
	
	utility_section:Slider({Name = "Y Offset", Min = -10, Max = 10, Default = Stranded.utility.viewmodel_changer.y_offset or 0, Suffix = "studs", Decimals = 1, Compact = true, Flag = "Viewmodel Y Offset", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.utility.viewmodel_changer.y_offset = math.clamp(num_value, -10, 10)
		end
	end})
	
	utility_section:Slider({Name = "Z Offset", Min = -10, Max = 10, Default = Stranded.utility.viewmodel_changer.z_offset or 0, Suffix = "studs", Decimals = 1, Compact = true, Flag = "Viewmodel Z Offset", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.utility.viewmodel_changer.z_offset = math.clamp(num_value, -10, 10)
		end
	end})
	
	utility_section:Divider()
	
	if not Stranded.utility.fov_changer then
		Stranded.utility.fov_changer = {
			enabled = false,
			fov = 70
		}
	end
	
	utility_section:Toggle({Name = "FOV Changer", Flag = "FOV Changer Enabled", Default = Stranded.utility.fov_changer.enabled, Callback = function(Value)
		Stranded.utility.fov_changer.enabled = Value
	end})
	
	utility_section:Slider({Name = "FOV", Min = 0, Max = 120, Default = Stranded.utility.fov_changer.fov or 70, Suffix = "", Decimals = 0, Compact = true, Flag = "FOV Changer Value", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.utility.fov_changer.fov = math.clamp(math.floor(num_value), 0, 120)
		end
	end})
	
end

do
	local player_section = Main_Misc:Section({Name = "Player", Side = 2})
	
	if not Stranded.utility.animation_player then
		Stranded.utility.animation_player = {
			enabled = false,
			animation_id = "rbxassetid://14352343065",
			speed = 1
		}
	end
	
	local animation_ids = {
		["Baby Queen - Bouncy Twirl"] = "rbxassetid://14352343065",
		["Floss"] = "rbxassetid://10714340543",
		["Yungblud Happier Jump"] = "rbxassetid://15609995579",
		["Godlike"] = "rbxassetid://10714347256",
		["Mae Stephens - Piano Hands"] = "rbxassetid://16553163212",
		["Victory Dance"] = "rbxassetid://15505456446",
		["Elton John - Heart Skip"] = "rbxassetid://11309255148",
		["Sturdy Dance - Ice Spice"] = "rbxassetid://17746180844",
		["Old Town Road Dance - Lil Nas X (LNX)"] = "rbxassetid://10714391240"
	}
	
	local animation_names = {}
	for name, _ in pairs(animation_ids) do
		table.insert(animation_names, name)
	end
	table.sort(animation_names)
	
	local current_animation_name = "Baby Queen - Bouncy Twirl"
	for name, id in pairs(animation_ids) do
		if id == (Stranded.utility.animation_player.animation_id or "rbxassetid://14352343065") then
			current_animation_name = name
			break
		end
	end
	
	player_section:Toggle({Name = "Animation Player", Flag = "Animation Player Enabled", Default = Stranded.utility.animation_player.enabled, Callback = function(Value)
		Stranded.utility.animation_player.enabled = Value
	end})
	
	player_section:Dropdown({Name = "Animation", Flag = "Animation Selection", Default = current_animation_name, Items = animation_names, Callback = function(Value)
		if animation_ids[Value] then
			Stranded.utility.animation_player.animation_id = animation_ids[Value]
		end
	end})
	
	player_section:Slider({Name = "Animation Speed", Min = 0, Max = 10, Default = Stranded.utility.animation_player.speed or 1, Suffix = "x", Decimals = 1, Compact = true, Flag = "Animation Speed", Callback = function(Value)
		local num_value = tonumber(Value)
		if num_value and num_value == num_value then
			Stranded.utility.animation_player.speed = math.clamp(num_value, 0, 10)
		end
	end})
	
	player_section:Divider()
	
	if not Stranded.utility.avatar_changer then
		Stranded.utility.avatar_changer = {
			enabled = false,
			user_id = 244844600
		}
	end
	
	local avatar_ids = {
		["Nex5us"] = 244844600,
		["dtbbullet"] = 2395613299,
		["asdfxdheh"] = 2611320910,
		["u5eful"] = 2238867037,
		["leaf10p"] = 548146549,
		["luaClass"] = 3525918505,
		["HellaBitcoin"] = 3924051431,
		["kenami"] = 5649499,
		["jelu067067"] = 2611320910,
		["Dragonboi_148"] = 2238867037,
		["ppskin70"] = 548146549,
		["KreekCraft"] = 27676190
	}
	
	local avatar_names = {}
	for name, _ in pairs(avatar_ids) do
		table.insert(avatar_names, name)
	end
	table.sort(avatar_names)
	
	local current_avatar_name = "Nex5us"
	for name, id in pairs(avatar_ids) do
		if id == (Stranded.utility.avatar_changer.user_id or 244844600) then
			current_avatar_name = name
			break
		end
	end
	
	player_section:Toggle({Name = "Avatar Changer", Flag = "Avatar Changer Enabled", Default = Stranded.utility.avatar_changer.enabled, Callback = function(Value)
		Stranded.utility.avatar_changer.enabled = Value
		if Value then
			esp.funcs.avatar_changer_update()
		else
			local character = game.Players.LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChild("Humanoid")
				if humanoid then
					pcall(function()
						humanoid:ApplyDescriptionClientServer(game.Players:GetHumanoidDescriptionFromUserId(game.Players.LocalPlayer.UserId))
					end)
				end
			end
		end
	end})
	
	player_section:Dropdown({Name = "Select Avatar", Flag = "Avatar Selection", Default = current_avatar_name, Items = avatar_names, Callback = function(Value)
		if avatar_ids[Value] then
			Stranded.utility.avatar_changer.user_id = avatar_ids[Value]
			if Stranded.utility.avatar_changer.enabled then
				esp.funcs.avatar_changer_update()
			end
		end
	end})
	
	player_section:Divider()
	
	if not Stranded.utility.skin_changer then
		Stranded.utility.skin_changer = {
			enabled = false,
			skin = "Valentines"
		}
	end
	
	local skin_options = {"Valentines", "Rainbow", "Luck", "Christmas Wrap", "Snow Wrap", "Blue Wrap"}
	
	player_section:Toggle({Name = "Skin Changer", Flag = "Skin Changer Enabled", Default = Stranded.utility.skin_changer.enabled, Callback = function(Value)
		Stranded.utility.skin_changer.enabled = Value
		if Value then
			esp.funcs.skin_changer_update()
		else
			esp.vars.rs:UnbindFromRenderStep("Skin Changer")
		end
	end})
	
	player_section:Dropdown({Name = "Skin Pack", Flag = "Skin Pack Selection", Default = Stranded.utility.skin_changer.skin or "Valentines", Items = skin_options, Callback = function(Value)
		Stranded.utility.skin_changer.skin = Value
		if Stranded.utility.skin_changer.enabled then
			esp.vars.rs:UnbindFromRenderStep("Skin Changer")
			esp.funcs.skin_changer_update()
		end
	end})
	
end

do
	local placessection = Teloports_misc:Section({Name = "Places", Side = 1})
	
	placessection:Button({Name = "Church", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(147.299988, 18.8493252, 31.7999744, 0, 0, 1, 0, 1, -0, -1, 0, 0)
		end
	end})
	
	placessection:Button({Name = "Ufo", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(2.85052466, 132, -736.571106, -0.0460956171, -4.24733706e-08, -0.998937011, 7.26012459e-08, 1, -4.58687275e-08, 0.998937011, -7.46384217e-08, -0.0460956171)
		end
	end})
	
	placessection:Button({Name = "Casino", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-995, 21.6998043, -153.100037, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		end
	end})
	
	placessection:Button({Name = "Bank", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-318.891174, 80.2145309, -257.177429, 0.0479469746, -5.14644114e-08, 0.998850107, -3.12971538e-09, 1, 5.16738901e-08, -0.998850107, -5.60372015e-09, 0.0479469746)
		end
	end})
	
	placessection:Button({Name = "Taco", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(584.026855, 48.1605072, -474.033936, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		end
	end})
	
	placessection:Button({Name = "Revolver Roof", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-634.463135, 80.434761, -204.232559, -0.0190527271, -1.03574322e-07, -0.999818563, 4.36709335e-09, 1, -1.03676342e-07, 0.999818563, -6.3416179e-09, -0.0190527271)
		end
	end})
	
	placessection:Button({Name = "PlayGround", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-282.694153, 19.7496624, -807.719727, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		end
	end})
	
	placessection:Button({Name = "Gas Station", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(604.800415, 46.0998344, -258.249573, 0, 0, 1, 0, 1, -0, -1, 0, 0)
		end
	end})
	
	placessection:Button({Name = "Cementery", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(135.109558, 99.75, -57.2315979, 0.999993503, -0.000633752206, -0.0035054055, 0.000638642872, 0.999998808, 0.00139435288, 0.00350463158, -0.00139658386, 0.999992728)
		end
	end})
	
	placessection:Button({Name = "School Roof", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-525.353455, 68.125, 311.824402, 0.999992013, 1.03866675e-08, -0.00399552286, -1.03507425e-08, 1, 9.01170427e-09, 0.00399552286, -8.97027519e-09, 0.999992013)
		end
	end})
	
	local gunssection = Teloports_misc:Section({Name = "Guns", Side = 2})
	
	gunssection:Button({Name = "Revolver", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-638.75, 18.8500004, -118.175011, -1, 0, 0, 0, 1, 0, 0, 0, -1)
		end
	end})
	
	gunssection:Button({Name = "Ak", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-587.529358, 5.39480686, -753.717712, -1, 0, 0, 0, 1, 0, 0, 0, -1)
		end
	end})
	
	gunssection:Button({Name = "Smg", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-577.123413, 5.47666788, -718.031433, -1, 0, 0, 0, 1, 0, 0, 0, -1)
		end
	end})
	
	gunssection:Button({Name = "AR", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-591.824158, 5.46046877, -744.731628, 0, 0, 1, 0, 1, -0, -1, 0, 0)
		end
	end})
	
	gunssection:Button({Name = "Double Barrel", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-1039.59985, 18.8513641, -256.449951, -1, 0, 0, 0, 1, 0, 0, 0, -1)
		end
	end})
	
	gunssection:Button({Name = "Shotgun", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-578.623657, 5.47212696, -725.131531, 0, 0, 1, 0, 1, -0, -1, 0, 0)
		end
	end})
	
	gunssection:Button({Name = "Flame Thrower", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-157.122437, 50.9120102, -104.93145, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		end
	end})
	
	gunssection:Button({Name = "Tactical Shotgun", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(470.877533, 45.1272316, -620.630676, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		end
	end})
	
	gunssection:Button({Name = "Drum Gun", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-83.548996, 19.7020588, -82.1449585, 1, 0, 0, 0, 1, 0, 0, 0, 1)
		end
	end})
	
	gunssection:Button({Name = "High Medium Armor", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(-939, -25, 571)
		end
	end})
	
	gunssection:Button({Name = "Bat", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(380, 49, -283)
		end
	end})
	
	gunssection:Button({Name = "Medium Armor", Callback = function()
		local character = game.Players.LocalPlayer.Character
		if character and character:FindFirstChild("HumanoidRootPart") then
			character.HumanoidRootPart.CFrame = CFrame.new(528, 50, -637)
		end
	end})
	
end

do
	local SettingsSection = SettingsTab:Section({Name = "Settings", Side = 2})
	local ConfigsSection = SettingsTab:Section({Name = "Profiles", Side = 1})
	
	local preset_themes = {
		["Black & Red"] = {
			["Background"] = Color3.fromRGB(10, 10, 10),
			["Inline"] = Color3.fromRGB(15, 15, 15),
			["Page Background"] = Color3.fromRGB(20, 20, 20),
			["Border"] = Color3.fromRGB(5, 5, 5),
			["Outline"] = Color3.fromRGB(25, 5, 5),
			["Accent"] = Color3.fromRGB(255, 0, 0),
			["Element"] = Color3.fromRGB(18, 18, 18),
			["Hovered Element"] = Color3.fromRGB(30, 5, 5),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Stranded"] = {
			["Background"] = Color3.fromRGB(20, 5, 5),
			["Inline"] = Color3.fromRGB(30, 8, 8),
			["Page Background"] = Color3.fromRGB(40, 10, 10),
			["Border"] = Color3.fromRGB(15, 3, 3),
			["Outline"] = Color3.fromRGB(50, 15, 15),
			["Accent"] = Color3.fromRGB(220, 20, 20),
			["Element"] = Color3.fromRGB(35, 12, 12),
			["Hovered Element"] = Color3.fromRGB(50, 18, 18),
			["Text"] = Color3.fromRGB(240, 220, 220),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Default"] = {
			["Background"] = Color3.fromRGB(15, 15, 20),
			["Inline"] = Color3.fromRGB(20, 20, 25),
			["Page Background"] = Color3.fromRGB(30, 30, 35),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(27, 27, 32),
			["Accent"] = Color3.fromRGB(235, 157, 255),
			["Element"] = Color3.fromRGB(33, 33, 36),
			["Hovered Element"] = Color3.fromRGB(40, 40, 43),
			["Text"] = Color3.fromRGB(215, 215, 215),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Entropy"] = {
			["Background"] = Color3.fromRGB(40, 39, 46),
			["Inline"] = Color3.fromRGB(63, 63, 67),
			["Page Background"] = Color3.fromRGB(56, 54, 61),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(0, 0, 0),
			["Accent"] = Color3.fromRGB(147, 188, 222),
			["Element"] = Color3.fromRGB(48, 47, 54),
			["Hovered Element"] = Color3.fromRGB(56, 54, 61),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Dracula"] = {
			["Background"] = Color3.fromRGB(30, 31, 40),
			["Inline"] = Color3.fromRGB(49, 45, 62),
			["Page Background"] = Color3.fromRGB(35, 37, 48),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(29, 30, 39),
			["Accent"] = Color3.fromRGB(125, 104, 142),
			["Element"] = Color3.fromRGB(33, 34, 44),
			["Hovered Element"] = Color3.fromRGB(40, 41, 52),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Neverlose"] = {
			["Background"] = Color3.fromRGB(3, 4, 17),
			["Inline"] = Color3.fromRGB(29, 30, 39),
			["Page Background"] = Color3.fromRGB(0, 13, 23),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(1, 1, 1),
			["Accent"] = Color3.fromRGB(0, 158, 210),
			["Element"] = Color3.fromRGB(2, 9, 20),
			["Hovered Element"] = Color3.fromRGB(5, 18, 30),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Nanohub"] = {
			["Background"] = Color3.fromRGB(20, 20, 20),
			["Inline"] = Color3.fromRGB(50, 50, 50),
			["Page Background"] = Color3.fromRGB(30, 30, 30),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(0, 0, 0),
			["Accent"] = Color3.fromRGB(170, 0, 255),
			["Element"] = Color3.fromRGB(25, 25, 25),
			["Hovered Element"] = Color3.fromRGB(35, 35, 35),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Aimware"] = {
			["Background"] = Color3.fromRGB(23, 23, 25),
			["Inline"] = Color3.fromRGB(42, 42, 42),
			["Page Background"] = Color3.fromRGB(15, 16, 18),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(0, 0, 0),
			["Accent"] = Color3.fromRGB(222, 60, 39),
			["Element"] = Color3.fromRGB(19, 20, 22),
			["Hovered Element"] = Color3.fromRGB(27, 28, 30),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Spotify"] = {
			["Background"] = Color3.fromRGB(16, 16, 16),
			["Inline"] = Color3.fromRGB(36, 36, 36),
			["Page Background"] = Color3.fromRGB(19, 19, 19),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(0, 0, 0),
			["Accent"] = Color3.fromRGB(30, 193, 81),
			["Element"] = Color3.fromRGB(18, 18, 18),
			["Hovered Element"] = Color3.fromRGB(25, 25, 25),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Interwebz"] = {
			["Background"] = Color3.fromRGB(27, 19, 37),
			["Inline"] = Color3.fromRGB(53, 45, 64),
			["Page Background"] = Color3.fromRGB(35, 29, 48),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(25, 22, 25),
			["Accent"] = Color3.fromRGB(172, 89, 66),
			["Element"] = Color3.fromRGB(31, 24, 43),
			["Hovered Element"] = Color3.fromRGB(40, 32, 52),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Neko"] = {
			["Background"] = Color3.fromRGB(17, 17, 17),
			["Inline"] = Color3.fromRGB(39, 39, 38),
			["Page Background"] = Color3.fromRGB(19, 19, 18),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(25, 22, 25),
			["Accent"] = Color3.fromRGB(170, 27, 80),
			["Element"] = Color3.fromRGB(18, 18, 18),
			["Hovered Element"] = Color3.fromRGB(25, 25, 24),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Gamesense"] = {
			["Background"] = Color3.fromRGB(23, 23, 23),
			["Inline"] = Color3.fromRGB(41, 41, 41),
			["Page Background"] = Color3.fromRGB(27, 27, 27),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(31, 31, 31),
			["Accent"] = Color3.fromRGB(165, 209, 33),
			["Element"] = Color3.fromRGB(25, 25, 25),
			["Hovered Element"] = Color3.fromRGB(30, 30, 30),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Onetap"] = {
			["Background"] = Color3.fromRGB(31, 33, 37),
			["Inline"] = Color3.fromRGB(31, 33, 37),
			["Page Background"] = Color3.fromRGB(44, 48, 54),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(9, 11, 16),
			["Accent"] = Color3.fromRGB(186, 142, 77),
			["Element"] = Color3.fromRGB(38, 41, 46),
			["Hovered Element"] = Color3.fromRGB(50, 54, 60),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(44, 48, 54)
		},
		["Vape"] = {
			["Background"] = Color3.fromRGB(17, 17, 17),
			["Inline"] = Color3.fromRGB(39, 39, 38),
			["Page Background"] = Color3.fromRGB(19, 19, 18),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(0, 0, 0),
			["Accent"] = Color3.fromRGB(1, 190, 136),
			["Element"] = Color3.fromRGB(18, 18, 18),
			["Hovered Element"] = Color3.fromRGB(25, 25, 24),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Fatality"] = {
			["Background"] = Color3.fromRGB(25, 20, 52),
			["Inline"] = Color3.fromRGB(61, 55, 89),
			["Page Background"] = Color3.fromRGB(34, 27, 71),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(61, 55, 89),
			["Accent"] = Color3.fromRGB(236, 11, 79),
			["Element"] = Color3.fromRGB(30, 24, 62),
			["Hovered Element"] = Color3.fromRGB(40, 32, 80),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Nebula"] = {
			["Background"] = Color3.fromRGB(27, 27, 34),
			["Inline"] = Color3.fromRGB(39, 39, 47),
			["Page Background"] = Color3.fromRGB(41, 41, 50),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(1, 1, 1),
			["Accent"] = Color3.fromRGB(61, 100, 227),
			["Element"] = Color3.fromRGB(34, 34, 42),
			["Hovered Element"] = Color3.fromRGB(45, 45, 55),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Bitch Bot"] = {
			["Background"] = Color3.fromRGB(27, 27, 27),
			["Inline"] = Color3.fromRGB(26, 26, 26),
			["Page Background"] = Color3.fromRGB(48, 48, 48),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(1, 1, 1),
			["Accent"] = Color3.fromRGB(162, 46, 230),
			["Element"] = Color3.fromRGB(38, 38, 38),
			["Hovered Element"] = Color3.fromRGB(50, 50, 50),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Primordial"] = {
			["Background"] = Color3.fromRGB(23, 23, 25),
			["Inline"] = Color3.fromRGB(12, 14, 18),
			["Page Background"] = Color3.fromRGB(23, 25, 24),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(0, 0, 0),
			["Accent"] = Color3.fromRGB(221, 192, 201),
			["Element"] = Color3.fromRGB(18, 20, 22),
			["Hovered Element"] = Color3.fromRGB(25, 27, 30),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Lucky Charms"] = {
			["Background"] = Color3.fromRGB(42, 42, 42),
			["Inline"] = Color3.fromRGB(35, 37, 36),
			["Page Background"] = Color3.fromRGB(35, 37, 36),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(42, 42, 42),
			["Accent"] = Color3.fromRGB(27, 96, 38),
			["Element"] = Color3.fromRGB(39, 40, 39),
			["Hovered Element"] = Color3.fromRGB(45, 47, 46),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Seere"] = {
			["Background"] = Color3.fromRGB(17, 17, 17),
			["Inline"] = Color3.fromRGB(28, 28, 28),
			["Page Background"] = Color3.fromRGB(20, 20, 20),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(1, 1, 1),
			["Accent"] = Color3.fromRGB(35, 131, 167),
			["Element"] = Color3.fromRGB(19, 19, 19),
			["Hovered Element"] = Color3.fromRGB(25, 25, 25),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Azure"] = {
			["Background"] = Color3.fromRGB(65, 65, 65),
			["Inline"] = Color3.fromRGB(72, 72, 72),
			["Page Background"] = Color3.fromRGB(80, 80, 80),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(60, 60, 60),
			["Accent"] = Color3.fromRGB(222, 117, 222),
			["Element"] = Color3.fromRGB(73, 73, 73),
			["Hovered Element"] = Color3.fromRGB(85, 85, 85),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		},
		["Rifk7"] = {
			["Background"] = Color3.fromRGB(33, 33, 33),
			["Inline"] = Color3.fromRGB(105, 105, 105),
			["Page Background"] = Color3.fromRGB(34, 34, 34),
			["Border"] = Color3.fromRGB(10, 10, 10),
			["Outline"] = Color3.fromRGB(20, 20, 20),
			["Accent"] = Color3.fromRGB(128, 158, 134),
			["Element"] = Color3.fromRGB(34, 34, 34),
			["Hovered Element"] = Color3.fromRGB(45, 45, 45),
			["Text"] = Color3.fromRGB(255, 255, 255),
			["Text Border"] = Color3.fromRGB(0, 0, 0)
		}
	}
	
	local function apply_theme(theme_name)
		local theme = preset_themes[theme_name]
		if not theme then return end
		
		for Index, Color in pairs(theme) do
			Library.Theme[Index] = Color
			Library:ChangeTheme(Index, Color)
			if Library.Flags["Theme"..Index] then
				Library.Flags["Theme"..Index].Color = Color
			end
		end
	end
	
	local current_theme = "Black & Red"
	
	SettingsSection:Dropdown({Name = "Theme Preset", Flag = "Theme Preset", Default = current_theme, Items = {"Black & Red", "Stranded", "Default", "Entropy", "Dracula", "Neverlose", "Nanohub", "Aimware", "Spotify", "Interwebz", "Neko", "Gamesense", "Onetap", "Vape", "Fatality", "Nebula", "Bitch Bot", "Primordial", "Lucky Charms", "Seere", "Azure", "Rifk7"}, Callback = function(Value)
		apply_theme(Value)
		current_theme = Value
	end})
	
	for Index, Value in Library.Theme do 
		SettingsSection:Label({Name = Index, Alignment = "Left"}):Colorpicker({ Name = Index, Default = Value, Flag = "Theme"..Index, Callback = function(Color) 
			Library.Theme[Index] = Color
			Library:ChangeTheme(Index, Color)
		end})
	end
	
	SettingsSection:Label({Name = "Menu Keybind", Alignment = "Left"}):Keybind({Name = "Menu Keybind", Flag = "Menu Keybind", Default = Enum.KeyCode.RightControl, Mode = "Toggle", Callback = function(Value)
		Library.MenuKeybind = Library.Flags["Menu Keybind"].Key
	end})
	
	SettingsSection:Toggle({Name = "Watermark", Flag = "Watermark", Default = true, Callback = function(Value)
		Watermark:SetVisibility(Value)
	end})
	
	SettingsSection:Toggle({Name = "Keybind List", Flag = "Keybind List", Default = true, Callback = function(Value)
		KeybindList:SetVisibility(Value)
	end})
	
	local font_names = {
		"Legacy", "Gotham", "GothamBold", "GothamSemibold", "GothamMedium",
		"SourceSans", "SourceSansBold", "SourceSansItalic", "SourceSansSemibold",
		"Arial", "ArialBold", "Code", "FredokaOne", "Highway",
		"IndieFlower", "JosefinSans", "Jura", "Kalam", "Merriweather", "Oswald",
		"PatrickHand", "PermanentMarker", "Roboto", "RobotoCondensed", "RobotoMono",
		"Sarpanch", "SciFi", "SpecialElite", "TitilliumWeb", "Ubuntu"
	}
	
	local font_map = {
		Legacy = Enum.Font.Legacy,
		Gotham = Enum.Font.Gotham,
		GothamBold = Enum.Font.GothamBold,
		GothamSemibold = Enum.Font.GothamSemibold,
		GothamMedium = Enum.Font.GothamMedium,
		SourceSans = Enum.Font.SourceSans,
		SourceSansBold = Enum.Font.SourceSansBold,
		SourceSansItalic = Enum.Font.SourceSansItalic,
		SourceSansSemibold = Enum.Font.SourceSansSemibold,
		Arial = Enum.Font.Arial,
		ArialBold = Enum.Font.ArialBold,
		Code = Enum.Font.Code,
		FredokaOne = Enum.Font.FredokaOne,
		Highway = Enum.Font.Highway,
		IndieFlower = Enum.Font.IndieFlower,
		JosefinSans = Enum.Font.JosefinSans,
		Jura = Enum.Font.Jura,
		Kalam = Enum.Font.Kalam,
		Merriweather = Enum.Font.Merriweather,
		Oswald = Enum.Font.Oswald,
		PatrickHand = Enum.Font.PatrickHand,
		PermanentMarker = Enum.Font.PermanentMarker,
		Roboto = Enum.Font.Roboto,
		RobotoCondensed = Enum.Font.RobotoCondensed,
		RobotoMono = Enum.Font.RobotoMono,
		Sarpanch = Enum.Font.Sarpanch,
		SciFi = Enum.Font.SciFi,
		SpecialElite = Enum.Font.SpecialElite,
		TitilliumWeb = Enum.Font.TitilliumWeb,
		Ubuntu = Enum.Font.Ubuntu,
	}
	
	local current_font_name = "Gotham"
	if Stranded.fonts.labels then
		for name, font_enum in pairs(font_map) do
			if font_enum == Stranded.fonts.labels then
				current_font_name = name
				break
			end
		end
	end
	
	SettingsSection:Dropdown({Name = "Label Font", Flag = "Label Font", Default = current_font_name, Items = font_names, Callback = function(Value)
		if font_map[Value] then
			Stranded.fonts.labels = font_map[Value]
		end
	end})
	
	SettingsSection:Dropdown({Name = "Tweening Style", Flag = "Tweening Style", Default = "Exponential", Items = {"Linear", "Sine", "Quad", "Cubic", "Quart", "Quint", "Exponential", "Circular", "Back", "Elastic", "Bounce"}, Callback = function(Value)
		Library.Tween.Style = Enum.EasingStyle[Value]
	end})
	
	SettingsSection:Dropdown({Name = "Tweening Direction", Flag = "Tweening Direction", Default = "Out", Items = {"In", "Out", "InOut"}, Callback = function(Value)
		Library.Tween.Direction = Enum.EasingDirection[Value]
	end})
	
	SettingsSection:Slider({Name = "Tweening Time", Min = 0, Max = 5, Default = 0.25, Suffix = "s", Decimals = 0.01, Compact = true, Flag = "Tweening Time", Callback = function(Value)
		Library.Tween.Time = Value
	end})
	
	SettingsSection:Button({Name = "Notification test", Callback = function()
		Library:Notification("This is a notification", 5, Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255)))
	end})
	
	SettingsSection:Button({Name = "Unload library", Callback = function()
		Library:Unload()
	end})
	
	local ConfigName 
	local ConfigSelected
	
	local ConfigsListbox = ConfigsSection:Listbox({Items = { }, Name = "Configs", Flag = "Configs List", Callback = function(Value)
		ConfigSelected = Value
	end})
	
	ConfigsSection:Textbox({Name = "Config Name", Placeholder = ". .", Flag = "Config Name", Callback = function(Value)
		ConfigName = Value
	end})
	
	ConfigsSection:Button({Name = "Create Config", Callback = function()
		if not isfile(Library.Folders.Configs .. "/" .. ConfigName .. ".json") then
			writefile(Library.Folders.Configs .. "/" .. ConfigName .. ".json", Library:GetConfig())
			Library:RefreshConfigsList(ConfigsListbox)
		else
			Library:Notification("Config '" .. ConfigName .. ".json' already exists", 3, Color3.fromRGB(255, 0, 0))
			return
		end
	end})
	
	ConfigsSection:Button({Name = "Load Config", Callback = function()
		if ConfigSelected then
			-- =========================
-- SAFE CONFIG LOADER
-- =========================

local function SafeLoadConfig(ConfigName)
    --   
    if not ConfigName or ConfigName == "" then
        warn("No config selected")
        return
    end

    --      
    local cleanName = tostring(ConfigName):gsub(Library.Folders.Configs .. "/", "")

    --  
    local path = Library.Folders.Configs .. "/" .. cleanName

    print("Loading config from:", path)

    --   
    if not isfile(path) then
        warn("Config file not found:", path)
        return
    end

    --    
    local tries = 0
    repeat
        task.wait(0.5)
        tries += 1
    until (Library and Library.LoadConfig) or tries >= 10

    if not Library or not Library.LoadConfig then
        warn("Library not ready to load config")
        return
    end

    --  
    local success, data = pcall(readfile, path)
    if not success then
        warn("Failed to read config file")
        return
    end

    --   
    local loaded, err = pcall(function()
        Library:LoadConfig(data)
    end)

    if loaded then
        print("Config loaded successfully:", cleanName)
    else
        warn("Config load error:", err)
    end
end
		end
		
		if esp and esp.funcs and esp.funcs.fix_corrupted_fog_values then
			esp.funcs.fix_corrupted_fog_values()
		end
		
		Library:Thread(function()
			task.wait(0.1)
			if Library.SetFlags["Fog Start"] then
				Library.SetFlags["Fog Start"](safe_number(Stranded.lighting.fog.start, 0))
			end
			if Library.SetFlags["Fog End"] then
				Library.SetFlags["Fog End"](safe_number(Stranded.lighting.fog.ending, 500))
			end
			if Library.SetFlags["Fog Start Misc"] then
				Library.SetFlags["Fog Start Misc"](safe_number(Stranded.lighting.fog.start, 0))
			end
			if Library.SetFlags["Fog End Misc"] then
				Library.SetFlags["Fog End Misc"](safe_number(Stranded.lighting.fog.ending, 500))
			end
			
			for Index, Value in Library.Theme do 
				Library.Theme[Index] = Library.Flags["Theme"..Index].Color
				Library:ChangeTheme(Index, Library.Flags["Theme"..Index].Color)
			end    
		end)
	end})
	
	ConfigsSection:Button({Name = "Delete Config", Callback = function()
		if ConfigSelected then
			Library:DeleteConfig(ConfigSelected)
			Library:RefreshConfigsList(ConfigsListbox)
		end
	end})
	
	ConfigsSection:Button({Name = "Save Config", Callback = function()
		if ConfigSelected then
			Library:SaveConfig(ConfigSelected)
		end
	end})
	
	ConfigsSection:Button({Name = "Refresh Configs", Callback = function()
		Library:RefreshConfigsList(ConfigsListbox)
	end})
	
	Library:RefreshConfigsList(ConfigsListbox)
end

local function safe_number(value, default)
	if value and type(value) == "number" and not (value ~= value) and value == value then
		return value
	end
	return default or 0
end

task.spawn(function()
	task.wait(0.5)
	if esp and esp.funcs and esp.funcs.fix_corrupted_fog_values then
		esp.funcs.fix_corrupted_fog_values()
		if Library and Library.SetFlags and safe_number then
			if Library.SetFlags["Fog Start"] then
				Library.SetFlags["Fog Start"](safe_number(Stranded.lighting.fog.start, 0))
			end
			if Library.SetFlags["Fog End"] then
				Library.SetFlags["Fog End"](safe_number(Stranded.lighting.fog.ending, 500))
			end
			if Library.SetFlags["Fog Start Misc"] then
				Library.SetFlags["Fog Start Misc"](safe_number(Stranded.lighting.fog.start, 0))
			end
			if Library.SetFlags["Fog End Misc"] then
				Library.SetFlags["Fog End Misc"](safe_number(Stranded.lighting.fog.ending, 500))
			end
		end
	end
	end)
	
	Library:Notification("stranded . lol loaded successfully", 5, Library.Theme.Accent)
	end)
end)

if not success_ui then
	warn("Failed to create UI: " .. tostring(err))
	print("UI Error:", err)
end
